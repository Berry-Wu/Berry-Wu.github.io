<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis实战 | Wzy's Blog</title><meta name="author" content="wzy"><meta name="copyright" content="wzy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis的实战部分">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis实战">
<meta property="og:url" content="http://example.com/2023/07/13/Redis%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="Wzy&#39;s Blog">
<meta property="og:description" content="Redis的实战部分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cheems.jpg">
<meta property="article:published_time" content="2023-07-13T02:47:40.000Z">
<meta property="article:modified_time" content="2023-07-25T05:45:05.747Z">
<meta property="article:author" content="wzy">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cheems.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/07/13/Redis%E5%AE%9E%E6%88%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis实战',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-25 13:45:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cheems.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/bk2.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Wzy's Blog"><span class="site-name">Wzy's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-13T02:47:40.000Z" title="发表于 2023-07-13 10:47:40">2023-07-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-25T05:45:05.747Z" title="更新于 2023-07-25 13:45:05">2023-07-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis%E5%AD%A6%E4%B9%A0/">Redis学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">42.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>163分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>视频学习：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cr4y1671t/">黑马Redis入门到实战</a></p>
<p>课程资料：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1189u6u4icQYHg_9_7ovWmA?pwd=eh11">链接</a>   提取码：eh11</p>
<p>学习路线及部分内容参考：<a target="_blank" rel="noopener" href="https://cyborg2077.github.io/">Kyle’s Blog</a></p>
</blockquote>
<h1 id="内容概述"><a href="#内容概述" class="headerlink" title="内容概述"></a>内容概述</h1><p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713111559810.png" alt="image-20230713111559810"></p>
<hr>
<h1 id="短信登陆"><a href="#短信登陆" class="headerlink" title="短信登陆"></a>短信登陆</h1><h2 id="项目导入"><a href="#项目导入" class="headerlink" title="项目导入"></a>项目导入</h2><ul>
<li>资料中导入<strong>SQL</strong>文件，所提供表的内容如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">表</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">tb_user</td>
<td>用户表</td>
</tr>
<tr>
<td align="left">tb_user_info</td>
<td>用户详情表</td>
</tr>
<tr>
<td align="left">tb_shop</td>
<td>商户信息表</td>
</tr>
<tr>
<td align="left">tb_shop_type</td>
<td>商户类型表</td>
</tr>
<tr>
<td align="left">tb_blog</td>
<td>用户日记表（达人探店日记)</td>
</tr>
<tr>
<td align="left">tb_follow</td>
<td>用户关注表</td>
</tr>
<tr>
<td align="left">tb_voucher</td>
<td>优惠券表</td>
</tr>
<tr>
<td align="left">tb_voucher_order</td>
<td>优惠券的订单表</td>
</tr>
</tbody></table>
<ul>
<li><p>导入<strong>后端</strong>项目：同样已经放在资源中了，修改Mysql和Redis的相关配置。启动项目后访问<a target="_blank" rel="noopener" href="http://localhost:8081/shop-type/list">http://localhost:8081/shop-type/list</a> ，如果可以看到JSON数据，则说明导入成功</p>
<ul>
<li><p>这里我修改了数据库连接驱动为8以后版本，所以对应修改了maven依赖和驱动名称</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>页面显示：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713114244441.png" alt="image-20230713114244441"></p>
</li>
</ul>
</li>
<li><p>导入<strong>前端</strong>项目：这里也是直接拿资源中的nginx项目解压即可，其中已经包含了hmdp的前端资源，位于html文件夹下。</p>
<ul>
<li><p>nginx文件结构：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713114522356.png" alt="image-20230713114522356"></p>
</li>
<li><p>在<code>nginx所在目录</code>打开一个cmd窗口，输入命令：<code>start nginx.exe</code>，即可启动项目</p>
</li>
<li><p>访问<a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a> ，打开开发者模式，就可以看到页面</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713114914727.png" alt="image-20230713114914727"></p>
</li>
</ul>
</li>
</ul>
<h2 id="基于Session实现登录"><a href="#基于Session实现登录" class="headerlink" title="基于Session实现登录"></a>基于Session实现登录</h2><h3 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h3><ol>
<li>发送验证码<br>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号<br>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</li>
<li>短信验证码登录、注册<br>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</li>
<li>校验登录状态<br>用户在请求的时候，会从cookie中携带JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并放行</li>
</ol>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713155947666.png" alt="image-20230713155947666"></p>
<h3 id="发送验证码"><a href="#发送验证码" class="headerlink" title="发送验证码"></a>发送验证码</h3><p>首先进入<code>我的</code>页面，第一次进入会显示手机验证码登录，这里点击发送验证码按钮，发送如下请求：</p>
<blockquote>
<p>Request URL: <a target="_blank" rel="noopener" href="http://localhost:8080/api/user/code?phone=13264429299">http://localhost:8080/api/user/code?phone=13264429299</a></p>
<p>Request Method: POST</p>
</blockquote>
<p>可以看出，操作的内容是UserController，且方法拦截方法为<code>code</code>，携带参数<code>phone</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;code&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 发送短信验证码并保存验证码</span></span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;功能未完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改以上方法，这里我们通过调用service中的实现进行，不要把业务实现放在controller中，不便于重用和阅读。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;code&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 发送短信验证码并保存验证码</span></span><br><span class="line">    <span class="keyword">return</span> userService.sendCode(phone, session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再对应的serviceImpl中实现该方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="comment">//2.如果不符合返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.符合，生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">//4.保存验证码到session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line">    <span class="comment">//5.发送验证码</span></span><br><span class="line">    log.info(<span class="string">&quot;生成的验证码为：&#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：这里没有去真的发送验证码，想要改成邮箱验证参考瑞吉外卖部分</p>
</blockquote>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>上一步填上验证码后，点击登录发送请求和携带参数如下：</p>
<blockquote>
<p>Request URL:<a target="_blank" rel="noopener" href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p>
<p>Request Method:POST</p>
<p>{phone: “13264429299”, code: “404849”}</p>
</blockquote>
<p>可以看出是UserController中的login方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> LoginFormDTO loginForm, HttpSession session)</span>&#123;</span><br><span class="line">    <span class="comment">// TODO 实现登录功能</span></span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;功能未完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且使用的Dto来封装手机号和验证码。然后根据上述逻辑进行代码实现。依旧是写在serviceImpl中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="comment">//如果不符合返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.验证码不一致则报错</span></span><br><span class="line">    <span class="keyword">if</span> (code==<span class="literal">null</span> || !cacheCode.toString().equals(code))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;输入的验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.一致则先根据手机号查询用户</span></span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    lqw.eq(User::getPhone, phone);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getOne(lqw);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.用户不存在则创建,存在则继续执行程序</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//创建逻辑封装成了一个方法</span></span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;user信息：&#123;&#125;&quot;</span>, user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.保存用户信息到session中</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> User <span class="title function_">createUserWithPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">    <span class="comment">//1.创建用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setPhone(phone);</span><br><span class="line">    user.setNickName(<span class="string">&quot;游客&quot;</span>+phone);</span><br><span class="line">    <span class="comment">//2.保存用户信息</span></span><br><span class="line">    save(user);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>登录完后，数据库中就新增了用户数据：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713172326865.png" alt="image-20230713172326865"></p>
<blockquote>
<p>在上述功能完成期间，直接用课程资料中给的maven依赖会报错，我这里经过查阅，将<strong>mybatis-plus版本</strong>从3.4.3降到3.4.2后就正常运行</p>
</blockquote>
<h3 id="校验登录状态"><a href="#校验登录状态" class="headerlink" title="校验登录状态"></a>校验登录状态</h3><p>目前登录功能还有问题，当我们登录成功后，再点击我的，会发现还是让我们验证登录。这是因为我们还没完成登录校验功能，所以直接跳转到登录页面。</p>
<p>并且，不仅仅这个登录页面需要进行校验，很多controller都需要这个功能，所以这里可以通过设置一个<strong>拦截器</strong>，再所有的controller执行之前进行相应地操作。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713191707291.png" alt="image-20230713191707291"></p>
<p>这里创建一个<code>LoginInterceptor</code>类，实现<code>HandlerInterceptor</code>接口，重写其中的两个方法（快捷键<code>shift+alt+p</code>），前置拦截器和完成处理方法，<strong>前置拦截器</strong>主要用于登陆之前的权限校验，<strong>完成处理方法</strong>是用于处理登录后的信息，避免内存泄露</p>
<p><code>LoginInterceptor</code>：登录拦截器方法，将session中的信息保存在ThreadLocal中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//获取session中的用户信息</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (user==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//不存在，返回401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存在则保存用户信息到ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser((User) user);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserHolder</code>：使用ThreadLocal保存用户信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MvcConfig</code>：添加配置类，配置拦截器，并指定放行的请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                    <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/voucher/**&quot;</span></span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>/user/me</code>请求：这里返回登录用户信息，从而完成登录校验（登录校验的逻辑应该在前端实现的，对<code>/me</code>的ajax请求的返回进行判断，如果没有登录则跳转到指定页面）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/me&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">me</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TODO 获取当前登录的用户并返回</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    <span class="keyword">return</span> Result.ok(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时登录后就能正常显示<code>我的</code>页面：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713195147184.png" alt="image-20230713195147184"></p>
<h3 id="番外：ThreadLocal"><a href="#番外：ThreadLocal" class="headerlink" title="番外：ThreadLocal"></a>番外：ThreadLocal</h3><p>ThreadLocal可以解释成<strong>线程的局部变量</strong>，也就是说一个ThreadLocal的变量<strong>只有当前自身线程可以访问</strong>，别的线程都访问不了，那么自然就避免了线程竞争。</p>
<h3 id="番外：拦截器和过滤器"><a href="#番外：拦截器和过滤器" class="headerlink" title="番外：拦截器和过滤器"></a>番外：拦截器和过滤器</h3><blockquote>
<p>在上面我们用到了拦截器实现登录校验。但是一直不太清楚拦截器和过滤器具体使用场景和区别。所以这里进行了对比和总结。</p>
<p>这里参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xinzhifu1/article/details/106356958%E3%80%81https://zhuanlan.zhihu.com/p/408809649">https://blog.csdn.net/xinzhifu1/article/details/106356958、https://zhuanlan.zhihu.com/p/408809649</a></p>
</blockquote>
<h4 id="过滤器Filter"><a href="#过滤器Filter" class="headerlink" title="过滤器Filter"></a>过滤器Filter</h4><p>过滤器的配置比较简单，直接<strong>实现Filter 接口</strong>即可，也可以通过@WebFilter注解实现对特定URL拦截，看到Filter 接口中定义了三个方法。</p>
<ul>
<li><p><code>init()</code> ：该方法在容器启动初始化过滤器时被调用，它在 Filter 的整个生命周期只会被调用一次。注意：这个方法必须执行成功，否则过滤器会不起作用。</p>
</li>
<li><p><code>doFilter() </code>：容器中的每一次请求都会调用该方法， FilterChain 用来调用下一个过滤器 Filter。</p>
</li>
<li><p><code>destroy()</code>： 当容器销毁 过滤器实例时调用该方法，一般在方法中销毁或关闭资源，在过滤器 Filter 的整个生命周期也只会被调用一次</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Filter 前置&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Filter 处理中&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter 后置&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拦截器Interceptor"><a href="#拦截器Interceptor" class="headerlink" title="拦截器Interceptor"></a>拦截器Interceptor</h4><p>拦截器它是<strong>链式调用</strong>，一个应用中可以同时存在多个拦截器<code>Interceptor</code>， 一个请求也可以触发多个拦截器 ，而每个拦截器的调用会依据它的声明顺序依次执行。需要<strong>实现HandlerInterceptor接口</strong>。接口中也定义了三个方法：</p>
<ul>
<li><p><code>preHandle()</code> ：这个方法将在请求处理之前进行调用。注意：如果该方法的返回值为false ，将视为当前请求结束，不仅自身的拦截器会失效，还会导致其他的拦截器也不再执行。</p>
</li>
<li><p><code>postHandle()</code>：只有在 <code>preHandle() </code>方法返回值为true 时才会执行。会在Controller 中的方法调用之后，DispatcherServlet 返回渲染视图之前被调用。 </p>
<blockquote>
<p><code>postHandle()</code>方法被调用的顺序跟<code>preHandle() </code>是相反的，先声明的拦截器 <code>preHandle()</code> 方法先执行，而<code>postHandle()</code>方法反而会后执行。</p>
</blockquote>
</li>
<li><p><code>afterCompletion()</code>：只有在 <code>preHandle()</code>方法返回值为true 时才会执行。在整个请求结束之后， DispatcherServlet 渲染了对应的视图之后执行。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Interceptor 前置&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Interceptor 处理中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Interceptor 后置&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后可以创建一个config类实现<code>WebMvcConfigurer</code>接口，重写<code>addInterceptors</code>方法，在其中通过<code>addPathPatterns</code>、<code>excludePathPatterns</code>等属性设置需要拦截或需要排除的 <code>URL</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">            		<span class="string">&quot;/xxx/yy&quot;</span>,</span><br><span class="line">            		<span class="string">&quot;/xxx/zz&quot;</span>,</span><br><span class="line">            		<span class="string">&quot;/ddd/ff&quot;</span></span><br><span class="line">            	); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li><p>过滤器是基于<strong>函数回调</strong>，拦截器是基于java的<strong>反射机制</strong></p>
</li>
<li><p>过滤器属于<strong>Servlet级别</strong>，拦截器属于Spring级别 ****</p>
<ul>
<li>Filter是在javax.servlet包中定义的，要依赖于网络容器，因此只能在web项目中使用。</li>
<li>Interceptor是SpringMVC中实现的，拦截器是一个Spring组件，由Spring容器进行管理。</li>
</ul>
</li>
<li><p>执行顺序不同：</p>
<ul>
<li>当一个请求进入Servlet之前，过滤器的<code>doFilter</code>方法进行过滤，进入Servlet容器之后，执行Controller方法之前，拦截器的<code>preHandle</code>方法进行拦截，执行Controller方法之后，视图渲染之前，拦截器的<code>postHandle</code>方法进行拦截，请求结束之后，执行拦截器的<code>postHandle</code>方法。</li>
<li><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230714113359939.png" alt="image-20230714113359939"></li>
</ul>
</li>
<li><p>二者实际开发中的应用场景：</p>
<ul>
<li><strong>拦截器</strong>：权限控制（登录校验），日志打印，参数校验</li>
<li><strong>过滤器</strong>：跨域问题解决，编码转换</li>
</ul>
</li>
</ul>
<h3 id="隐藏用户敏感信息"><a href="#隐藏用户敏感信息" class="headerlink" title="隐藏用户敏感信息"></a>隐藏用户敏感信息</h3><p>在上面的内容中，我们可以在<code>/user/me</code>的请求返回值中看到如下用户的全部信息，这样会泄露用户的信息。所以这里在返回用户信息前，将其敏感信息进行隐藏。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1013</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span><span class="string">&quot;13264429111&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;nickName&quot;</span><span class="punctuation">:</span><span class="string">&quot;游客13264429111&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;createTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2023-07-13T19:12:59&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;updateTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2023-07-13T19:12:59&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>核心思想就是实现一个<code>UserDto</code>类，其中只包含用户名，头像和id即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> String icon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改UserHolder，将其User类型都换为UserDto</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且对应修改<code>/login</code>方法，在将用户信息存入session中时只存UserDto类型</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    @Override</span><br><span class="line">    public Result login(LoginFormDTO loginForm, HttpSession session) &#123;</span><br><span class="line">        String phone = loginForm.getPhone();</span><br><span class="line">        String code = loginForm.getCode();</span><br><span class="line">        Object cacheCode = session.getAttribute(&quot;code&quot;);</span><br><span class="line"></span><br><span class="line">        //1.校验手机号</span><br><span class="line">        if(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">            //如果不符合返回错误信息</span><br><span class="line">            return Result.fail(&quot;手机号格式错误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //2.验证码不一致则报错</span><br><span class="line">        if (code==null || !cacheCode.toString().equals(code))&#123;</span><br><span class="line">            return Result.fail(&quot;输入的验证码错误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.一致则先根据手机号查询用户</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        lqw.eq(User::getPhone, phone);</span><br><span class="line">        User user = getOne(lqw);</span><br><span class="line"></span><br><span class="line">        //4.用户不存在则创建,存在则继续执行程序</span><br><span class="line">        if (user == null) &#123;</span><br><span class="line">            //创建逻辑封装成了一个方法</span><br><span class="line">            user = createUserWithPhone(phone);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(&quot;user信息：&#123;&#125;&quot;, user);</span><br><span class="line"></span><br><span class="line">        //5.保存用户信息到session中</span><br><span class="line"><span class="deletion">-       session.setAttribute(&quot;user&quot;, user);</span></span><br><span class="line"><span class="addition">+       UserDTO userDTO = new UserDTO();</span></span><br><span class="line"><span class="addition">+       BeanUtils.copyProperties(user, userDTO);</span></span><br><span class="line"><span class="addition">+       session.setAttribute(&quot;user&quot;, userDTO);</span></span><br><span class="line">        return Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>同时也要修改拦截器中的方法</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        //获取session</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        //获取session中的用户信息</span><br><span class="line">        Object user = session.getAttribute(&quot;user&quot;);</span><br><span class="line">        //判断用户是否存在</span><br><span class="line">        if (user==null)&#123;</span><br><span class="line">            //不存在，返回401状态码</span><br><span class="line">            response.setStatus(401);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //存在则保存用户信息到ThreadLocal</span><br><span class="line"><span class="deletion">-       UserHolder.saveUser((User) user);</span></span><br><span class="line"><span class="addition">+       UserHolder.saveUser((UserDTO) user);</span></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此时再查看返回的内容，可见不包含敏感信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1013</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;nickName&quot;</span><span class="punctuation">:</span><span class="string">&quot;游客13264429111&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="基于Redis实现共享Session登录"><a href="#基于Redis实现共享Session登录" class="headerlink" title="基于Redis实现共享Session登录"></a>基于Redis实现共享Session登录</h2><h3 id="集群的Session共享问题"><a href="#集群的Session共享问题" class="headerlink" title="集群的Session共享问题"></a>集群的Session共享问题</h3><p><strong>session共享问题：</strong>多台Tomcat并不共享session的存储空间，当请求切换到不同tomcat服务器上时导致数据丢失的问题</p>
<p>早期的方案是<strong>session拷贝</strong>，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了。但是这种方法存在很大的缺点：每台服务器中都有完整的一份session数据，服务器压力过大；session拷贝数据时，可能会出现延迟。</p>
<p>session的替代方案应该满足：数据共享、内存存储和key-value结构。这自然想到<strong>Redis</strong></p>
<h3 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h3><ul>
<li>保存登录的用户信息，可以使用String结构，以JSON字符串来保存，比较直观</li>
</ul>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713212409863.png" alt="image-20230713212409863"></p>
<ul>
<li>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD，并且内存占用更少。（本项目以Hash存储）</li>
</ul>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713212420023.png" alt="image-20230713212420023"></p>
<p>对于保存用户手机号和验证码，采用String结构，以手机号为key，以验证码为value。</p>
<p>对于保存用户登录状态，采用Hash结构，以<strong>随机token</strong>为key存储用户数据，而不是将手机号作为key，因为这会造成用户信息的泄露。</p>
<h3 id="基于Redis实现验证码登录"><a href="#基于Redis实现验证码登录" class="headerlink" title="基于Redis实现验证码登录"></a>基于Redis实现验证码登录</h3><p>注入<code>StringRedisTemplate</code></p>
<ul>
<li><p>修改<code>sendCode</code></p>
<blockquote>
<p>key以手机号存储，同时加上业务逻辑便于查看。并且可以定义一个常量类来替换<code>login:code:</code>和<code>2</code>。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="comment">//2.如果不符合返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.符合，生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">//4.保存验证码到session</span></span><br><span class="line">    <span class="comment">//session.setAttribute(&quot;code&quot;, code);</span></span><br><span class="line">    <span class="comment">//4.保存验证码到redis</span></span><br><span class="line">    <span class="comment">//stringRedisTemplate.opsForValue().set(&quot;login:code:&quot;+phone, code,2, TimeUnit.MINUTES);</span></span><br><span class="line">	stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY+phone, code,LOGIN_CODE_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">//5.发送验证码(这里没有去真的发送验证码，想要改成邮箱验证参考瑞吉外卖部分)</span></span><br><span class="line">    log.info(<span class="string">&quot;生成的验证码为：&#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>常量类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConstants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOGIN_CODE_KEY</span> <span class="operator">=</span> <span class="string">&quot;login:code:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">LOGIN_CODE_TTL</span> <span class="operator">=</span> <span class="number">2L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOGIN_USER_KEY</span> <span class="operator">=</span> <span class="string">&quot;login:token:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">LOGIN_USER_TTL</span> <span class="operator">=</span> <span class="number">36000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">CACHE_NULL_TTL</span> <span class="operator">=</span> <span class="number">2L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">CACHE_SHOP_TTL</span> <span class="operator">=</span> <span class="number">30L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CACHE_SHOP_KEY</span> <span class="operator">=</span> <span class="string">&quot;cache:shop:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_SHOP_KEY</span> <span class="operator">=</span> <span class="string">&quot;lock:shop:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">LOCK_SHOP_TTL</span> <span class="operator">=</span> <span class="number">10L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SECKILL_STOCK_KEY</span> <span class="operator">=</span> <span class="string">&quot;seckill:stock:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BLOG_LIKED_KEY</span> <span class="operator">=</span> <span class="string">&quot;blog:liked:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FEED_KEY</span> <span class="operator">=</span> <span class="string">&quot;feed:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SHOP_GEO_KEY</span> <span class="operator">=</span> <span class="string">&quot;shop:geo:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER_SIGN_KEY</span> <span class="operator">=</span> <span class="string">&quot;sign:&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改<code>login</code></li>
</ul>
<blockquote>
<p>注意：直接按照老师代码会报错，这里将userMap中的value全转化为String类型才行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="comment">//通过session获取验证码</span></span><br><span class="line">    <span class="comment">//Object cacheCode = session.getAttribute(&quot;code&quot;);</span></span><br><span class="line">    <span class="comment">//通过redis获取验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY+phone);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="comment">//如果不符合返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.验证码不一致则报错</span></span><br><span class="line">    <span class="keyword">if</span> (code==<span class="literal">null</span> || !cacheCode.equals(code))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;输入的验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.一致则先根据手机号查询用户</span></span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    lqw.eq(User::getPhone, phone);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getOne(lqw);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.用户不存在则创建,存在则继续执行程序</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//创建逻辑封装成了一个方法</span></span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;user信息：&#123;&#125;&quot;</span>, user);</span><br><span class="line"></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDTO</span>();</span><br><span class="line">    BeanUtils.copyProperties(user, userDTO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.保存用户信息到session中</span></span><br><span class="line">    <span class="comment">//session.setAttribute(&quot;user&quot;, userDTO);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.保存用户信息到redis</span></span><br><span class="line">    <span class="comment">//5.1 随机生成token，作为登录令牌</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//5.2 将UserDto对象转为hash存储</span></span><br><span class="line">    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO);</span><br><span class="line">    <span class="comment">//这里将value全转换为String类型，因为userDto中的id是Long型，直接存入hash结构会报错</span></span><br><span class="line">    userMap.forEach((key, value) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != value) userMap.put(key, String.valueOf(value));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//5.3 存储</span></span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY+token, userMap);</span><br><span class="line">    <span class="comment">//设定token的有效期</span></span><br><span class="line">    stringRedisTemplate.expire(LOGIN_USER_KEY+token, LOGIN_USER_TTL,TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>经过这样的修改后，就可以在redis中看到缓存的数据。但是此时就会校验登录失败，因为之前实现是使用session，这里修改成redis，需要对应的修改。</p>
<p>此外，注意<strong>返回时要带上token</strong>，因为前端进行了数据判断，如果不携带token就会重新验证码登录</p>
</blockquote>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713222244886.png" alt="image-20230713222244886"></p>
<h3 id="解决状态登录刷新问题"><a href="#解决状态登录刷新问题" class="headerlink" title="解决状态登录刷新问题"></a>解决状态登录刷新问题</h3><p>之前设置了用户信息在redis中存活30分钟，但是此时无论用户是否有操作，30分钟一到都会被删除，这是不合理的。这里可以<strong>通过拦截器拦截到的请求</strong>，来证明用户是否在操作，如果用户没有任何操作30分钟，则token会消失，用户需要重新登录</p>
<h4 id="初步版本"><a href="#初步版本" class="headerlink" title="初步版本"></a>初步版本</h4><ul>
<li><p>首先通过查看前端请求，发现<strong>存的token在请求头里</strong>（这部分前端实现）</p>
<p><code>authorization: 6867061d-a8d0-4e60-b92f-97f7d698a1ca</code></p>
</li>
<li><p>修改<code>LoginInterceptor</code>类</p>
<blockquote>
<p>注意：这里不能直接注入StringRedisTemplate，因为这个类并没有给String容器管理，所以使用以下方法进行赋值实现。</p>
<p>而在<code>MvcConfig</code>中调用时进行依赖的注入，因为这个类标注了<code>@Configuration</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token))&#123;</span><br><span class="line">            <span class="comment">//不存在，返回401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.基于token获取redis中的用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//不存在，返回401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.将查询到的Hash数据转为UserDto对象</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.将userDto保存在TheadLocal中</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.刷新token的有效期</span></span><br><span class="line">        stringRedisTemplate.expire(key, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上述操作6中，会设置token数据的有效期，而每一次操作页面就会触发拦截器，所以只要用户在活跃状态，这个用户信息就不会过期。</p>
</blockquote>
</li>
<li><p><code>MvcConfig</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>(stringRedisTemplate))</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                    <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/voucher/**&quot;</span></span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>此时再运行，可以看到redis数据库中的数据和前端请求头中的<code>authorization</code>一致。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713225510663.png" alt="image-20230713225510663"></p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713225540560.png" alt="image-20230713225540560"></p>
<p>目前这个拦截器只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713225826186.png" alt="image-20230713225826186"></p>
<h4 id="优化版本"><a href="#优化版本" class="headerlink" title="优化版本"></a>优化版本</h4><p>可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713230004843.png" alt="image-20230713230004843"></p>
<ol>
<li><p>首先新建一个拦截器<code>RefreshTokenInterceptor</code>，将之前的拦截器主要逻辑粘在这里，但是并<strong>不做拦截操作，而是全部放行</strong>，主要功能是获取token将用户信息保存在Threadloacl并且刷新token的有效期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.基于token获取redis中的用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.将查询到的Hash数据转为UserDto对象</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.将userDto保存在TheadLocal中</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.刷新token的有效期</span></span><br><span class="line">        stringRedisTemplate.expire(key, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改原来的拦截器，只需要对ThreadLocal中的数据判断是否为空即可，为空则拦截。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//判断是否需要拦截(ThreadLocal中是否有用户)</span></span><br><span class="line">        <span class="keyword">if</span> (UserHolder.getUser()==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//没有则需要拦截，设置状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="comment">//拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有用户则放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时修改对应的配置类<code>MvcConfig</code>，此时<code>LoginInterceptor</code>不需要传入stringRedisTemplate了，并且设置<code>ReefreshTokenInterceptor</code>的注册，设置拦截所有路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                    <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/voucher/**&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate))</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：这里可以使用<code>order</code>函数设置拦截器的执行顺序，我们把<code>RefreshTokenInterceptor</code>的优先级设为最高。</p>
</blockquote>
</li>
</ol>
<p>此时，通过Redis图行界面查看数据的TTL，每次更换访问页面，token的TTL就会刷新。</p>
<hr>
<h1 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h1><h2 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h2><p>缓存就是数据交换的缓存区，是存储数据的临时地方，一般读写性能较高。</p>
<p>缓存的作用：</p>
<ul>
<li>降低后端负载</li>
<li>提高读写效率，降低响应时间</li>
</ul>
<p>缓存的成本：</p>
<ul>
<li>数据一致性成本</li>
<li>代码维护成本</li>
<li>运维成本</li>
</ul>
<h2 id="添加商户缓存"><a href="#添加商户缓存" class="headerlink" title="添加商户缓存"></a>添加商户缓存</h2><h3 id="原本查询方法"><a href="#原本查询方法" class="headerlink" title="原本查询方法"></a>原本查询方法</h3><p>启动前端和后端的项目，登陆之后访问一个商户，查看浏览器发送的请求</p>
<blockquote>
<p>Request URL: <a target="_blank" rel="noopener" href="http://localhost:8080/api/shop/1">http://localhost:8080/api/shop/1</a></p>
<p>Request Method: GET</p>
</blockquote>
<p>可以看出在<code>ShopController</code>中的实现，原本的代码直接从数据库进行查询，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shopService.getById(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加缓存模型"><a href="#添加缓存模型" class="headerlink" title="添加缓存模型"></a>添加缓存模型</h3><p>可以在客户端与数据库之间加上一个Redis缓存，先从Redis中查询，如果没有查到，再去MySQL中查询，同时查询完毕之后，将查询到的数据也存入Redis，这样当下一个用户来进行查询的时候，就可以直接从Redis中获取到数据</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230714150534787.png" alt="image-20230714150534787"></p>
<p>对应的代码逻辑如下所示：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230714150543594.png" alt="image-20230714150543594"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>在Service中实现业务逻辑。</p>
<p><code>ShopController</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> shopService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IShopService</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IShopService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Shop&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Result <span class="title function_">queryById</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小技巧：快捷键<code>ctrl+alt+B</code>：直接跳转对应的实现类</p>
</blockquote>
<p><code>ShopServiceImpl</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ShopMapper, Shop&gt; <span class="keyword">implements</span> <span class="title class_">IShopService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">            <span class="comment">//3.存在，直接返回</span></span><br><span class="line">            <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.存在，写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<p>此时商铺信息就会存储在Redis数据库中：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230714152421152.png" alt="image-20230714152421152"></p>
<h2 id="添加商户类型缓存"><a href="#添加商户类型缓存" class="headerlink" title="添加商户类型缓存"></a>添加商户类型缓存</h2><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>商户类型指的是首页上方的几种类型：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230714152543289.png" alt="image-20230714152543289"></p>
<p>此时点击任意一种类型，会发送如下请求</p>
<blockquote>
<p>Request URL: <a target="_blank" rel="noopener" href="http://localhost:8080/api/shop-type/list">http://localhost:8080/api/shop-type/list</a></p>
<p>Request Method: GET</p>
</blockquote>
<p>可以看出是属于<code>ShopTypeController</code>中的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryTypeList</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;ShopType&gt; typeList = typeService</span><br><span class="line">        .query().orderByAsc(<span class="string">&quot;sort&quot;</span>).list();</span><br><span class="line">    <span class="keyword">return</span> Result.ok(typeList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要需要缓存的就是查询出的商户列表。像之前一样，还是将业务逻辑写在Service中。</p>
<p><code>ShopTypeController</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryTypeList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> typeService.queryList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ShopTypeServiceImpl</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopTypeServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ShopTypeMapper, ShopType&gt; <span class="keyword">implements</span> <span class="title class_">IShopTypeService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//首先根据key从redis中查询缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_TYPE_KEY;</span><br><span class="line">        <span class="type">String</span> <span class="variable">shopTypes</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//如果缓存不为空，则将返回的json字符串转换为类型列表，并且返回查询结果</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopTypes))&#123;</span><br><span class="line">            List&lt;ShopType&gt; typeList = JSONUtil.toList(shopTypes, ShopType.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(typeList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果为空，则进行sql查询，获取类型列表</span></span><br><span class="line">        List&lt;ShopType&gt; typeList = query().orderByAsc(<span class="string">&quot;sort&quot;</span>).list();</span><br><span class="line">        <span class="keyword">if</span> (typeList.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;分类信息为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果sql查询不为空，则将查询的列表转化为json字符串，将其存入redis中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(typeList);</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, jsonStr);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(typeList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时可以看到redis数据库中缓存到了商户类型</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230714163302426.png" alt="image-20230714163302426"></p>
<h3 id="番外：JSONUtil工具类"><a href="#番外：JSONUtil工具类" class="headerlink" title="番外：JSONUtil工具类"></a>番外：JSONUtil工具类</h3><p>这里对<code>JSONUtil</code>的几个常用方法进行记录：</p>
<ul>
<li><p><code>toBean(JSON json, Type beanType)</code>：将json转化为指定的实体类</p>
</li>
<li><p><code>toList(String jsonArray, Class&lt;T&gt; elementType )</code>：将<strong>JSONArray字符串</strong>转换为Bean的List</p>
</li>
<li><p><code>toJsonStr(JSON json)</code>：将<strong>实体类或实体类列表</strong>转为JSON字符串</p>
</li>
</ul>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJOSNUtil</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;wzy&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;yzw&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    List&lt;Stu&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(stu1);</span><br><span class="line">    list.add(stu2);</span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(list);</span><br><span class="line">    System.out.println(jsonStr);</span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr1</span> <span class="operator">=</span> JSONUtil.toJsonStr(stu1);</span><br><span class="line">    System.out.println(jsonStr1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Stu stu : JSONUtil.toList(jsonStr, Stu.class)) &#123;</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(JSONUtil.toBean(jsonStr1, Stu.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&quot;name&quot;:&quot;wzy&quot;,&quot;age&quot;:12&#125;,&#123;&quot;name&quot;:&quot;yzw&quot;,&quot;age&quot;:23&#125;]</span><br><span class="line">&#123;&quot;name&quot;:&quot;wzy&quot;,&quot;age&quot;:12&#125;</span><br><span class="line"></span><br><span class="line">Stu(name=wzy, age=12)</span><br><span class="line">Stu(name=yzw, age=23)</span><br><span class="line"></span><br><span class="line">Stu(name=wzy, age=12)</span><br></pre></td></tr></table></figure>

<h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><h3 id="常见更新策略"><a href="#常见更新策略" class="headerlink" title="常见更新策略"></a>常见更新策略</h3><p>因为Redis数据在内存中存储，插入太多数据，会导致缓存中数据过多，所以需要对缓存进行更新。常见的更新策略如下：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">内存淘汰</th>
<th align="center">超时剔除</th>
<th align="center">主动更新</th>
</tr>
</thead>
<tbody><tr>
<td align="center">说明</td>
<td align="center">不用自己维护， 利用Redis的内存淘汰机制， 当内存不足自动淘汰部分数据。 下次查询时更新缓存。</td>
<td align="center">给缓存数据添加TTL时间， 到期后自动删除缓存。 下次查询时更新缓存。</td>
<td align="center">编写业务逻辑， 在修改数据库的同时， 更新缓存。</td>
</tr>
<tr>
<td align="center">一致性</td>
<td align="center">差</td>
<td align="center">一般</td>
<td align="center">好</td>
</tr>
<tr>
<td align="center">维护成本</td>
<td align="center">无</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
</tbody></table>
<p>业务场景</p>
<ul>
<li>低一致性需求：使用内存淘汰机制，例如店铺类型的查询缓存）</li>
<li>高一致性需求：主动更新，并以超时剔除作为兜底方案，例如店铺详情查询的缓存、优惠券缓存</li>
</ul>
<h3 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h3><p>缓存数据源来自数据库，如果当数据库中数据发生变化，而缓存却没有同步，此时就导致一致性问题。有以下三种方案：</p>
<ol>
<li><code>Cache Aside Pattern</code> 人工编码方式：缓存调用者在更新完数据库之后再去更新缓存，也称之为双写方案</li>
<li><code>Read/Write Through Pattern</code>：缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。但是维护这样一个服务很复杂，市面上也不容易找到这样的一个现成的服务，开发成本高</li>
<li><code>Write Behind Caching Pattern</code>：调用者只操作缓存，其他线程去异步处理数据库，最终实现一致性。但是维护这样的一个异步的任务很复杂，需要实时监控缓存中的数据更新，其他线程去异步更新数据库也可能不太及时，而且缓存服务器如果宕机，那么缓存的数据也就丢失了</li>
</ol>
<p>在以上三种方法中，更多采用<strong>方案一</strong>。</p>
<p>操作缓存和数据库时有三个问题需要考虑：</p>
<ol>
<li><p>删除缓存还是更新缓存？</p>
<ul>
<li>更新缓存：每次更新数据库都更新缓存，无效写操作较多。❎</li>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存。✅</li>
</ul>
</li>
<li><p>如何保证缓存与数据库的操作的同步成功或失败？</p>
<ul>
<li>单体系统，将缓存与数据库放在一个事务</li>
<li>分布式系统，使用TTC等分布式事务</li>
</ul>
</li>
<li><p>先操作缓存还是先操作数据库？</p>
<ul>
<li><p>先删除缓存：</p>
<p>删除缓存的操作很快，更新数据库的操作相对较慢。在线程1进行修改时，如果此时有一个线程2进来查询缓存，由于刚刚删除缓存，所以线程2需要查询数据库，并写入缓存，但是更新数据库的操作还未完成，所以线程2此时缓存的数据和数据库中的数据不一致，出现线程安全问题。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230714171323199.png" alt="image-20230714171323199"></p>
</li>
<li><p>先删除数据库</p>
<p>线程1在查询缓存的时候，缓存TTL刚好失效，需要查询数据库并写入缓存，这个操作耗时相对较短，但是就在这么短的时间内，线程2进来了，更新数据库，删除缓存，但是线程1虽然查询完了数据（更新前的旧数据），但是还没来得及写入缓存，所以线程2的更新数据库与删除缓存，并没有影响到线程1的查询旧数据，写入缓存，造成线程安全问题</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230714172852683.png" alt="image-20230714172852683"></p>
</li>
<li><p>二者相比，后者出现线程安全问题的概率相对较低，所以通常采用<strong>先操作数据库，再删除缓存</strong>的方案</p>
</li>
</ul>
</li>
</ol>
<h3 id="实现商铺缓存与数据库双写一致"><a href="#实现商铺缓存与数据库双写一致" class="headerlink" title="实现商铺缓存与数据库双写一致"></a>实现商铺缓存与数据库双写一致</h3><p>修改ShopController中的业务逻辑，满足以下要求</p>
<ol>
<li>根据id查询店铺时，如果缓存未命中，则查询数据库，并将数据库结果写入缓存，并设置超时时间</li>
<li>根据id修改店铺时，先修改数据库，再删除缓存</li>
</ol>
<p>修改：</p>
<ol>
<li><p>修改ShopService的queryById方法，写入缓存时设置一下超时时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, Time)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改Controller中的<code>updateShop</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">updateShop</span><span class="params">(<span class="meta">@RequestBody</span> Shop shop)</span> &#123;</span><br><span class="line">    <span class="comment">// 写入数据库</span></span><br><span class="line">    <span class="keyword">return</span> shopService.update(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>serviceImpl实现对应的update方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">    <span class="keyword">if</span> (id==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺id不能为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.更新数据库</span></span><br><span class="line">    updateById(shop);</span><br><span class="line">    <span class="comment">//2.删除缓存</span></span><br><span class="line">    stringRedisTemplate.delete(RedisConstants.CACHE_SHOP_KEY+id);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：该方法需要声明为事务，因为涉及sql数据库操作和redis数据库操作，一旦其中有一个错误就回滚。</p>
</blockquote>
</li>
<li><p>然后启动项目，点击餐厅，将其数据缓存到Redis中。但是由于目前没有后端提供修改功能，所以这里使用POSTMAN发送PUT请求，请求路径<a target="_blank" rel="noopener" href="http://localhost:8081/shop%EF%BC%8C%E6%90%BA%E5%B8%A6JSON%E6%95%B0%E6%8D%AE%E5%A6%82%E4%B8%8B">http://localhost:8081/shop，携带JSON数据如下</a></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;area&quot;</span><span class="punctuation">:</span> <span class="string">&quot;大关&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;openHours&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10:00-22:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sold&quot;</span><span class="punctuation">:</span> <span class="number">4215</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;金华路锦昌文华苑29号&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="number">3035</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;avgPrice&quot;</span><span class="punctuation">:</span> <span class="number">80</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span> <span class="number">37</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;369茶餐厅&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typeId&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>此时数据库更新成功，同时redis中相关的缓存也被清理了，并且再次点击详情，对应数据的缓存就被保存在redis中。并且</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230714202109756.png" alt="image-20230714202109756"></p>
</li>
</ol>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="问题描述和解决方案"><a href="#问题描述和解决方案" class="headerlink" title="问题描述和解决方案"></a>问题描述和解决方案</h3><p><strong>缓存穿透：</strong>缓存穿透是指客户端<strong>请求的数据在缓存中和数据库中都不存在</strong>，这样缓存永远都不会生效（只有数据库查到了，才会让redis缓存，但现在的问题是查不到），会频繁的去访问数据库。</p>
<p>常见的解决方案有两种</p>
<ol>
<li><p><strong>缓存空对象（可添加TTL）</strong></p>
<ul>
<li><p>优点：实现简单，维护方便</p>
</li>
<li><p>缺点：额外的内存消耗；可能造成短期的不一致</p>
</li>
<li><p>实现思路：当客户端访问不存在的数据时，会先请求redis，但是此时redis中也没有数据，就会直接访问数据库，但是数据库里也没有数据，那么这个数据就穿透了缓存，直击数据库。但是数据库能承载的并发不如redis这么高，所以如果大量的请求同时都来访问这个不存在的数据，那么这些请求就会访问到数据库，简单的解决方案就是哪怕这个数据在数据库里不存在，我们也把这个这个数据存在redis中去，存为空对象，这样下次用户过来访问这个不存在的数据时，redis缓存中也能找到这个数据，不用去查数据库，但这样就造成了<strong>额外的内存消耗</strong>。<strong>短期不一致</strong>是指在空对象的存活期间，如果更新了数据库，但由于空对象的TTL还没过，所以当用户来查询的时候，查询到的还是空对象，等TTL过了之后，才能访问到正确的数据。</p>
</li>
<li><p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715103123126.png" alt="image-20230715103123126"></p>
</li>
</ul>
</li>
<li><p><strong>布隆过滤</strong></p>
<ul>
<li>优点：内存占用较少，没有多余的key</li>
<li>缺点：实现复杂；可能存在误判</li>
<li>实现思路：布隆过滤器采用的是<strong>哈希思想</strong>，并不是将数据库中的内容都保存到这里，而是通过一个<strong>二进制数组</strong>，根据哈希思想去判断当前这个要查询的数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，从数据库中查询到数据之后，再将其放到redis中。如果布隆过滤器判断这个数据不存在，则直接返回。优点在于节约内存空间，但<strong>存在误判</strong>，误判的原因在于：布隆过滤器基于哈希思想，只要是哈希思想，都可能存在<strong>哈希冲突</strong></li>
<li><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715103149780.png" alt="image-20230715103149780"></li>
</ul>
</li>
</ol>
<h3 id="解决商铺查询缓存穿透"><a href="#解决商铺查询缓存穿透" class="headerlink" title="解决商铺查询缓存穿透"></a>解决商铺查询缓存穿透</h3><p>商铺查询缓存穿透流程图：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715104124554.png" alt="image-20230715104124554"></p>
<p>思路：如果这个数据不存在，将这个数据写入到Redis中，将value设置为空字符串，然后设置一个较短的TTL，返回错误信息。当再次发起查询时，先去Redis中判断value是否为空字符串，如果是空字符串，则说明是不存在的数据，直接返回错误信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson))&#123; <span class="comment">//isNotBlank中如果是null、&quot;&quot;都会返回false</span></span><br><span class="line">        <span class="comment">//3.存在，直接返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[缓存穿透]判断命中的是否为空值。</span></span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;查询的商户不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//[缓存穿透]将空值写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.存在，写入Redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽取为一个方法"><a href="#抽取为一个方法" class="headerlink" title="抽取为一个方法"></a>抽取为一个方法</h3><p>这里先把之前写的缓存穿透代码修改一下，提取成一个独立的方法<code>queryWithPassThrough</code>，以免全写在queryById中，不便于阅读。同时方便后续功能的增加，更有区分性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithPassThrough</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson))&#123; <span class="comment">//isNotBlank中如果是null、&quot;&quot;都会返回false</span></span><br><span class="line">        <span class="comment">//3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[缓存穿透]判断命中的是否为空值。</span></span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//[缓存穿透]将空值写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.存在，写入Redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">//7.返回</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后的的<code>queryById</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> queryWithPassThrough(id);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>缓存穿透产生的原因是什么？</p>
<ul>
<li>用户请求的数据在缓存中和在数据库中都不存在，不断发起这样的请求，会给数据库带来巨大压力</li>
</ul>
<p>缓存穿透的解决方案有哪些？</p>
<ul>
<li>缓存null值</li>
<li>布隆过滤</li>
<li>增强id复杂度，避免被猜测id规律（可以采用<strong>雪花算法</strong>）</li>
<li>做好数据的基础格式校验</li>
<li>加强用户权限校验</li>
<li>做好热点参数的限流</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>缓存雪崩</strong>是指在同一时间段，<strong>大量缓存的key同时失效，或者Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>给不同的Key的TTL添加随机值。<ul>
<li>让其在不同时间段分批失效</li>
</ul>
</li>
<li>利用Redis集群提高服务的可用性。<ul>
<li>使用一个或者多个哨兵实例组成的系统，对redis节点进行监控，在主节点出现故障的情况下，能将从节点中的一个升级为主节点，进行故障转义，保证系统的可用性。</li>
</ul>
</li>
<li>给缓存业务添加降级限流策略。</li>
<li>给业务添加多级缓存。<ul>
<li>浏览器访问静态资源时，优先读取浏览器本地缓存；访问非静态资源（ajax查询数据）时，访问服务端；请求到达Nginx后，优先读取Nginx本地缓存；如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）；如果Redis查询未命中，则查询Tomcat；请求进入Tomcat后，优先查询JVM进程缓存；如果JVM进程缓存未命中，则查询数据库。</li>
</ul>
</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿也叫<strong>热点Key问题</strong>，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，那么无数请求访问就会在瞬间给数据库带来巨大的冲击</p>
<p>例如：秒杀商品的key突然失效了，大家都在疯狂抢购，那么这个瞬间就会有无数的请求访问去直接抵达数据库，从而造成缓存击穿</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715135246603.png" alt="image-20230715135246603"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>常见的解决方案：</p>
<ul>
<li><p><strong>互斥锁</strong></p>
<ul>
<li><p>流程：</p>
<p>在第一个线程缓存未命中时，首先会获取到一个互斥锁，然后继续后续的数据库查询重建任务，在此期间，如果有其他线程进来，在缓存查询未命中时，首先会尝试获取互斥锁，此时因为线程1还没释放锁，所以线程2获取失败，然后休眠一段时间后循环上述操作，直到线程1释放了锁，此时线程2就能获取到缓存，从而解决了上述问题</p>
</li>
<li><p>原理示意：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715135550365.png" alt="image-20230715135550365"></p>
</li>
</ul>
</li>
<li><p><strong>逻辑过期</strong></p>
<ul>
<li><p>流程：</p>
<p>之所以会出现缓存击穿问题，主要原因是对key设置了TTL，如果不设置TTL，就不会出现缓存击穿，但是就会占用过多内存，所以采用逻辑过期方案。也就是实际上没有设置TTL，但是在缓存的字段中新加了<code>expire</code>并指定了时间。在查询时，会判断逻辑时间是否过期，如果过期就会重新查询数据库进行重建。在重建完成前，其他线程都直接<strong>获取旧的缓存</strong>，直到锁的释放</p>
</li>
<li><p>原理示意：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715140132200.png" alt="image-20230715140132200"></p>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">解决方案</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">互斥锁</td>
<td align="center">没有额外的内存消耗; 保证一致性; 实现简单</td>
<td align="center">线程需要等待，性能受影响; 可能有死锁风险</td>
</tr>
<tr>
<td align="center">逻辑过期</td>
<td align="center">线程无需等待，性能较好</td>
<td align="center">不保证一致性; 有额外内存消耗; 实现复杂</td>
</tr>
</tbody></table>
<h3 id="互斥锁使用示例"><a href="#互斥锁使用示例" class="headerlink" title="互斥锁使用示例"></a>互斥锁使用示例</h3><p>修改根据id查询商铺信息的业务，基于互斥锁方式来解决缓存击穿的问题。流程如下：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715140840403.png" alt="image-20230715140840403"></p>
<p>这里锁的获取和释放采用的是Redis中的<code>setnx</code>命令实现：</p>
<ul>
<li>获取锁：<code>setnx lock [value] [TTL]</code><ul>
<li>当一个线程使用该命令进行指定key（lock）缓存的写入时，其他线程就无法操作这个lock</li>
<li>这里设置TTL是防止忘记释放锁而导致无法后续操作</li>
</ul>
</li>
<li>释放锁：<code>del lock</code><ul>
<li>当前线程执行完后，需要释放锁，可以直接将该缓存数据删除即可。</li>
</ul>
</li>
</ul>
<p>这里我们在<code>ShopServiceImpl</code>中新建两个方法，实现获取锁和释放锁的方法:</p>
<blockquote>
<p>这里的<code>setIfAbsent</code>就对应Redis命令<code>setnx</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存击穿：获取锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//避免返回值为null，这里使用了BooleanUtil工具类</span></span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存击穿：释放锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似之前的缓存穿透，我们这里也把互斥锁解决缓存击穿抽离为一个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson))&#123; <span class="comment">//isNotBlank中如果是null、&quot;&quot;都会返回false</span></span><br><span class="line">        <span class="comment">//3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[缓存穿透]判断命中的是否为空值。</span></span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[缓存击穿]获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">//[缓存击穿]判断是否获取成功</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock)&#123;</span><br><span class="line">            <span class="comment">//[缓存击穿]失败，则休眠重试</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="comment">//重试就是重新查询缓存，所以这里直接使用递归</span></span><br><span class="line">            <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.成功，根据id查询数据库</span></span><br><span class="line">        shop = getById(id);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模拟重建的延时</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//[缓存穿透]将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.存在，写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//[缓存击穿]释放互斥锁</span></span><br><span class="line">        unlock(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.返回</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里用到了try-catch去捕获线程sleep的异常。可以在选择需要包括的code后使用快捷键<code>ctrl+alt+T</code>快速实现功能。</p>
</blockquote>
<p>此时<code>queryById</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//缓存穿透</span></span><br><span class="line">    <span class="comment">//Shop shop = queryWithPassThrough(id);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存击穿:互斥锁</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> queryWithMutex(id);</span><br><span class="line">    <span class="comment">//这里统一对返回为null的情况进行报错</span></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JMeter并发测试"><a href="#JMeter并发测试" class="headerlink" title="JMeter并发测试"></a>JMeter并发测试</h4><p>使用教程参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/64847409">https://zhuanlan.zhihu.com/p/64847409</a></p>
<p>官网：<a target="_blank" rel="noopener" href="https://jmeter.apache.org/download_jmeter.cgi">https://jmeter.apache.org/download_jmeter.cgi</a></p>
<p>操作如下：</p>
<ol>
<li>首先将Redis中的热点商品数据删除，模拟TTL到期，然后用Jmeter进行压力测试，开1000个线程来访问这个没有缓存的热点数据</li>
<li>创建线程组，设置线程数和间隔时间。</li>
</ol>
<blockquote>
<p>右键点击“Test Plan测试计划”-“Add添加”-“Threads(Users)线程(用户)”-“Thread Group线程组”</p>
</blockquote>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715164507853.png" alt="image-20230715164507853"></p>
<ol start="3">
<li>然后设置HTTP请求，设定服务器协议，请求ip及端口号，设置请求方式和请求路径，修改编码为UTF-8</li>
</ol>
<blockquote>
<p>右键点击“Thread Group线程组” - “Add添加”-“Sampler” - “HTTP Request”</p>
</blockquote>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715164458590.png" alt="image-20230715164458590"></p>
<ol start="4">
<li>然后添加添加<strong>结果树视图&#x2F;聚合视图</strong></li>
</ol>
<blockquote>
<p>右键点击“Thread线程组”-“Add添加”-“Listener监听器”-“View Results Tree结果树视图”及“Summary Report聚合视图”</p>
</blockquote>
<ol start="5">
<li><p>然后点击上方小三角即可进行并发测试。此时查看结果树视图、聚合视图结果如下：</p>
<ul>
<li><p>结果树视图：</p>
<p>可以看出，请求都顺利执行</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715164519972.png" alt="image-20230715164519972"></p>
</li>
<li><p>聚合视图：</p>
<p>可以看到请求的各项参数</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715164531483.png" alt="image-20230715164531483"></p>
</li>
</ul>
</li>
<li><p>此时查看控制台输出，可以看出，执行1000个线程查询请求，后台只输出了一次sql数据库查询。这说明互斥锁有效，降低了数据库的查询量。</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT id,name,type_id,images,area,address,x,y,avg_price,sold,comments,score,open_hours, create_time,update_time FROM tb_shop WHERE id=?</span><br><span class="line">==&gt; Parameters: 1(Long)</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="逻辑过期使用示例"><a href="#逻辑过期使用示例" class="headerlink" title="逻辑过期使用示例"></a>逻辑过期使用示例</h3><p>需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿的问题。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715201049866.png" alt="image-20230715201049866"></p>
<p>过程：从Redis中查询缓存判断是否命中。如果没有命中则直接返回空数据，不查询数据库；如果命中，则将缓存中数据的value取出，判断value中的过期时间是否满足。如果没有过期，则直接返回Redis中的数据；如果过期，该线程直接返回之前的数据并获取互斥锁，然后新创建一个线程独去查询数据库以重构缓存数据，重构完成后再释放互斥锁。</p>
<p>流程：</p>
<ol>
<li><p>因为原本的Shop实体类并没有这个过期时间属性，为了不对原本的代码进行入侵（直接在Shop中添加字段），所以这里<strong>新建一个实体类</strong><code>RedisData</code>，包含原有数据和过期时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后再ShopServiceImlp中实现将shop数据和<strong>过期时间封装</strong>到redisData中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShop2Redis</span><span class="params">(Long id, Long expireSeconds)</span>&#123;</span><br><span class="line">    <span class="comment">//1.查询店铺数据</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">//2.封装逻辑过期时间</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">    redisData.setData(shop);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));</span><br><span class="line">    <span class="comment">//3.写入Redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这里进行测试，看看是否能成功写入redis，这里在测试类中进行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ShopServiceImpl shopService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveShop</span><span class="params">()</span>&#123;</span><br><span class="line">    shopService.saveShop2Redis(<span class="number">1L</span>, <span class="number">100L</span>); <span class="comment">//id=1，过期时间=当前时间+100s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis数据库中的缓存</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;area&quot;</span><span class="punctuation">:</span> <span class="string">&quot;大关&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;openHours&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10:00-22:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sold&quot;</span><span class="punctuation">:</span> <span class="number">4215</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;images&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://qcloud.dpfile.com/pc/jiclIsCKmOI2arxKN1Uf0Hx3PucIJH8q0QSz-Z8llzcN56-_QiKuOvyio1OOxsRtFoXqu0G3iT2T27qat3WhLVEuLYk00OmSS1IdNpm8K8sG4JN9RIm2mTKcbLtc2o2vfCF2ubeXzk49OsGrXt_KYDCngOyCwZK-s3fqawWswzk.jpg,https://qcloud.dpfile.com/pc/IOf6VX3qaBgFXFVgp75w-KKJmWZjFc8GXDU8g9bQC6YGCpAmG00QbfT4vCCBj7njuzFvxlbkWx5uwqY2qcjixFEuLYk00OmSS1IdNpm8K8sG4JN9RIm2mTKcbLtc2o2vmIU_8ZGOT1OjpJmLxG6urQ.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;金华路锦昌文华苑29号&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="number">3035</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;avgPrice&quot;</span><span class="punctuation">:</span> <span class="number">80</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;updateTime&quot;</span><span class="punctuation">:</span> <span class="number">1689337040000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span> <span class="number">37</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;createTime&quot;</span><span class="punctuation">:</span> <span class="number">1640167839000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;369茶餐厅&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;x&quot;</span><span class="punctuation">:</span> <span class="number">120.149192</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;y&quot;</span><span class="punctuation">:</span> <span class="number">30.316078</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typeId&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;expireTime&quot;</span><span class="punctuation">:</span> <span class="number">1689424146614</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看出，保存的缓存中多了过期时间字段</p>
</blockquote>
</li>
<li><p>然后就是类似上面互斥锁，也新建一个方法单独实现逻辑过期功能</p>
<blockquote>
<p>注意：因为这里代码实现是如果reids中不存在缓存，则直接返回null，这样会导致前端加载商铺信息失败，所以需要提前进行redis的缓存存入，具体操作如上述2操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里需要声明一个线程池，因为下面需要新建一个现成来完成重构缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * queryById：解决缓存击穿：使用逻辑过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithExpire</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(shopJson))&#123;</span><br><span class="line">        <span class="comment">//不存在直接返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.命中，将json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="comment">//4.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (LocalDateTime.now().isBefore(redisData.getExpireTime()))&#123;</span><br><span class="line">        <span class="comment">//4.1如果未过期则直接返回数据</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 过期，则需要缓存重建</span></span><br><span class="line">    <span class="comment">//5.缓存重建</span></span><br><span class="line">    <span class="comment">//5.1 获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">//5.2 判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">        <span class="comment">//成功则开启独立线程，并返回旧的店铺信息</span></span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//重建缓存(这里过期时间设置得短，为了便于测试)</span></span><br><span class="line">                <span class="built_in">this</span>.saveShop2Redis(id, <span class="number">30L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//直接返回商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//未获取到锁，直接返回商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);</code>这里用到的是Java中的一个常用线程池类——newFixedThreadPool。创建的线程池是一个固定大小的线程池，线程池中的线程数量是固定的，由构造函数传入的参数指定，而任务队列的大小则由内部的阻塞队列来决定。</p>
</blockquote>
</li>
</ol>
<p>这里我们模拟场景，在此之前，我们已经将餐厅数据缓存到redis，但是缓存时间早已过期，这时，我们去数据库修改餐厅的数据，（这里是修改餐厅名称）。这样逻辑过期前和逻辑过期后的数据就不一致，当用户来访问数据的时候，需要花时间来进行重构缓存数据，但是在重构完成之前，都只能获得脏数据（也就是修改前的数据），只有当重构完毕之后，才能获得新数据（修改后的数据）。</p>
<p>然后此时在缓存重建部分内容人为添加上延时，便于观察重建期间其他线程访问到的数据内容</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void saveShop2Redis(Long id, Long expireSeconds) throws InterruptedException &#123;</span><br><span class="line">    //1.查询店铺数据</span><br><span class="line">    Shop shop = getById(id);</span><br><span class="line"><span class="addition">+   Thread.sleep(200);</span></span><br><span class="line">    //2.封装逻辑过期时间</span><br><span class="line">    RedisData redisData = new RedisData();</span><br><span class="line">    redisData.setData(shop);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));</span><br><span class="line">    //3.写入Redis</span><br><span class="line">    stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时使用JMeter进行100个线程访问测试：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715212020400.png" alt="image-20230715212020400"></p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715211954105.png" alt="image-20230715211954105"></p>
<p>在前面部分线程访问到的都是旧数据，在线程25以后访问到的就是更新后的数据。并且通过IDEA的控制台输出可以看出只进行了一次SQL查询。</p>
<h2 id="缓存工具封装"><a href="#缓存工具封装" class="headerlink" title="缓存工具封装"></a>缓存工具封装</h2><blockquote>
<p>无论是解决缓存穿透还是缓存击穿，其逻辑都是复杂的，如果每次开发都重写这些逻辑，就会有些复杂，所以这里将其封装为工具类</p>
</blockquote>
<p>基于StringRedisTemplate封装一个<strong>缓存工具类</strong>，需满足下列要求</p>
<ul>
<li>方法1：将<strong>任意</strong>Java对象序列化为JSON，并存储到String类型的Key中，并可以设置TTL过期时间</li>
<li>方法2：将<strong>任意</strong>Java对象序列化为JSON，并存储在String类型的Key中，并可以设置逻辑过期时间，用于处理缓存击穿问题</li>
<li>方法3：根据指定的Key查询缓存，并反序列化为指定类型，利用<strong>缓存空值</strong>的方式解决<strong>缓存穿透</strong>问题</li>
<li>方法4：根据指定的Key查询缓存，并反序列化为指定类型，需要利用<strong>逻辑过期</strong>解决<strong>缓存击穿</strong>问题</li>
</ul>
<p><strong>流程：</strong></p>
<ol start="0">
<li><p>这里在util包中创建<code>CacheClinet</code></p>
<blockquote>
<p>让后将上述内容写在该类中即可</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1：将**任意**Java对象序列化为JSON，并存储到String类型的Key中，并可以设置TTL过期时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法2：将任意Java对象序列化为JSON，并存储在String类型的Key中，并可以设置逻辑过期时间，用于处理缓存击穿问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="comment">//设置逻辑过期</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">    redisData.setData(value);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">    <span class="comment">//写入redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法三</p>
<blockquote>
<p>该方法直接在之前<code>queryWithPassThrough</code>的基础上进行修改。</p>
<ul>
<li>因为需要改成通用方法，所以这里返回类型不能是Shop，而是需要返回一个泛型，所以方法上定义泛型和返回类型<code>&lt;R&gt; R</code>，并且通过参数<code>Class&lt;R&gt; type</code>传递需要处理的类型</li>
<li>传入id的类型也不一定是Long，所以也是用泛型，定义在前面。</li>
<li>然后此时缓存前缀也会随着任务的不同而不同，所以也需要调用者自己输入，所以这里也抽离称为一个参数<code>String keyPrefix</code></li>
<li>因为具体的数据库查询逻辑也不同，所以在参数列表中加入一个查询数据库逻辑的函数<code>Function&lt;ID, R&gt; dbFallback</code>，传递id和处理的类型。然后调用<code>apply</code>方法调用传递的函数，返回对应类型的数据r。</li>
<li>以及传入TTL的两个参数</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法3：根据指定的Key查询缓存，并反序列化为指定类型，利用**缓存空值**的方式解决**缓存穿透**问题</span></span><br><span class="line"><span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123; <span class="comment">//isNotBlank中如果是null、&quot;&quot;都会返回false</span></span><br><span class="line">        <span class="comment">//3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[new]判断命中的是否为空值。</span></span><br><span class="line">    <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">    <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//[new]将空值写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.存在，写入Redis</span></span><br><span class="line">    <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">    <span class="comment">//7.返回</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改<code>ShopServiceImpl</code>中的<code>queryById</code>方法，修改缓存击穿的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CacheClient cacheClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//调用封装工具解决缓存击穿</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient.queryWithPassThrough(RedisConstants.CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>方法四</p>
<blockquote>
<p>类似上面的逻辑，传递的参数都一致。只不过这里需要将线程获取、获取锁和释放锁的代码拿过来。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法4：根据指定的Key查询缓存，并反序列化为指定类型，需要利用**逻辑过期**解决**缓存击穿**问题</span></span><br><span class="line"><span class="comment">//这里需要声明一个线程池，因为下面需要新建一个现成来完成重构缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//[缓存击穿-互斥锁]：获取锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//避免返回值为null，我们这里使用了BooleanUtil工具类</span></span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[缓存击穿-互斥锁]：释放锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">    <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(json))&#123;</span><br><span class="line">        <span class="comment">//不存在直接返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.命中，将json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">    <span class="comment">//4.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (LocalDateTime.now().isBefore(redisData.getExpireTime()))&#123;</span><br><span class="line">        <span class="comment">//4.1如果未过期则直接返回数据</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 过期，则需要缓存重建</span></span><br><span class="line">    <span class="comment">//5.缓存重建</span></span><br><span class="line">    <span class="comment">//5.1 获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">//5.2 判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">        <span class="comment">//成功则开启独立线程，并返回旧的店铺信息</span></span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//[]重建缓存:查询数据库</span></span><br><span class="line">                <span class="type">R</span> <span class="variable">r1</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                <span class="comment">//[]重建缓存:写入Redis</span></span><br><span class="line">                <span class="built_in">this</span>.setWithLogicalExpire(key, r1, time, unit);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//直接返回商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//未获取到锁，直接返回商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这部分内容不能直接执行，因为这个方法会判断过期时间字段，如果缓存没有这个字段就会查询失败。所以执行前先使用测试方法添加一个缓存信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CacheClient cacheClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLogicalExpire</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> shopService.getById(<span class="number">1L</span>);</span><br><span class="line">    cacheClient.setWithLogicalExpire(RedisConstants.CACHE_SHOP_KEY+<span class="number">1L</span>, shop, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
</blockquote>
</li>
</ol>
<p>至此，之前在<code>ShopServiceImpl</code>中实现的缓存击穿、缓存穿透的代码就不需要了，直接调用写好的<code>CacheClient</code>工具类即可，并且更加灵活，应对不同的输入类型和操作逻辑。</p>
<hr>
<h1 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h1><h2 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h2><p>背景：这里以购物app中的优惠券为例，当用户下单抢购优惠券后，对应的订单就会保存在 <code>user_voucher_order</code>，因为对应的订单号的id需要展示给用户，如果使用数据库自增id就会出现一些问题：</p>
<ol>
<li>id的规律性太明显<ul>
<li>如果id有明显的规律，会被用户或者竞争对手从中获取到敏感信息，比如商城一天之内的销售量</li>
</ul>
</li>
<li>受单表数据量的限制<ul>
<li>随着商城规模的扩大，mysql单表数据量不宜超过500W，这时过多的订单就要通过拆库拆表实现，从逻辑上讲，这些属于一张表，所以id不能重复，因此要保证id的唯一性</li>
</ul>
</li>
</ol>
<p>这就引入了<strong>全局ID生成器</strong>，这是一种在分布式系统下用来生成全局唯一ID的工具，一般需要满足下列特征：</p>
<ul>
<li>唯一性</li>
<li>高可用</li>
<li>高性能</li>
<li>递增性</li>
<li>安全性</li>
</ul>
<p><strong>全局唯一ID生成策略：</strong></p>
<ul>
<li>UUID</li>
<li>Redis自增</li>
<li>snowflake算法</li>
<li>数据库自增</li>
</ul>
<p><strong>ID组成部分</strong></p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716171045615.png" alt="image-20230716171045615"></p>
<ul>
<li>符号位：1bit，永远为0</li>
<li>时间戳：31bit，以秒为单位，可以使用69年（2^31秒约等于69年）</li>
<li>序列号：32bit，秒内的计数器，支持每秒传输2^32个不同ID</li>
</ul>
<h3 id="Redis自增"><a href="#Redis自增" class="headerlink" title="Redis自增"></a>Redis自增</h3><p>Redis自增策略：</p>
<ul>
<li>每天一个key，方便统计销售量；同时也避免超过存储数据上限（incr自增的值限制在64位）</li>
<li>ID构造是时间戳+计数器</li>
</ul>
<p><strong>代码实现：</strong></p>
<blockquote>
<p>这里首先在utils包下新建一个<code>RedisIdWorker</code>类</p>
</blockquote>
<p>这里使用Redis的<code>INCR</code>递增函数实现，该命令会将key中存储的数字值增加一。如果key不存在，那么key值就会先被初始化为0，再执行incr命令。本操作的值限制在 64 位(bit)有符号数字表示之内。对应的SpringRedisTemplate中对应的是<code>opsForString.increment()</code></p>
<ol start="0">
<li>首先获取起始时间的秒数</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//设置一下起始时间，时间戳就是起始时间与当前时间的秒数差</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">tmp</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2022</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    System.out.println(tmp.toEpochSecond(ZoneOffset.UTC));</span><br><span class="line">    <span class="comment">//结果为1640995200L</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>然后进行唯一id的获取，将上面得到的其实时间定义为一个常量。</p>
<blockquote>
<p>注意：在生成序列号的部分，之所以获取当天日期，是为了便于后续统计当天、当月或当年的销售量，便于区分</p>
</blockquote>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置起始时间:2022.01.01 00:00:00</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line">    <span class="comment">//序列号长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">COUNT_BIT</span> <span class="operator">=</span> <span class="number">32L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">//生成时间戳</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> LocalDateTime.now().toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeStamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成序列号</span></span><br><span class="line">        <span class="comment">// 先获取当天日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">// 自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拼接并返回</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> timeStamp &lt;&lt; COUNT_BIT | count; <span class="comment">// 将timeStamp左移32位，然后使用或运算拼接redis序列号</span></span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实现优惠券秒杀下单"><a href="#实现优惠券秒杀下单" class="headerlink" title="实现优惠券秒杀下单"></a>实现优惠券秒杀下单</h2><p>每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以随意购买，特价券需要秒杀抢购</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716174921932.png" alt="image-20230716174921932"></p>
<p>这两种代金券对应数据库中的两个表：</p>
<ul>
<li><p>平价券<code>tb_voucher</code></p>
<ul>
<li><p>表结构如下：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716180403204.png" alt="image-20230716180403204"></p>
</li>
</ul>
</li>
<li><p>特价券 <code>tb_seckill_voucher</code></p>
<ul>
<li><p>表结构如下：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716180445638.png" alt="image-20230716180445638"></p>
</li>
</ul>
</li>
</ul>
<p>对比：</p>
<ul>
<li>可以看出平价券并没有库存字段，而特价券除了具有优惠券的基本信息外（通过关联优惠券id），还有库存、生效时间、失效时间等字段</li>
<li>并且平价券的字段中包含了type，0代表普通券，1代表秒杀券</li>
</ul>
<h3 id="添加优惠券"><a href="#添加优惠券" class="headerlink" title="添加优惠券"></a>添加优惠券</h3><p>因为这时数据库中还没有秒杀券，这里进行添加逻辑分析和数据添加（这部分代码项目中已经实现好了）</p>
<p><code>VoucherController</code>中的优惠券添加方法。<strong>新增普通券</strong>，只是将普通券的信息保存到表中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 新增普通券</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> voucher 优惠券信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 优惠券id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.save(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增秒杀券位于<code>addSeckillVoucher</code>中的业务逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 新增秒杀券</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> voucher 优惠券信息，包含秒杀信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 优惠券id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;seckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.addSeckillVoucher(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对应的<code>addSeckillVoucher</code>方法如下：</p>
<blockquote>
<p>秒杀券可以看做是一种特殊的普通券，将普通券信息保存到普通券表中，同时将秒杀券的数据保存到秒杀券表中，<strong>通过券的ID进行关联</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为该项目没有实现后端管理界面，所以使用postman模拟发送请求来新增秒杀券，请求路径为<code>localhost:8081/voucher/seckill</code>， 请求方式POST，JSON数据如下。注意优惠券的截止日期设置，若优惠券过期，则不会在页面上显示。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;shopId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;100元代金券&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;subTitle&quot;</span><span class="punctuation">:</span><span class="string">&quot;周一至周五可用&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span><span class="string">&quot;全场通用\\n无需预约\\n可无限叠加&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;payValue&quot;</span><span class="punctuation">:</span><span class="number">8000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;actualValue&quot;</span><span class="punctuation">:</span><span class="number">10000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span><span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;beginTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2023-07-16T19:00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;endTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2023-07-16T23:59:59&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>页面显示如下：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716191825577.png" alt="image-20230716191825577"></p>
<h3 id="秒杀实现"><a href="#秒杀实现" class="headerlink" title="秒杀实现"></a>秒杀实现</h3><p>此时点击<code>限时抢购</code>，发送如下请求</p>
<blockquote>
<p>Request URL：<a target="_blank" rel="noopener" href="http://localhost:8080/api/voucher-order/seckill/10">http://localhost:8080/api/voucher-order/seckill/10</a></p>
<p>Request Method: POST</p>
</blockquote>
<p>可以看出是<code>VoucherOrderController</code>中的<code>seckill/&#123;id&#125;</code>请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/voucher-order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;seckill/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long voucherId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;功能未完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下单时需要判断两点：</p>
<ul>
<li>秒杀是否开始或者结束，如果尚未开始或已经结束则无法下单</li>
<li>库存是否充足，不足则无法下单</li>
</ul>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716204730696.png" alt="image-20230716204730696"></p>
<p><strong>代码实现：</strong></p>
<p>依旧是修改controller中的方法，调用service中的实现，然后在serviceImpl中实现对应功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//1.查询优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">//2.判断秒杀是否开始</span></span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.判断秒杀是否结束</span></span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>,voucherId)</span><br><span class="line">                .update();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!success)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//6.1订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">//6.2用户id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">//6.3代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        <span class="comment">//7.返回订单id</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：这里扣减库存逻辑采用<code>setSql</code>实现：在此之前，我们如果想要更新数据库中的某条数据的某个字段，需要前先查询出来再更新。但若直接使用<code>setSql</code>则相当于直接更新。以下述为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seckillVoucherService.update()</span><br><span class="line">    .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">    .eq(<span class="string">&quot;voucher_id&quot;</span>,voucherId)</span><br><span class="line">    .update();</span><br></pre></td></tr></table></figure>

<p>相当于sql语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="string">&#x27;voucher&#x27;</span> <span class="keyword">SET</span> <span class="string">&#x27;stock&#x27;</span> <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> <span class="string">&#x27;voucher_id&#x27;</span> <span class="operator">=</span> voucherId;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>结果：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716211205452.png" alt="image-20230716211205452"></p>
<p>可以看到抢购成功，并且刷新后库存减一</p>
<h2 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h2><h3 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h3><p>之前的代码其实是有问题的，当<strong>遇到高并发场景时，会出现超卖现象</strong>，可以用Jmeter开200个线程来模拟抢优惠券的场景（此时券只有100个），URL为 <code>localhost:8081/voucher-order/seckill/10</code>，请求方式为<code>POST</code></p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716212429435.png" alt="image-20230716212429435"></p>
<blockquote>
<p>但是这样直接去请求会出现问题，所有的http请求都失败了。这是因为没有携带登录的token ，可以从redis缓存或者浏览器中获取，添加到http请求中。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716212819878.png" alt="image-20230716212819878"></p>
</blockquote>
<p>执行完后，会发现出现了109个订单，并且秒杀券的数量变成了-9，说明超卖了9张。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716214748603.png" alt="image-20230716214748603"></p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716214803865.png" alt="image-20230716214803865"></p>
<h3 id="问题分析-悲、乐观锁"><a href="#问题分析-悲、乐观锁" class="headerlink" title="问题分析|悲、乐观锁"></a>问题分析|悲、乐观锁</h3><p>之所以出现超卖问题，是因为代码中首先会查询库存数量，然后进行库存判断和扣减，在这个过程中，可能涉及多个线程同时操作，造成了多线程并发问题。如下图所示：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716215255599.png" alt="image-20230716215255599"></p>
<p>针对这一问题的常见解决方案就是<strong>加锁</strong>：而对于加锁，我们通常有两种解决方案：</p>
<ul>
<li><strong>悲观锁</strong><ul>
<li>悲观锁认为线程安全问题<strong>一定会发生</strong>，因此在操作数据之前先获取锁，确保<strong>线程串行执行</strong></li>
<li>例如Synchronized、Lock等，都是悲观锁</li>
<li>优点：简单粗暴</li>
<li>缺点：性能一般</li>
</ul>
</li>
<li><strong>乐观锁</strong><ul>
<li>乐观锁认为线程安全问题<strong>不一定会发生</strong>，因此不加锁，只是在更新数据的时候再去判断有没有其他线程对数据进行了修改<ul>
<li>如果没有修改，则认为自己是安全的，自己才可以更新数据</li>
<li>如果已经被其他线程修改，则说明发生了安全问题，此时可以重试或者异常</li>
</ul>
</li>
<li>优点：性能好</li>
<li>缺点：存在成功率低的问题</li>
</ul>
</li>
</ul>
<blockquote>
<p>悲观锁比较常用，这里不做赘述，这里具体介绍乐观锁</p>
</blockquote>
<p>乐观锁的关键是判断之前查询得到的数据是否被修改过，常见有两种方式：</p>
<ul>
<li><p><strong>版本号法：</strong></p>
<ul>
<li><p>乐观锁会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会比较之前查询到的版本号和目前保存的版本号，如果一致，则进行操作成功，如果不一致，则数据被修改过。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716221304180.png" alt="image-20230716221304180"></p>
</li>
</ul>
</li>
<li><p><strong>CAS(Compare-And-Set)法：</strong></p>
<ul>
<li><p>类似上面的方法，只不过不需要版本号，而是判断查询到的库存是否和实际库存一致。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716221731397.png" alt="image-20230716221731397"></p>
</li>
</ul>
</li>
</ul>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>初步实现：</strong></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    @Transactional</span><br><span class="line">    public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">        //1.查询优惠券</span><br><span class="line">        SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);</span><br><span class="line">        //2.判断秒杀是否开始</span><br><span class="line">        if (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            return Result.fail(&quot;秒杀尚未开始&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.判断秒杀是否结束</span><br><span class="line">        if (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            return Result.fail(&quot;秒杀已经结束&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //4.判断库存是否充足</span><br><span class="line">        if (seckillVoucher.getStock() &lt; 1) &#123;</span><br><span class="line">            return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //5.扣减库存</span><br><span class="line">        boolean success = seckillVoucherService.update()</span><br><span class="line">                .setSql(&quot;stock = stock - 1&quot;)</span><br><span class="line">                .eq(&quot;voucher_id&quot;,voucherId) // set stock = stock - 1</span><br><span class="line"><span class="addition">+               .eq(&quot;stock&quot;, seckillVoucher.getStock()) //where id = ? and stock = ? </span></span><br><span class="line">                .update();</span><br><span class="line">        if (!success)&#123;</span><br><span class="line">            return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //6.创建订单</span><br><span class="line">        VoucherOrder voucherOrder = new VoucherOrder();</span><br><span class="line">        //6.1订单id</span><br><span class="line">        long orderId = redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        //6.2用户id</span><br><span class="line">        Long userId = UserHolder.getUser().getId();</span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        //6.3代金券id</span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        //7.返回订单id</span><br><span class="line"></span><br><span class="line">        return Result.ok(orderId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述逻辑：扣减库存时的库存和之前查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多<strong>失败的情况</strong>，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败。但实际上有其他线程修改是没有问题的，只要stock的数目大于0就行。</p>
<p><strong>完善版本：</strong></p>
<p>实际上就是在前面判断了库存大于0的基础上，在后面准备修改数据时在判断库存是否大于0.</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    @Transactional</span><br><span class="line">    public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">        //1.查询优惠券</span><br><span class="line">        SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);</span><br><span class="line">        //2.判断秒杀是否开始</span><br><span class="line">        if (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            return Result.fail(&quot;秒杀尚未开始&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.判断秒杀是否结束</span><br><span class="line">        if (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            return Result.fail(&quot;秒杀已经结束&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //4.判断库存是否充足</span><br><span class="line">        if (seckillVoucher.getStock() &lt; 1) &#123;</span><br><span class="line">            return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //5.扣减库存</span><br><span class="line">        boolean success = seckillVoucherService.update()</span><br><span class="line">                .setSql(&quot;stock = stock - 1&quot;)</span><br><span class="line">                .eq(&quot;voucher_id&quot;,voucherId) // set stock = stock - 1</span><br><span class="line"><span class="deletion">-               .eq(&quot;stock&quot;, seckillVoucher.getStock()) //where id = ? and stock = ? </span></span><br><span class="line"><span class="addition">+               .gt(&quot;stock&quot;, 0) //where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        if (!success)&#123;</span><br><span class="line">            return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //6.创建订单</span><br><span class="line">        VoucherOrder voucherOrder = new VoucherOrder();</span><br><span class="line">        //6.1订单id</span><br><span class="line">        long orderId = redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        //6.2用户id</span><br><span class="line">        Long userId = UserHolder.getUser().getId();</span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        //6.3代金券id</span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        //7.返回订单id</span><br><span class="line"></span><br><span class="line">        return Result.ok(orderId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这时再测试，就会发现优惠券正好被抢光。</p>
<h2 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h2><p>所谓一人一单就是修改秒杀业务，要求同一个优惠券，<strong>一个用户只能抢一张</strong></p>
<p>实现逻辑也很简单，在判断库存是否充足之后，根据用户id和优惠券id查询订单，判断用户订单是否已存在。如果已存在，则不能下单，返回错误信息；如果不存在，则继续下单，获取优惠券。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230717195742940.png" alt="image-20230717195742940"></p>
<h3 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional</span><br><span class="line">public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">    //1.查询优惠券</span><br><span class="line">    SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);</span><br><span class="line">    //2.判断秒杀是否开始</span><br><span class="line">    if (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀尚未开始&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.判断秒杀是否结束</span><br><span class="line">    if (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀已经结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.判断库存是否充足</span><br><span class="line">    if (seckillVoucher.getStock() &lt; 1) &#123;</span><br><span class="line">        return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   //[一人一单]</span></span><br><span class="line"><span class="addition">+   // 查询订单</span></span><br><span class="line"><span class="addition">+   Long userId = UserHolder.getUser().getId();</span></span><br><span class="line"><span class="addition">+   Integer count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();</span></span><br><span class="line"><span class="addition">+   // 判断订单是否存在</span></span><br><span class="line"><span class="addition">+   if (count &gt; 0)&#123;</span></span><br><span class="line"><span class="addition">+       return Result.fail(&quot;不能重复购买&quot;);</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line"></span><br><span class="line">    //5.扣减库存</span><br><span class="line">    boolean success = seckillVoucherService.update()</span><br><span class="line">        .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1</span><br><span class="line">        .eq(&quot;voucher_id&quot;,voucherId)</span><br><span class="line">        .gt(&quot;stock&quot;, 0) //where id = ? and stock &gt; 0</span><br><span class="line">        .update();</span><br><span class="line">    if (!success)&#123;</span><br><span class="line">        return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //6.创建订单</span><br><span class="line">    VoucherOrder voucherOrder = new VoucherOrder();</span><br><span class="line">    //6.1订单id</span><br><span class="line">    long orderId = redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    //6.2用户id</span><br><span class="line"></span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    //6.3代金券id</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line">    //7.返回订单id</span><br><span class="line"></span><br><span class="line">    return Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时使用JMeter进行多线程购买测试，但是因为http头携带的token是同一个用户的，所以按说执行200个线程只有一个订单。但实际运行后，发现还是会出现多个订单。其实发生的原因是一样的，还是因为在一人一单逻辑之前，如果进来了多个线程，还是可以抢多张优惠券的，这里使用悲观锁来解决这个问题。</p>
<h3 id="进一步优化-加锁"><a href="#进一步优化-加锁" class="headerlink" title="进一步优化(加锁)"></a>进一步优化(加锁)</h3><p>核心思想：把一人一单逻辑之后的代码都提取到一个<code>createVoucherOrder</code>方法中，然后给这个方法加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span>&#123;</span><br><span class="line">    <span class="comment">//[一人一单]</span></span><br><span class="line">    <span class="comment">// 查询订单</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 判断订单是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不能重复购买&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>,voucherId)</span><br><span class="line">            .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">//where id = ? and stock &gt; 0</span></span><br><span class="line">            .update();</span><br><span class="line">        <span class="keyword">if</span> (!success)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//6.1订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">//6.2用户id</span></span><br><span class="line"></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">//6.3代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li>这里获取<strong>锁并没有放在方法上，而是放在获取了用户id之后</strong><ul>
<li>这是因为如果放在方法上，所有的用户都要公用这一把锁，导致每个线程进来都会被锁住，串行执行，效率很低</li>
</ul>
</li>
<li>这里的锁采用用户的id实现，但是为什么要使用<code>userId.toString().intern()</code>？<ul>
<li>这是<strong>因为<code>toString</code>的源码是new String</strong>，所以如果只用<code>userId.toString()</code>会拿到不同的地址引用，所以需要使用<code>intern()</code>：如果字符串常量池中已经包含了一个等于这个string对象的字符串（由equals（object）方法确定），那么将返回池中的字符串。否则，将此String对象添加到池中，并返回对此String对象的引用。</li>
<li>具体解释：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44201525/article/details/120897052">https://blog.csdn.net/weixin_44201525/article/details/120897052</a></li>
</ul>
</li>
</ul>
</blockquote>
<p>原来的方法变为:</p>
<blockquote>
<p>此时这个方法就不需要事务注解了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">//2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.判断秒杀是否结束</span></span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最终版本-事务"><a href="#最终版本-事务" class="headerlink" title="最终版本(事务)"></a>最终版本(事务)</h3><p>但是以上代码还是存在问题，问题的原因在于当前方法被Spring事务控制，如果在内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放了，这样也会导致其他线程的进入，从而引发线程安全问题，所以需要<strong>使用锁将当前方法整体包裹起来</strong>，确保事务不会出现问题。</p>
<p>所以还是在函数外加锁，外部传递用户id给锁:</p>
<p><code>createVoucherOrder</code>函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//[一人一单]</span></span><br><span class="line">    <span class="comment">// 查询订单</span></span><br><span class="line">	<span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="comment">// 判断订单是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;不能重复购买&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">        .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">        .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">        .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">//where id = ? and stock &gt; 0</span></span><br><span class="line">        .update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">//6.1订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">//6.2用户id</span></span><br><span class="line"></span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">//6.3代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用函数处加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">//2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.判断秒杀是否结束</span></span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">        <span class="keyword">return</span> createVoucherOrder(voucherId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，只有在事务完成后才会释放锁，因此解决了线程安全问题。但是，此时<strong>还存在事务的问题</strong>。因为调用的函数声明了事务，但是上述方法不涉及事务。这是因为调用的<code>createVoucherOrder</code>方法，其实是this.的方式调用的，<strong>事务想要生效，需要利用代理来生效</strong>，所以这个地方，需要获得原始的事务对象， 来操作事务，这里可以使用<code>AopContext.currentProxy()</code>来<strong>获取当前对象的代理对象</strong>，然后再用代理对象调用方法，从而使这个方法被spring事务管理。</p>
<blockquote>
<p>注意：这里需要去<code>IVoucherOrderService</code>中创建<code>createVoucherOrder</code>方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">    <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法会对应依赖，需要导入。导入完成记得刷新！</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建代理事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时需要启动类上加上<code>@EnableAspectJAutoProxy(exposeProxy = true)</code>注解，来暴露这个代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.hmdp.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(exposeProxy = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HmDianPingApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(HmDianPingApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启服务器，再次使用JMeter测试，100个线程并发，但是只能抢到一张优惠券，实现一人一单.</p>
<h3 id="并发安全问题"><a href="#并发安全问题" class="headerlink" title="并发安全问题"></a>并发安全问题</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了</p>
<ol>
<li><p>我们将服务启动两份，端口分别为8081和8082：</p>
<ul>
<li>首先IEAD锤子图标右边选择<code>edit Configuration</code></li>
<li>然后点击本项目，然后点击复制上方图标</li>
<li>然后点击<code>Modify options</code>–&gt;<code>Add VM option</code>，填写指定端口即可<code>-Dserver.port=8081</code>和<code>-Dserver.port=8082</code></li>
<li><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230717222104666.png" alt="image-20230717222104666"></li>
</ul>
</li>
<li><p>然后修改nginx的config目录下的nginx.conf文件，配置反向代理和负载均衡（默认轮询就行）</p>
<blockquote>
<p>这部分内容在瑞吉外卖优化篇有介绍，参考以前博客</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">worker_processes</span>  <span class="string">1;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">events</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">worker_connections</span>  <span class="string">1024;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">http</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">include</span>       <span class="string">mime.types;</span></span><br><span class="line">    <span class="attr">default_type</span>  <span class="string">application/json;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">sendfile</span>        <span class="string">on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">keepalive_timeout</span>  <span class="string">65;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">listen</span>       <span class="string">8080;</span></span><br><span class="line">        <span class="attr">server_name</span>  <span class="string">localhost;</span></span><br><span class="line"><span class="comment">        # 指定前端项目所在的位置</span></span><br><span class="line">        <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">            <span class="attr">root</span>   <span class="string">html/hmdp;</span></span><br><span class="line">            <span class="attr">index</span>  <span class="string">index.html index.htm;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">error_page</span>   <span class="string">500 502 503 504  /50x.html;</span></span><br><span class="line">        <span class="attr">location</span> = <span class="string">/50x.html &#123;</span></span><br><span class="line">            <span class="attr">root</span>   <span class="string">html;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="attr">location</span> <span class="string">/api &#123;  </span></span><br><span class="line">            <span class="attr">default_type</span>  <span class="string">application/json;</span></span><br><span class="line"><span class="comment">            #internal;  </span></span><br><span class="line">            <span class="attr">keepalive_timeout</span>   <span class="string">30s;  </span></span><br><span class="line">            <span class="attr">keepalive_requests</span>  <span class="string">1000;  </span></span><br><span class="line"><span class="comment">            #支持keep-alive  </span></span><br><span class="line">            <span class="attr">proxy_http_version</span> <span class="string">1.1;  </span></span><br><span class="line">            <span class="attr">rewrite</span> <span class="string">/api(/.*) $1 break;  </span></span><br><span class="line">            <span class="attr">proxy_pass_request_headers</span> <span class="string">on;</span></span><br><span class="line"><span class="comment">            #more_clear_input_headers Accept-Encoding;  </span></span><br><span class="line">            <span class="attr">proxy_next_upstream</span> <span class="string">error timeout;  </span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            #proxy_pass http://127.0.0.1:8081; # modify-1</span></span><br><span class="line">            <span class="attr">proxy_pass</span> <span class="string">http://backend;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">upstream</span> <span class="string">backend &#123;</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">127.0.0.1:8081 max_fails=5 fail_timeout=10s weight=1;</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">127.0.0.1:8082 max_fails=5 fail_timeout=10s weight=1; # modify-2</span></span><br><span class="line">    <span class="attr">&#125;</span>  <span class="string"></span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>具体测试：</strong>使用<code>POSTMAN</code>发送两次请求，header携带同一用户的token，尝试用同一账号抢两张优惠券，结果出现了同一用户下了两次单。</p>
<p><strong>原因分析：</strong>部署了多个Tomcat时，每个Tomcat都有一个属于自己的<code>JVM</code>，假设在<code>JVM1</code>的内部，有两个线程：线程1和线程2，<strong>在<code>JVM</code>内部有一个锁监视器来管理锁的线程所有者</strong>，所以线程1和线程2可以实现互斥的。但是如果在<code>JVM2</code>，又有两个线程，但是他们的锁对象虽然写的和<code>JVM1</code>一样，但是<strong>锁对象却不是同一个</strong>，因为此时锁监视器变了，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2互斥。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230717220856033.png" alt="image-20230717220856033"></p>
<p>这就是集群环境下，syn锁失效的原因，在这种情况下，需要使用<strong>分布式锁</strong>来解决这个问题，让锁不存在于每个jvm的内部，而是让所有jvm公用外部的一把锁（Redis）</p>
<hr>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>分布式锁：满足分布式系统或集群模式下<strong>多线程可见并且可以互斥的锁</strong>。此外，还需要具有高可用、高性能、安全性等特性。</p>
<p>分布式锁的核心思想就是让大家共用同一把锁，那么就能锁住线程，不让线程进行，让程序串行执行，以下是原理示意：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230717224352825.png" alt="image-20230717224352825"></p>
<p>常见的分布式锁有三种：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">MySQL</th>
<th align="center">Redis</th>
<th align="center">Zookeeper</th>
</tr>
</thead>
<tbody><tr>
<td align="center">互斥</td>
<td align="center">利用mysql本身的互斥锁机制</td>
<td align="center">利用setnx这样的互斥命令</td>
<td align="center">利用节点的唯一性和有序性实现互斥</td>
</tr>
<tr>
<td align="center">高可用</td>
<td align="center">好</td>
<td align="center">好</td>
<td align="center">好</td>
</tr>
<tr>
<td align="center">高性能</td>
<td align="center">一般</td>
<td align="center">好</td>
<td align="center">一般</td>
</tr>
<tr>
<td align="center">安全性</td>
<td align="center">断开连接，自动释放锁</td>
<td align="center">利用锁超时时间，到期释放</td>
<td align="center">临时节点，断开连接自动释放</td>
</tr>
</tbody></table>
<h2 id="分布式锁获取和释放"><a href="#分布式锁获取和释放" class="headerlink" title="分布式锁获取和释放"></a>分布式锁获取和释放</h2><p>实现分布式锁时需要实现两个基本方法：</p>
<ol>
<li><p>获取锁：</p>
<ul>
<li><p>互斥：确保只能有一个线程获取锁</p>
</li>
<li><p>非阻塞：尝试一次，成功返回true，失败返回false</p>
</li>
<li><p>实现：</p>
<ul>
<li><p><input disabled="" type="checkbox"> 
老方法，这种方法添加锁和设置过期时间是两步实现的，有可能在设置过期时间前就出现问题，还会造成死锁。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加锁</span></span><br><span class="line">SETNX lock thread01</span><br><span class="line"><span class="comment"># 添加锁过期时间，避免服务器宕机引起的死锁</span></span><br><span class="line">EXPIRE lock 10</span><br></pre></td></tr></table></figure>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
新方法，使用redis中的方法，同时添加锁和过期时间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加锁的同时设置过期时间 NX是互斥，EX是设置过期时间</span></span><br><span class="line">SET lock thread01 NX EX 10</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>释放锁：</p>
<ul>
<li><p>手动释放</p>
</li>
<li><p>超时释放：获取锁的时候添加一个超时时间</p>
</li>
<li><p>实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 释放锁，删除即可</span></span><br><span class="line">DEL lock</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="初步实现分布式锁"><a href="#初步实现分布式锁" class="headerlink" title="初步实现分布式锁"></a>初步实现分布式锁</h2><ol>
<li><p>首先给出ILock接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeoutSec 锁持有的超时时间，过期自动释放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true表示获取锁成功，false表示获取锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建<code>SimpleRedisLock</code>类集成ILock，实现对应方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">//锁的前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="comment">//具体业务名称，将前缀和业务名拼接之后当做Key</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">//获取线程标识</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX+name, threadId+<span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//自动拆箱可能会出现null，这样写避免空指针</span></span><br><span class="line">        <span class="keyword">return</span> success.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改之前一人一单的业务逻辑，替换<code>synchronized</code>为自己写的redis锁</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">    //1.查询优惠券</span><br><span class="line">    SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);</span><br><span class="line">    //2.判断秒杀是否开始</span><br><span class="line">    if (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀尚未开始&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.判断秒杀是否结束</span><br><span class="line">    if (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀已经结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.判断库存是否充足</span><br><span class="line">    if (seckillVoucher.getStock() &lt; 1) &#123;</span><br><span class="line">        return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Long userId = UserHolder.getUser().getId();</span><br><span class="line"><span class="deletion">-   synchronized (userId.toString().intern())&#123;</span></span><br><span class="line"><span class="deletion">-		IVoucherOrderService proxy = (IVoucherOrderService)AopContext.currentProxy();</span></span><br><span class="line"><span class="deletion">-       return proxy.createVoucherOrder(voucherId);</span></span><br><span class="line"><span class="deletion">-   &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   //[redis实现分布式锁]</span></span><br><span class="line"><span class="addition">+   SimpleRedisLock lock = new SimpleRedisLock(stringRedisTemplate, &quot;order:&quot; + userId);</span></span><br><span class="line"><span class="deletion">-   boolean tryLock = lock.tryLock(5);</span></span><br><span class="line"><span class="addition">+   if (!tryLock)&#123;</span></span><br><span class="line"><span class="addition">+       return Result.fail(&quot;一人只能下一单&quot;);</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line"><span class="addition">+   //获取代理对象(事务)</span></span><br><span class="line"><span class="addition">+   try &#123;</span></span><br><span class="line"><span class="addition">+       IVoucherOrderService proxy = (IVoucherOrderService)AopContext.currentProxy();</span></span><br><span class="line"><span class="addition">+       return proxy.createVoucherOrder(voucherId);</span></span><br><span class="line"><span class="addition">+   &#125; catch (IllegalStateException e) &#123;</span></span><br><span class="line"><span class="addition">+       throw new RuntimeException(e);</span></span><br><span class="line"><span class="addition">+   &#125; finally &#123;</span></span><br><span class="line"><span class="addition">+       lock.unlock();</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="锁的超时释放问题"><a href="#锁的超时释放问题" class="headerlink" title="锁的超时释放问题"></a>锁的超时释放问题</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>上述完成了redis分布式锁的功能，在大部分场景下都能正常工作，但也会出现极端情况：</p>
<ul>
<li>线程1首先获取到锁，但是由于业务问题，造成了阻塞，所以Redis锁超时释放，然后此时线程2过来就能获取到锁，执行自己的业务逻辑，但线程2未完成前，线程1业务完成，于是释放了锁，<strong>注意：此时线程1将线程2的锁释放了</strong>。接着线程3过来，发现锁被释放了，于是也获取了锁，因此，相当于线程2和线程3都获取到了锁。</li>
</ul>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230721133034625.png" alt="image-20230721133034625"></p>
<ul>
<li>上述问题主要是线程1释放了线程2的锁，关键在于缺少锁的线程标识。解决这个问题就是在释放锁的时候，都判断一下这个锁是不是自己的，如果不属于自己，则不进行删除操作。</li>
</ul>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230721133935505.png" alt="image-20230721133935505"></p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p>主要逻辑：</p>
<ul>
<li>在获取锁时存入线程标识</li>
<li>在释放锁的时候先获取锁的线程标识，判断与当前线程标识是否一致。一致则可以释放锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//具体业务名称，将前缀和业务名拼接之后当做Key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;<span class="comment">//锁的前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;<span class="comment">//id前缀</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">//获取线程标识</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//自动拆箱可能会出现null，这样写避免空指针</span></span><br><span class="line">        <span class="keyword">return</span> success.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取线程标识</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">//获取锁中的标识</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">        <span class="comment">//判断标识是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (threadId.equals(id))&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分布式锁的原子性问题"><a href="#分布式锁的原子性问题" class="headerlink" title="分布式锁的原子性问题"></a>分布式锁的原子性问题</h2><p>虽然上面已经对超时释放问题进行了解决，但是极端情况下还会出现下面的问题：</p>
<ul>
<li>线程1执行完任务后进行锁标识的判断，判断一致，刚准备释放锁的时候出现了阻塞，此时redis锁超时释放，然后线程2获取到了锁，执行业务时线程1的阻塞结束，于是直接释放了锁，导致线程3再来也能获取到锁。这时因为<strong>判断锁标识和释放锁两个方法缺乏原子性</strong>所致</li>
</ul>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230721135127896.png" alt="image-20230721135127896"></p>
<h3 id="Lua脚本解决原子性问题"><a href="#Lua脚本解决原子性问题" class="headerlink" title="Lua脚本解决原子性问题"></a>Lua脚本解决原子性问题</h3><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，<strong>确保多条命令执行时的原子性</strong>。Lua是一种编程语言，它的基本语法可以上菜鸟教程看看，链接：<a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-tutorial.html">https://www.runoob.com/lua/lua-tutorial.html</a></p>
<p>这里重点介绍Redis提供的调用函数，可以使用Lua去操作Redis，而且还能保证它的原子性，这样就可以实现<strong>获取锁，判断线程标识，释放锁</strong>是一个原子性动作了</p>
<p><strong>使用如下：</strong></p>
<ul>
<li><p>调用函数：</p>
<ul>
<li><code>redis.call(&#39;命令名称&#39;,&#39;key&#39;,&#39;其他参数&#39;, ...)</code></li>
<li>比如：<code>redis.call(&#39;set&#39;, &#39;name&#39;, &#39;wzy&#39;)</code></li>
</ul>
</li>
<li><p>编写脚本：</p>
<ul>
<li><pre><code class="bash"># 先执行set name wzy
redis.call(&#39;set&#39;, &#39;name&#39;, &#39;wzy&#39;)
# 再执行get name
local name = redis.call(&#39;get&#39;, &#39;name&#39;)
# 返回
return name
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 写好脚本以后，需要用Redis命令来调用脚本</span><br><span class="line"></span><br><span class="line">  - `EVAL script numkeys key [key ...] arg [arg ...]`</span><br><span class="line">  - 比如：`EVAL &quot;return redis.call(&#x27;set&#x27;, &#x27;name&#x27;, &#x27;wzy&#x27;)&quot; 0`</span><br><span class="line"></span><br><span class="line">- 如果脚本中的key和value不想写死，可以作为参数传递，key类型参数会放入KEYS数组，其他参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组中获取这些参数</span><br><span class="line"></span><br><span class="line">  &gt; 在Lua中，数组下标从1开始</span><br><span class="line"></span><br><span class="line">  - `EVAL &quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[1])&quot; 1 name wzy`</span><br><span class="line"></span><br><span class="line">**使用Lua脚本来代替释放锁的逻辑：**</span><br><span class="line"></span><br><span class="line">- 原始的释放锁的逻辑</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  @Override</span><br><span class="line">  public void unlock() &#123;</span><br><span class="line">      // 获取当前线程的标识</span><br><span class="line">      String threadId = ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">      // 获取锁中的标识</span><br><span class="line">      String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">      // 判断标识是否一致</span><br><span class="line">      if (threadId.equals(id)) &#123;</span><br><span class="line">          // 释放锁</span><br><span class="line">          stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>初步改写成Lua脚本</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> key = <span class="string">&quot;lock:order:userId&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 线程标识</span></span><br><span class="line"><span class="keyword">local</span> threadId = <span class="string">&quot;UUID-33&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取锁中线程标识</span></span><br><span class="line"><span class="keyword">local</span> id = redis.call(<span class="string">&#x27;get&#x27;</span>, key)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 比较线程标识与锁的标识是否一致</span></span><br><span class="line"><span class="keyword">if</span> (threadId == id) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 一致则释放锁 del key</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, key)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是这里的参数都写死了，所以过传参的方式来变成动态的Lua脚本</p>
</blockquote>
</li>
<li><p>动态传参的Lua脚本</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里的KEYS[1]就是传入锁的key</span></span><br><span class="line"><span class="comment">-- 这里的ARGV[1]就是线程标识</span></span><br><span class="line"><span class="comment">-- 比较锁中的线程标识与线程标识是否一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 一致则释放锁</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Java调用Lua脚本改造分布式锁"><a href="#Java调用Lua脚本改造分布式锁" class="headerlink" title="Java调用Lua脚本改造分布式锁"></a>Java调用Lua脚本改造分布式锁</h3><p>在RedisTemplate中，可以利用execute方法去执行lua脚本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">execute</span><span class="params">(RedisScript&lt;T&gt; script, List&lt;K&gt; keys, Object... args)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.scriptExecutor.execute(script, keys, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法与Redis中的 <code>EVAL</code>方法一一对应：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230721164151638.png" alt="image-20230721164151638"></p>
<p><strong>实际操作：</strong></p>
<ol>
<li><p>首先在resource资源夹下新建<code>unlock.lua</code>文件，将之前写的粘贴进去</p>
</li>
<li><p>替换原本的<code>unlock</code>函数</p>
<blockquote>
<p>脚本不是调用函数时进行加载，而是在类加载时就加载脚本。这里通过静态代码块实现相应设定</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>();</span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));<span class="comment">//即resource资源文件夹下</span></span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    stringRedisTemplate.execute(UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><p><strong>基于SETNX实现的分布式锁存在以下问题：</strong></p>
<ol>
<li>不可重入<ul>
<li>同一个线程无法多次获得同一把锁</li>
<li>可重入锁的意义在于防止死锁，例如在HashTable这样的代码中，它的方法都是使用synchronized修饰的，加入它在一个方法内调用另一个方法，如果此时是不可重入的，那就死锁了。所以可重入锁的主要意义是防止死锁，synchronized和Lock锁都是可重入的</li>
</ul>
</li>
<li>不可重试<ul>
<li>编写的分布式锁只能尝试一次，失败了就返回false，没有重试机制。</li>
<li>但合理的情况应该是：当线程获取锁失败后，他应该能再次尝试获取锁</li>
</ul>
</li>
<li>超时释放<ul>
<li>在加锁的时候增加了TTL，这样可以防止死锁，但是如果业务执行耗时过长，也会导致锁的释放，存在安全隐患。</li>
<li>虽然采用Lua脚本来防止删锁的时候，误删别人的锁，但现在的新问题是没锁住，也有安全隐患</li>
</ul>
</li>
<li>主从一致性<ul>
<li>如果Redis提供了主从集群，那么当向集群写数据时，主机需要异步的将数据同步给从机，万一在同步之前，主机宕机了(主从同步存在延迟，虽然时间很短，但还是发生了)，那么又会出现死锁问题</li>
</ul>
</li>
</ol>
<p><strong>上述问题可一通过Redisson解决：</strong></p>
<p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格(In-Memory Data Grid)。它不仅提供了一系列的分布式Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现</p>
<p>Redis提供了分布式锁的多种多样功能</p>
<ol>
<li>可重入锁(Reentrant Lock)</li>
<li>公平锁(Fair Lock)</li>
<li>联锁(MultiLock)</li>
<li>红锁(RedLock)</li>
<li>读写锁(ReadWriteLock)</li>
<li>信号量(Semaphore)</li>
<li>可过期性信号量(PermitExpirableSemaphore)</li>
<li>闭锁(CountDownLatch)</li>
</ol>
<h3 id="Redisson入门"><a href="#Redisson入门" class="headerlink" title="Redisson入门"></a>Redisson入门</h3><ol>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置Redisson客户端，在config包下新建<code>RedissonConfig</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//配置类</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">//添加redis地址，这里添加的是单点地址，也可以使用config.useClusterServers()添加集群地址</span></span><br><span class="line">        config.useSingleServer()</span><br><span class="line">            .setAddress(<span class="string">&quot;redis://192.168.186.128:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;xxxxxx&quot;</span>);</span><br><span class="line">        <span class="comment">//创建客户端</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Redisson的分布式锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//获取可重入锁</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁的自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>替换之前自己写的分布式锁</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+@Autowired</span></span><br><span class="line"><span class="addition">+private RedissonClient redissonClient;</span></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">    //1.查询优惠券</span><br><span class="line">    SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);</span><br><span class="line">    //2.判断秒杀是否开始</span><br><span class="line">    if (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀尚未开始&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.判断秒杀是否结束</span><br><span class="line">    if (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀已经结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.判断库存是否充足</span><br><span class="line">    if (seckillVoucher.getStock() &lt; 1) &#123;</span><br><span class="line">        return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Long userId = UserHolder.getUser().getId();</span><br><span class="line">    // synchronized (userId.toString().intern())&#123;</span><br><span class="line"></span><br><span class="line">    //[redis实现分布式锁]</span><br><span class="line"><span class="deletion">-   SimpleRedisLock lock = new SimpleRedisLock(stringRedisTemplate, &quot;order:&quot; + userId);</span></span><br><span class="line"><span class="addition">+   RLock lock = redissonClient.getLock(&quot;order:&quot; + userId);</span></span><br><span class="line"><span class="deletion">-   boolean tryLock = lock.tryLock(5);</span></span><br><span class="line"><span class="addition">+   boolean tryLock = lock.tryLock();</span></span><br><span class="line">    if (!tryLock)&#123;</span><br><span class="line">        return Result.fail(&quot;一人只能下一单&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //获取代理对象(事务)</span><br><span class="line">    try &#123;</span><br><span class="line">        IVoucherOrderService proxy = (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">        return proxy.createVoucherOrder(voucherId);</span><br><span class="line">    &#125; catch (IllegalStateException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Redisson锁重入"><a href="#Redisson锁重入" class="headerlink" title="Redisson锁重入"></a>Redisson锁重入</h3><p>案例背景：如下所示，method1在方法内部调用method2，method1和method2出于同一个线程，那么method1已经拿到一把锁了，想进入method2中拿另外一把锁，必然是拿不到的，从而出现死锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"><span class="keyword">private</span> RLock lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    lock = redissonClient.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;获取锁失败，1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;获取锁成功&quot;</span>);</span><br><span class="line">        method2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;释放锁，1&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;获取锁失败，2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;获取锁成功，2&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;释放锁，2&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上述问题，容易想到获取锁时不能只看线程，可以<strong>设定一个属性state进行重用次数计量</strong>，对于同一个线程，可以拿到锁，但是state会+1，之后执行method2中的方法，释放锁，释放锁的时候也只是将state进行-1，只有减至0，才会真正释放锁</p>
<p>因为需要新增一个属性，所以不能使用原本的String类型了，这里可以<strong>使用Hash结构存储</strong>：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230721211145746.png" alt="image-20230721211145746"></p>
<p>此时代码逻辑如下：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230721211236155.png" alt="image-20230721211236155"></p>
<h4 id="Lua脚本实现"><a href="#Lua脚本实现" class="headerlink" title="Lua脚本实现"></a>Lua脚本实现</h4><p>为了保证原子性，流程图中的业务逻辑也需要用Lua来实现</p>
<ul>
<li>获取锁的逻辑</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"><span class="comment">-- 锁不存在</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, key) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 获取锁并添加线程标识，state设为1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="comment">-- 设置锁有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 锁存在，判断threadId是否为自己</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 锁存在，重入次数 +1，这里用的是hash结构的incrby增长</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, thread, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">-- 设置锁的有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">-- 代码走到这里，说明获取锁的不是自己，获取锁失败</span></span><br></pre></td></tr></table></figure>

<ul>
<li>释放锁的逻辑</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>];</span><br><span class="line"><span class="comment">-- 如果锁不是自己的</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, key, threadId) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">-- 直接返回</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 锁是自己的，锁计数-1，还是用hincrby，不过自增长的值为-1</span></span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">-- 判断重入次数为多少</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 大于0说明不能释放锁，重置有效期然后返回</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 等于0说明可以直接释放锁</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<p>对应Redisson中的源码，可以看出逻辑跟上述类似：</p>
<ul>
<li>获取锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; RFuture&lt;T&gt; <span class="title function_">tryLockInnerAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.evalWriteAsync(<span class="built_in">this</span>.getName(), LongCodec.INSTANCE, command, <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>, Collections.singletonList(<span class="built_in">this</span>.getName()), <span class="built_in">this</span>.internalLockLeaseTime, <span class="built_in">this</span>.getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>释放锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">unlockInnerAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.evalWriteAsync(<span class="built_in">this</span>.getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then return nil;end; local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); if (counter &gt; 0) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); return 0; else redis.call(&#x27;del&#x27;, KEYS[1]); redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); return 1; end; return nil;&quot;</span>, Arrays.asList(<span class="built_in">this</span>.getName(), <span class="built_in">this</span>.getChannelName()), LockPubSub.UNLOCK_MESSAGE, <span class="built_in">this</span>.internalLockLeaseTime, <span class="built_in">this</span>.getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redisson锁重试和WatchDog机制"><a href="#Redisson锁重试和WatchDog机制" class="headerlink" title="Redisson锁重试和WatchDog机制"></a>Redisson锁重试和WatchDog机制</h3><p>这里是对带参数的<code>tryLock</code>方法的分析</p>
<p>逻辑流程：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230721214624877.png" alt="image-20230721214624877"></p>
<h3 id="Redisson锁的MutiLock原理"><a href="#Redisson锁的MutiLock原理" class="headerlink" title="Redisson锁的MutiLock原理"></a>Redisson锁的MutiLock原理</h3><p>上面解决了<code>SETNX</code>锁的不可重入、不可重试、延时释放的缺点，但是还存在主从一致性的问题，如下图所示，当主节点宕机后，其两个从节点中的其中一个会变成主节点，但是由于主从同步失败，会导致新的主节点不存在锁，因此此时其他应用进来也能获取到锁，造成了主从节点的不一致性。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230721215719872.png" alt="image-20230721215719872"></p>
<p><strong>Redisson中使用MultiLock机制解决这个问题</strong>，如下图所示，会设定多个主节点，对应的主节点可以建立从节点。但是获取锁时必须依次向多个主节点获取锁，如果有一个没获取到都获取失败。需要将加锁的逻辑写入到每一个主从节点上，只有所有的服务器都写入成功，此时才是加锁成功，若其中一个节点宕机并且主从同步失败导致丢失锁，那么他去获取锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。<img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230721215556595.png" alt="image-20230721215556595"></p>
<h4 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h4><ol>
<li>这里先配置多个redis节点</li>
</ol>
<blockquote>
<p>这里可以通过配置多个id或者同一id的多个端口进行配置</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.186.128:6379&quot;</span>)</span><br><span class="line">                .setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.186.129:6379&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.186.130:6379&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>注入三个client，使用<code>redissonClient.getMultiLock</code>获取多个锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient2;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> RLock lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock2</span> <span class="operator">=</span> redissonClient2.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock3</span> <span class="operator">=</span> redissonClient3.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    <span class="comment">//创建联锁multiLock</span></span><br><span class="line">    lock = redissonClient.getMultiLock(lock1, lock2, lock3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    redissonClient.getMultiLock();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;获取锁失败，1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;获取锁成功&quot;</span>);</span><br><span class="line">        method2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;释放锁，1&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;获取锁失败，2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;获取锁成功，2&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;释放锁，2&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redisson分布式锁总结"><a href="#Redisson分布式锁总结" class="headerlink" title="Redisson分布式锁总结"></a>Redisson分布式锁总结</h3><ul>
<li><strong>可重入</strong>：利用hash结构记录线程id和重入次数</li>
<li><strong>可重试</strong>：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制</li>
<li><strong>超时续约</strong>：利用WatchDog，每隔一段时间，重置超时时间。</li>
</ul>
<ol>
<li>不可重入<ul>
<li>原理：利用SETNX的互斥性；利用EX避免死锁；释放锁时判断线程标识</li>
<li>缺陷：不可重入、无法重试、锁超时失效</li>
</ul>
</li>
<li>可重入<ul>
<li>原理：利用Hash结构，记录线程标识与重入次数；利用WatchDog延续锁时间；利用信号量控制锁重试等待</li>
<li>缺陷：Redis宕机引起锁失效问题</li>
</ul>
</li>
<li>Redisson的multiLock<ul>
<li>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li>
<li>缺陷：运维成本高、实现复杂</li>
</ul>
</li>
</ol>
<hr>
<h1 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h1><h2 id="异步秒杀"><a href="#异步秒杀" class="headerlink" title="异步秒杀"></a>异步秒杀</h2><p><strong>回顾下单流程：</strong></p>
<ul>
<li>当用户发起请求，此时会先请求Nginx，Nginx反向代理到Tomcat，而Tomcat中的程序，会进行串行操作，这样就会导致程序执行很慢，再加上分布式锁，整体执行就会很慢。</li>
<li><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230722141026763.png" alt="image-20230722141026763"></li>
</ul>
<p><strong>优化方案：</strong></p>
<ul>
<li><p>将耗时较短的<strong>逻辑判断放到Redis中</strong>，例如：判断秒杀库存，校验一人一单这样的操作，只要满足这两条操作，那么是一定可以下单成功的，不用等数据真的写进数据库，可以直接告诉用户下单成功就好了。然后后台同时开一个线程，后台线程异步读取阻塞队列里的消息，完成下单业务。逻辑如下所示：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230722141515078.png" alt="image-20230722141515078"></p>
</li>
</ul>
<p><strong>如何实现：</strong></p>
<ul>
<li><p>判断秒杀库存</p>
<ul>
<li>因为需要在redis中判断秒杀的库存，所以需要提前将库存缓存在redis中，直接使用String类型。</li>
</ul>
</li>
<li><p>校验一人一单</p>
<ul>
<li>需要在redis中记录该商品被哪些用户购买过，当有用户购买时，先判断是否存在，如果存在就不能购买。其特点是一个key可以对应多个value，并且value不能重复。自然想到使用Set结构存储。</li>
</ul>
</li>
<li><p>额外注意</p>
<ul>
<li>在判断了库存充足和一人一单后，在redis中进行库存的预减，并且把对应的用户id存入set集合</li>
<li>将两个过程使用Lua脚本执行，从而使得具有原子性。</li>
<li>根据Lua脚本执行的结果进行后续判断，如果具有购买资格，就将优惠券id、用户id和订单id存入阻塞队列，并将订单id返回给用户。后续另一个线程进行数据库的读写操作执行异步下单。</li>
</ul>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230722142143683.png" alt="image-20230722142143683"></p>
</li>
</ul>
<h2 id="秒杀资格判断"><a href="#秒杀资格判断" class="headerlink" title="秒杀资格判断"></a>秒杀资格判断</h2><p><strong>需求：</strong></p>
<ol>
<li><strong>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</strong></li>
<li><strong>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</strong></li>
<li>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</li>
<li>开启线程任务，不断从阻塞队列中获取信息，实现异步下单。</li>
</ol>
<p><strong>代码实现</strong></p>
<ol>
<li><p>修改保存优惠券逻辑，添加库存到redis</p>
<p><code>VoucherServiceImpl</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[异步秒杀] 保存秒杀库存到redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY+voucher.getId(),                                                                   voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后使用PostMan发送优惠券添加请求：localhost:8081&#x2F;voucher&#x2F;seckill</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;shopId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;99元代金券&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;subTitle&quot;</span><span class="punctuation">:</span><span class="string">&quot;周一至周五可用&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span><span class="string">&quot;全场通用\\n无需预约\\n可无限叠加&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;payValue&quot;</span><span class="punctuation">:</span><span class="number">5000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;actualValue&quot;</span><span class="punctuation">:</span><span class="number">10000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span><span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;beginTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2023-07-22T19:00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;endTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2023-07-22T23:59:59&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时可以在Mysql数据库和Redis中看到新增的优惠券数据。redis中缓存了优惠券的库存</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230722145104166.png" alt="image-20230722145104166"></p>
</blockquote>
</li>
<li><p>编写Lua脚本</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1 优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2 用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1 库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2 订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1 判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.2 判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3 存在说明是重复下单</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.4 扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span> ,stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5 下单（保存用户） sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li>lua的字符串拼接使用<code>..</code>，字符串转数字是<code>tonumber()</code></li>
<li></li>
</ul>
</blockquote>
</li>
<li><p>修改下单逻辑（保存阻塞队列部分后续实现）</p>
<p><code>VoucherOrderServiceImpl</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这部分是导入lua脚本</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));</span><br><span class="line">    SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">        SECKILL_SCRIPT,</span><br><span class="line">        Collections.emptyList(),</span><br><span class="line">        voucherId.toString(), UserHolder.getUser().getId().toString()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 判断返回值是否为0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//2.1 不为0代表没有购买资格</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(r==<span class="number">1</span>?<span class="string">&quot;库存不足&quot;</span>:<span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.2 为0，有购买资格，把下单信息保存在阻塞队列</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">// TODO 保存阻塞队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>此时使用JMeter进行高并发测试，可以看出平均耗时只有197ms</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230722152851549.png" alt="image-20230722152851549"></p>
<p>并且redis中也保存了下单信息，保存了用户的id</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230722153001811.png" alt="image-20230722153001811"></p>
<h2 id="阻塞队列实现"><a href="#阻塞队列实现" class="headerlink" title="阻塞队列实现"></a>阻塞队列实现</h2><p><strong>需求：</strong></p>
<ol>
<li>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</li>
<li>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</li>
<li><strong>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</strong></li>
<li><strong>开启线程任务，不断从阻塞队列中获取信息，实现异步下单。</strong></li>
</ol>
<p><strong>代码实现：</strong></p>
<ol>
<li><p>将优惠券，用户等信息封装并存入阻塞队列</p>
<blockquote>
<p><strong>阻塞队列特点</strong>：当一个线程尝试从阻塞队列里获取元素的时候，如果没有元素，那么该线程就会被阻塞，直到队列中有元素，才会被唤醒，并去获取元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">        SECKILL_SCRIPT,</span><br><span class="line">        Collections.emptyList(),</span><br><span class="line">        voucherId.toString(), UserHolder.getUser().getId().toString()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 判断返回值是否为0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//2.1 不为0代表没有购买资格</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.2 为0，有购买资格，把下单信息保存在阻塞队列</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">// TODO 保存阻塞队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装到voucherOrder中</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    voucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">//加入到阻塞队列</span></span><br><span class="line">    orderTasks.add(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现异步下单功能</p>
<ul>
<li>创建一个线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor(); </span><br></pre></td></tr></table></figure>

<ul>
<li>开启一个线程，这里使用内部类实现</li>
</ul>
<blockquote>
<p>这里的异步下单需要在项目一启动就执行从阻塞队列中获取信息。所以这里就用到了<code>@PostConstruct</code>注解，项目一启动就调用这个方法，在其中开启一个线程任务，不断从队列中获取订单信息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1. 获取队列中的订单信息</span></span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                <span class="comment">//2. 创建订单</span></span><br><span class="line">                handleVoucherOrder(voucherOrder);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;订单处理异常&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建订单逻辑handleVoucherOrder</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 获取用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">    <span class="comment">//2. 创建锁对象，作为兜底方案</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;order:&quot;</span> + userId);</span><br><span class="line">    <span class="comment">//3. 获取锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock();</span><br><span class="line">    <span class="comment">//4. 判断是否获取锁成功         </span></span><br><span class="line">    <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;不允许重复下单!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//5. 使用代理对象，由于这里是另外一个线程，</span></span><br><span class="line">        proxy.createVoucherOrder(voucherOrder);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redisLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>这里同样需要创建代理进行，后续进行解释；并且这里的锁已经不需要了，因为我们在前面<strong>秒杀资格判断</strong>中已经进行了判断，这里只是作为兜底</p>
<p>这里用到了<code>createVoucherOrder</code>方法，传入的整个订单（原本是传入订单id），该方法后续会进行部分修改。</p>
</blockquote>
<ul>
<li>获取代理对象是通过ThreadLocal进行获取的，由于这里是异步下单，和主线程不是一个线程，所以不能获取成功</li>
<li>可以<strong>将proxy放在成员变量的位置</strong>，然后在主线程中获取代理对象。然后如上述所示<code>handleVoucherOrder</code>调用proxy执行方法即可</li>
</ul>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+private IVoucherOrderService proxy;</span></span><br><span class="line">@Override</span><br><span class="line">public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">    //1. 执行lua脚本</span><br><span class="line">    Long result = stringRedisTemplate.execute(</span><br><span class="line">        SECKILL_SCRIPT,</span><br><span class="line">        Collections.emptyList(),</span><br><span class="line">        voucherId.toString(), UserHolder.getUser().getId().toString()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    //2. 判断返回值是否为0</span><br><span class="line">    int r = result.intValue();</span><br><span class="line">    if (r != 0) &#123;</span><br><span class="line">        //2.1 不为0代表没有购买资格</span><br><span class="line">        return Result.fail(r == 1 ? &quot;库存不足&quot; : &quot;不能重复下单&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //2.2 为0，有购买资格，把下单信息保存在阻塞队列</span><br><span class="line">    long orderId = redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">    // TODO 保存阻塞队列</span><br><span class="line"></span><br><span class="line">    //封装到voucherOrder中</span><br><span class="line">    VoucherOrder voucherOrder = new VoucherOrder();</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    voucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    //加入到阻塞队列</span><br><span class="line">    orderTasks.add(voucherOrder);</span><br><span class="line"></span><br><span class="line"><span class="addition">+   //主线程获取代理对象</span></span><br><span class="line"><span class="addition">+   proxy = (IVoucherOrderService) AopContext.currentProxy();</span></span><br><span class="line"></span><br><span class="line">    //3. 返回订单id</span><br><span class="line">    return Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改创建订单的逻辑</p>
</li>
</ol>
<p>   原本代码：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//[一人一单]</span></span><br><span class="line">    <span class="comment">// 查询订单</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="comment">// 判断订单是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;不能重复购买&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">        .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">        .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">        .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">//where id = ? and stock &gt; 0</span></span><br><span class="line">        .update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">//6.1订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">//6.2用户id</span></span><br><span class="line"></span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">//6.3代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的创建订单逻辑已经不需要了，可以删去</p>
<p>因为这部分逻辑是通过异步执行，不能再使用<code>UserHolder</code>中获取userId，所以这里通过传入的订单信息获取用户id，并且订单id也通过传入的订单获取订单id</p>
</blockquote>
<p>   修改后：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">    <span class="comment">//[一人一单]</span></span><br><span class="line">    <span class="comment">// 查询订单</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();</span><br><span class="line">    <span class="comment">// 判断订单是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;不能重复购买&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">        .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">        .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId())</span><br><span class="line">        .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">//where id = ? and stock &gt; 0</span></span><br><span class="line">        .update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    save(voucherOrder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，下单后redis中的缓存stock会-1，数据库中的stock也会-1，并且出现订单，重复下单就会提示一人一单。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>秒杀业务的<strong>优化思路</strong>是什么？</p>
<ol>
<li>先利用Redis完成库存容量、一人一单的判断，完成抢单业务</li>
<li>再将下单业务放入阻塞队列，利用独立线程异步下单</li>
</ol>
<p>基于阻塞队列的异步秒杀<strong>存在哪些问题</strong>？</p>
<ol>
<li>内存限制问题：<ul>
<li>我们现在使用的是JDK里的阻塞队列，它使用的是JVM的内存，如果在高并发的条件下，无数的订单都会放在阻塞队列里，可能就会造成内存溢出，所以我们在创建阻塞队列时，设置了一个长度，但是如果真的存满了，再有新的订单来往里塞，那就塞不进去了，存在内存限制问题</li>
</ul>
</li>
<li>数据安全问题：<ul>
<li>经典服务器宕机了，用户明明下单了，但是数据库里没看到</li>
</ul>
</li>
</ol>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载lua脚本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));</span><br><span class="line">        SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//异步下单，准备线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//1. 获取队列中的订单信息</span></span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                    <span class="comment">//2. 创建订单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;订单处理异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建订单逻辑</span></span><br><span class="line">    <span class="keyword">private</span> IVoucherOrderService proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 获取用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="comment">//2. 创建锁对象，作为兜底方案</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;order:&quot;</span> + userId);</span><br><span class="line">        <span class="comment">//3. 获取锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock();</span><br><span class="line">        <span class="comment">//4. 判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;不允许重复下单!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//5. 使用代理对象，由于这里是另外一个线程，</span></span><br><span class="line">            proxy.createVoucherOrder(voucherOrder);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            redisLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 执行lua脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">                SECKILL_SCRIPT,</span><br><span class="line">                Collections.emptyList(),</span><br><span class="line">                voucherId.toString(), UserHolder.getUser().getId().toString()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 判断返回值是否为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//2.1 不为0代表没有购买资格</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2 为0，有购买资格，把下单信息保存在阻塞队列</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        <span class="comment">// TODO 保存阻塞队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装到voucherOrder中</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        voucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">//加入到阻塞队列</span></span><br><span class="line">        orderTasks.add(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程获取代理对象</span></span><br><span class="line">        proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="comment">//[一人一单]</span></span><br><span class="line">        <span class="comment">// 查询订单</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();</span><br><span class="line">        <span class="comment">// 判断订单是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;不能重复购买&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId())</span><br><span class="line">                .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">//where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.创建订单</span></span><br><span class="line">        save(voucherOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p>消息队列(<strong>M</strong>essage <strong>Q</strong>ueue)，字面意思就是存放消息的队列，最简单的消息队列模型包括3个角色</p>
<ol>
<li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li>
<li>生产者：发送消息到消息队列</li>
<li>消费者：从消息队列获取消息并处理消息</li>
</ol>
<p>举例：</p>
<p>快递员把快递放到驿站&#x2F;快递柜里去(Message Queue)去，消费者从快递柜&#x2F;驿站去拿快递，这就是一个异步，如果耦合，那么快递员必须亲自上楼把快递送到你手里，服务当然好，但是万一我不在家，快递员就得一直等我，浪费了快递员的时间。所以解耦还是非常有必要的</p>
<p>但这样看，跟之前的阻塞队列不一样吗？这里有<strong>两个区别</strong>：</p>
<ul>
<li>消息队列独立于JVM之外的服务，不受JVM内存的限制</li>
<li>消息队列不仅仅是做数据存储，还要确保数据安全，存入消息队列中的数据做持久化。而且将消息投递给消费者后需要消费者确认，如果不确认消息队列中还会保存该信息。</li>
</ul>
<p>一些现成的(MQ)消息队列：如kafka，rabbitmq等，如果没有安装MQ，也可以使用Redis提供的MQ方案。<strong>Redis提供了三种不同的方式实现消息队列</strong>：</p>
<ul>
<li>list结构：基于List结构模拟消息队列</li>
<li>PubSub：基本的点对点消息模型</li>
<li>Stream：比较完善的消息队列模型</li>
</ul>
<h2 id="基于List实现消息队列"><a href="#基于List实现消息队列" class="headerlink" title="基于List实现消息队列"></a>基于List实现消息队列</h2><p>消息队列(Message Queue)，字面意思就是存放消息的队列，而Redis的list数据结构是一个双向链表，很容易模拟出队列的效果。队列的入口和出口不在同一边，所以我们可以利用：<strong>LPUSH结合RPOP或者RPUSH结合LPOP来实现消息队列</strong>。</p>
<p>注意：当队列中没有消息时，RPOP和LPOP操作会返回NULL，而不像JVM阻塞队列那样会阻塞，并等待消息，所以我们这里应该<strong>使用BRPOP或者BLPOP来实现阻塞效果</strong></p>
<p>基于List的消息队列有哪些<strong>优缺点</strong>？</p>
<ul>
<li><strong>优点</strong><ol>
<li>利用Redis存储，不受限于JVM内存上限</li>
<li>基于Redis的持久化机制，数据安全性有保障</li>
<li>可以满足消息有序性</li>
</ol>
</li>
<li><strong>缺点</strong><ol>
<li>无法避免消息丢失(服务器宕机)</li>
<li>只支持单消费者(一个消费者把消息拿走了，其他消费者就看不到这条消息了)</li>
</ol>
</li>
</ul>
<h2 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h2><p><strong>PubSub(发布订阅)<strong>是Redis2.0版本引入的消息传递模型。顾名思义，</strong>消费和可以订阅一个或多个channel</strong>，生产者向对应channel发送消息后，<strong>所有订阅者都能收到相关消息</strong></p>
<p><strong>常用命令：</strong></p>
<ul>
<li><p><code>SUBSCRIBE channel [channel]</code>：订阅一个或多个频道</p>
</li>
<li><p><code>PUBLISH channel msg</code>：向一个频道发送消息</p>
</li>
<li><p><code>PSUBSCRIBE pattern [pattern]</code>：订阅与pattern格式匹配的所有频道</p>
<blockquote>
<p>Subscribes the client to the given patterns.</p>
<p>Supported glob-style patterns:</p>
<ul>
<li><code>h?llo</code> subscribes to <code>hello</code>, <code>hallo</code> and <code>hxllo</code></li>
<li><code>h*llo</code> subscribes to <code>hllo</code> and <code>heeeello</code></li>
<li><code>h[ae]llo</code> subscribes to <code>hello</code> and <code>hallo,</code> but not <code>hillo</code></li>
</ul>
<p>Use <code>\</code> to escape special characters if you want to match them verbatim.</p>
</blockquote>
</li>
</ul>
<p>基于PubSub的消息队列有哪些<strong>优缺点</strong></p>
<ul>
<li><strong>优点：</strong><ol>
<li>采用发布订阅模型，支持多生产，多消费</li>
</ol>
</li>
<li><strong>缺点：</strong><ol>
<li>不支持数据持久化</li>
<li>无法避免消息丢失（如果向频道发送了消息，却没有人订阅该频道，那发送的这条消息就丢失了）</li>
<li>消息堆积有上限，超出时数据丢失（消费者拿到数据的时候处理的太慢，而发送消息发的太快）</li>
</ol>
</li>
</ul>
<h2 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h2><p>Stream是Redis 5.0引入的一种<strong>新数据类型</strong>，可以时间一个功能非常完善的消息队列</p>
<p><strong>命令：</strong></p>
<ul>
<li><p><strong>发送消息：</strong></p>
<ul>
<li><p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723134910600.png" alt="image-20230723134910600"></p>
</li>
<li><p>使用示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建名为users的队列，并向其中发送一个消息，内容是&#123;name=jack, age=21&#125;，并且使用Redis自动生成ID</span></span><br><span class="line">XADD <span class="built_in">users</span> * name jack age 21</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>读取消息：</strong></p>
<ul>
<li><p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723135210955.png" alt="image-20230723135210955"></p>
</li>
<li><p>使用示例：</p>
<ul>
<li><p>读取第一个消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt;XREAD COUNT 1 STREAMS <span class="built_in">users</span> 0</span><br><span class="line">1) 1) <span class="string">&quot;users&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1667119621804-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;jack&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;21&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>并且可以重复读取，消息不会删除，一直保存在消息队列中</p>
</blockquote>
</li>
<li><p>读取最后一个消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt;XREAD COUNT 1 STREAMS <span class="built_in">users</span> $</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>阻塞读取：</strong></p>
<ul>
<li><p>使用阻塞读取最新消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREAD COUNT 1 BLOCK 1000 STREAMS <span class="built_in">users</span> $</span><br></pre></td></tr></table></figure>
</li>
<li><p>在业务开发中，可以循环调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">//尝试读取队列中的消息，最多阻塞2秒</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> redis.execute(<span class="string">&quot;XREAD COUNT 1 BLOCK 2000 STREAMS users $&quot;</span>);</span><br><span class="line">    <span class="comment">//没读取到，跳过下面的逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(msg == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理消息</span></span><br><span class="line">    handleMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意：</strong>当我们指定其实ID为$时，代表只能读取到最新消息，如果当我们在处理一条消息的过程中，又有<strong>超过1条以上的消息到达队列</strong>，那么下次获取的时候，也只能获取到最新的一条，会出现<strong>漏读消息</strong>的问题</p>
</li>
</ul>
</li>
</ul>
<p>STREAM类型消息队列的<strong>XREAD命令特点</strong></p>
<ol>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有漏读消息的风险</li>
</ol>
<h2 id="基于Stream的消息队列—消费者组"><a href="#基于Stream的消息队列—消费者组" class="headerlink" title="基于Stream的消息队列—消费者组"></a>基于Stream的消息队列—消费者组</h2><p><strong>消费者组(Consumer Group)<strong>：将多个消费者划分到一个组中，监听同一个队列，具备以下</strong>特点</strong></p>
<ul>
<li><p><strong>消息分流</strong>：队列中的消息会分留给组内的不同消费者，而不是重复消费者，从而加快消息处理的速度</p>
</li>
<li><p><strong>消息标识</strong>：消费者会维护一个标识，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标识之后读取消息，确保每一个消息都会被消费</p>
</li>
<li><p><strong>消息确认</strong>：消费者获取消息后，消息处于pending状态（待处理），并存入一个pending-list，当处理完成后，需要通过XACK命令来确认消息，标记消息为已处理，才会从pending-list中移除</p>
</li>
</ul>
<p><strong>命令：</strong></p>
<ul>
<li><p><strong>创建消费者组：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATE key groupName ID [MKSTREAM]</span><br></pre></td></tr></table></figure>

<ul>
<li>key：队列名称</li>
<li>groupName：消费者组名称</li>
<li>ID：起始ID标识，$代表队列中的最后一个消息，0代表队列中的第一个消息</li>
<li>MKSTREAM：队列不存在时自动创建队列</li>
</ul>
</li>
<li><p><strong>从消费者组中读取消息</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [keys ...] ID [ID ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>group：消费者组名称</li>
<li>consumer：消费者名，如果消费者不存在，会自动创建一个消费者</li>
<li>count：本次查询的最大数量</li>
<li>BLOCK milliseconds：当前没有消息时的最大等待时间</li>
<li>NOACK：无需手动ACK，获取到消息后自动确认（一般不配置，们都是手动确认）</li>
<li>STREAMS key：指定队列名称</li>
<li>ID：获取消息的起始ID<ul>
<li><code>&gt;</code>：从<strong>下一个未消费</strong>的消息开始(pending-list中)</li>
<li>其他：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>其他常见命令</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除指定的消费者组</span></span><br><span class="line">XGROUP DESTORY key groupName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给指定的消费者组添加消费者</span></span><br><span class="line">XGROUP CREATECONSUMER key groupName consumerName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除消费者组中指定的消费者</span></span><br><span class="line">XGROUP DELCONSUMER key groupName consumerName</span><br></pre></td></tr></table></figure></li>
</ul>
<p>STREAM类型消息队列的<strong>XREADGROUP命令的特点</strong></p>
<ol>
<li>消息可回溯</li>
<li>可以多消费者争抢消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消息漏读风险</li>
<li>有消息确认机制，保证消息至少被消费一次</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">List</th>
<th align="center">PubSub</th>
<th align="center">Stream</th>
</tr>
</thead>
<tbody><tr>
<td align="center">消息持久化</td>
<td align="center">支持</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">阻塞读取</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">消息堆积处理</td>
<td align="center">受限于内存空间， 可以利用多消费者加快处理</td>
<td align="center">受限于消费者缓冲区</td>
<td align="center">受限于队列长度， 可以利用消费者组提高消费速度，减少堆积</td>
</tr>
<tr>
<td align="center">消息确认机制</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">消息回溯</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<p><strong>消费者监听消息的基本思路</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 尝试监听队列，使用阻塞模式，最大等待时长为2000ms</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> redis.call(<span class="string">&quot;XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(msg == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 没监听到消息，重试</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//处理消息，完成后要手动确认ACK，ACK代码在handleMessage中编写</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//0表示从pending-list中的第一个消息开始，如果前面都ACK了，那么这里就不会监听到消息</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> redis.call(<span class="string">&quot;XREADGROUP GROUP g1 c1 COUNT 1 STREAMS s1 0&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(msg == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//null表示没有异常消息，所有消息均已确认，结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//说明有异常消息，再次处理</span></span><br><span class="line">                handleMessage(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                <span class="comment">//再次出现异常，记录日志，继续循环</span></span><br><span class="line">                log.error(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>后续的内容我没有继续看了，因为实际生产中用的更多的还是MQ中间件，这里只是作为了解下即可，后续可以看SpringCloud课程学习消息队列</p>
</blockquote>
<hr>
<h1 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h1><h2 id="发布探店笔记"><a href="#发布探店笔记" class="headerlink" title="发布探店笔记"></a>发布探店笔记</h2><p>探店笔记类似点评网站的评价，往往是图文结合，<strong>对应的表</strong>有两个：</p>
<ul>
<li><p>tb_blog：探店店笔记表，包含笔记中的标题、文字、图片等</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723144810877.png" alt="image-20230723144810877"></p>
</li>
<li><p>tb_blog_comments：其他用户对探店笔记的评价</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723144837759.png" alt="image-20230723144837759"></p>
</li>
</ul>
<p>点击首页最下方菜单栏中的+按钮，即可发布探店笔记。（因为这部分的代码不涉及Redis，已经实现好了，可以直接使用。）</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723145018314.png" alt="image-20230723145018314"></p>
<p>这里上传图片和发布评论是独立实现的：</p>
<ul>
<li><p><strong>图片上传</strong>代码</p>
<p><code>UploadController</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">uploadImage</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取原始文件名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">        <span class="comment">// 生成新文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> createNewFileName(originalFilename);</span><br><span class="line">        <span class="comment">// 保存文件</span></span><br><span class="line">        image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        log.debug(<span class="string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(fileName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件上传失败&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里通过<code>SystemConstants.IMAGE_UPLOAD_DIR</code>制定了图片的本地路径</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemConstants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IMAGE_UPLOAD_DIR</span> <span class="operator">=</span> <span class="string">&quot;D:\\lesson\\nginx-1.18.0\\html\\hmdp\\imgs\\&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER_NICK_NAME_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;user_&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_PAGE_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_PAGE_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是这里我们需要修改图片路径为自己的，也就是之前下载的Nginx目录下的imgs文件夹下</p>
</blockquote>
</li>
<li><p><strong>发布笔记</strong>代码：</p>
<p><code>BlogController</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(<span class="meta">@RequestBody</span> Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    <span class="comment">// 保存探店博文</span></span><br><span class="line">    blogService.save(blog);</span><br><span class="line">    <span class="comment">// 返回id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="查看探店笔记"><a href="#查看探店笔记" class="headerlink" title="查看探店笔记"></a>查看探店笔记</h2><p>需求：点击首页的探店笔记，会进入详情页面，现在需要实现页面的查询接口</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723150109965.png" alt="image-20230723150109965"></p>
<p>点击对应的笔记后，首先会发送如下请求：</p>
<blockquote>
<p> Request URL: <a target="_blank" rel="noopener" href="http://localhost:8080/api/blog/23">http://localhost:8080/api/blog/23</a></p>
<p>Request Method: GET</p>
</blockquote>
<p>此时<code>BlogController</code>中没有对应的方法，首先在Controller中进行调用</p>
<ul>
<li><p><code>Controller层</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getBlog</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ServiceImpl</code></p>
<p>在Service类中创建对应方法之后，在Impl类中实现，查看用户探店笔记的时候，<strong>需要额外设置用户名和其头像</strong>，由于设置用户信息这个操作比较通用，所以这里封装成了一个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//查询blog</span></span><br><span class="line">    <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="keyword">if</span> (blog==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;笔记不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询blog相关用户</span></span><br><span class="line">    queryBlogUser(blog);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryBlogUser</span><span class="params">(Blog blog)</span>&#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> blog.getUserId();</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">    blog.setName(user.getNickName());</span><br><span class="line">    blog.setIcon(user.getIcon());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>顺手将<code>queryHotBlog</code>也修改一下，原始代码将业务逻辑写到了Controller中，此时整体代码如下：</p>
<ul>
<li><p><code>Controller</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlogController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IBlogService blogService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(<span class="meta">@RequestBody</span> Blog blog)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取登录用户</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        blog.setUserId(user.getId());</span><br><span class="line">        <span class="comment">// 保存探店博文</span></span><br><span class="line">        blogService.save(blog);</span><br><span class="line">        <span class="comment">// 返回id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> blogService.queryBlogById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/like/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 修改点赞数量</span></span><br><span class="line">        blogService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/of/me&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryMyBlog</span><span class="params">(<span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取登录用户</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        <span class="comment">// 根据用户查询</span></span><br><span class="line">        Page&lt;Blog&gt; page = blogService.query()</span><br><span class="line">                .eq(<span class="string">&quot;user_id&quot;</span>, user.getId()).page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));</span><br><span class="line">        <span class="comment">// 获取当前页数据</span></span><br><span class="line">        List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line">        <span class="keyword">return</span> Result.ok(records);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hot&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryHotBlog</span><span class="params">(<span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> blogService.queryHotBlog(current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ServiceImpl</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlogServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;BlogMapper, Blog&gt; <span class="keyword">implements</span> <span class="title class_">IBlogService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryBlogById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">//查询blog</span></span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="keyword">if</span> (blog==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;笔记不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查询blog相关用户</span></span><br><span class="line">        queryBlogUser(blog);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryHotBlog</span><span class="params">(Integer current)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据用户查询</span></span><br><span class="line">        Page&lt;Blog&gt; page = query()</span><br><span class="line">                .orderByDesc(<span class="string">&quot;liked&quot;</span>)</span><br><span class="line">                .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));</span><br><span class="line">        <span class="comment">// 获取当前页数据</span></span><br><span class="line">        List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line">        <span class="comment">// 查询用户</span></span><br><span class="line">        records.forEach(<span class="built_in">this</span>::queryBlogUser);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(records);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryBlogUser</span><span class="params">(Blog blog)</span>&#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> blog.getUserId();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">        blog.setName(user.getNickName());</span><br><span class="line">        blog.setIcon(user.getIcon());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里L28用到了java8新特性中的lambda表达式，后续进行详细了解</p>
</blockquote>
</li>
</ul>
<p>此时点击查看探店笔记，可以看到详细内容</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723152046148.png" alt="image-20230723152046148"></p>
<h2 id="点赞功能"><a href="#点赞功能" class="headerlink" title="点赞功能"></a>点赞功能</h2><p>原本的代码已经有了初步的实现。点击点赞按钮，查看发送的请求</p>
<blockquote>
<p>请求网址: <a target="_blank" rel="noopener" href="http://localhost:8080/api/blog/like/23">http://localhost:8080/api/blog/like/23</a><br>请求方法: PUT</p>
</blockquote>
<p>BlogController中的like方法，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;/like/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改点赞数量</span></span><br><span class="line">    blogService.update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是目前存在问题，也就是同一个用户可以无限制点赞，这明显是不合理的。造成这个问题的原因是现在的逻辑发起请求只是简单地给数据库+1，并没有用户判断，所以才会出现这个问题</p>
<h3 id="功能完善"><a href="#功能完善" class="headerlink" title="功能完善"></a>功能完善</h3><p><strong>需求</strong></p>
<ol>
<li>同一个用户只能对同一篇笔记点赞一次，再次点击则取消点赞</li>
<li>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li>
</ol>
<p><strong>实现步骤</strong></p>
<ol>
<li>给Blog类添加一个isLike字段，表示是否被当前用户点赞过。<ul>
<li>这里可以利用<strong>Redis中的set集合</strong>来存储点赞后的用户id表明该用户已经点赞过。</li>
</ul>
</li>
<li>修改点赞功能，利用Redis中的set集合来判断是否点赞过，未点赞则点赞数<code>+1</code>，已点赞则点赞数<code>-1</code></li>
<li>修改根据id查询的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li>
<li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li>
</ol>
<p><strong>代码实现</strong></p>
<ol>
<li><p>首先在Blog类中添加字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 是否点赞过了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@TableField(exist = false)</span> <span class="comment">//表明不是数据库中的字段</span></span><br><span class="line"><span class="keyword">private</span> Boolean isLike;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改controller逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;/like/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.likeBlog(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将对应业务逻辑写在serviceImpl中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//获取登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//判断当前用户是否已经点赞</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.BLOG_LIKED_KEY + id;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(isMember))&#123;</span><br><span class="line">        <span class="comment">//如果未点赞，则数据库对应点赞数+1</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="comment">//保存用户id到redis</span></span><br><span class="line">        <span class="keyword">if</span> (isSuccess)&#123;</span><br><span class="line">            stringRedisTemplate.opsForSet().add(key, userId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果已点赞，取消点赞，并数据库点赞数-1</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="comment">//并从redis中移除用户id</span></span><br><span class="line">        <span class="keyword">if</span> (isSuccess)&#123;</span><br><span class="line">            stringRedisTemplate.opsForSet().remove(key, userId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改查询blog的逻辑，判断Blog是否被当前用户点赞过，并设置blog的isLiked字段</p>
<blockquote>
<p>因为这里按照id查询和分页查询都要用到这个功能，所以这里也抽离成一个方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//查询blog</span></span><br><span class="line">    <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="keyword">if</span> (blog==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;笔记不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询blog相关用户</span></span><br><span class="line">    queryBlogUser(blog);</span><br><span class="line">    <span class="comment">//[new]查询blog是否被点赞</span></span><br><span class="line">    isBlogLiked(blog);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryHotBlog</span><span class="params">(Integer current)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据用户查询</span></span><br><span class="line">    Page&lt;Blog&gt; page = query()</span><br><span class="line">        .orderByDesc(<span class="string">&quot;liked&quot;</span>)</span><br><span class="line">        .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));</span><br><span class="line">    <span class="comment">// 获取当前页数据</span></span><br><span class="line">    List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line"></span><br><span class="line">    records.forEach(blog -&gt; &#123;</span><br><span class="line">        <span class="comment">// 查询用户</span></span><br><span class="line">        <span class="built_in">this</span>.queryBlogUser(blog);</span><br><span class="line">        <span class="comment">//[new]查询blog是否被点赞</span></span><br><span class="line">        <span class="built_in">this</span>.isBlogLiked(blog);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(records);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">isBlogLiked</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">//获取登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//判断当前用户是否已经点赞</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.BLOG_LIKED_KEY + blog.getId();</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span><br><span class="line">    blog.setIsLike(BooleanUtil.isTrue(isMember));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>此时再点赞笔记，点赞后就会高亮，再次点赞就会取消。并且对应Redis中也保存了指定笔记的点赞用户id信息</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723155421867.png" alt="image-20230723155421867"></p>
<h2 id="点赞排行榜"><a href="#点赞排行榜" class="headerlink" title="点赞排行榜"></a>点赞排行榜</h2><p>在探店笔记的详情页面，应该把给该笔记点赞的用户显示出来，比如最早点赞的Top5，形成点赞排行榜。参考微信、QQ的动态点赞</p>
<p>这里进行<strong>Redis中集合的对比</strong>：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">List</th>
<th align="center">Set</th>
<th align="center">SortedSet</th>
</tr>
</thead>
<tbody><tr>
<td align="center">排序方式</td>
<td align="center">按添加顺序排序</td>
<td align="center">无法排序</td>
<td align="center">根据score值排序</td>
</tr>
<tr>
<td align="center">唯一性</td>
<td align="center">不唯一</td>
<td align="center">唯一</td>
<td align="center">唯一</td>
</tr>
<tr>
<td align="center">查找方式</td>
<td align="center">按索引查找或首尾查找</td>
<td align="center">根据元素查找</td>
<td align="center">根据元素查找</td>
</tr>
</tbody></table>
<p>之前的点赞是放到Set集合中，但是Set集合又不能排序，所以这个时候，就可以<strong>改用SortedSet(Zset)<strong>，可以</strong>用时间戳作为score</strong>，从而实现排序</p>
<ul>
<li>但是ZSet没有isMember方法，所以这里使用<code>ZSCORE</code>命令查询score来判断集合中是否有该元素，如果有该元素，则返回值是对应的score，如果没有该元素，则返回值为null</li>
<li>获取点赞排行可以通过<code>ZRANGE</code>命令获取指定范围内的数据</li>
</ul>
<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><p><strong>使用ZSET替换SET：</strong></p>
<ol>
<li><p>修改<code>BlogServiceImpl</code>中<code>likeBlog</code>的点赞逻辑</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Result likeBlog(Long id) &#123;</span><br><span class="line">    //获取登录用户</span><br><span class="line">    Long userId = UserHolder.getUser().getId();</span><br><span class="line">    //判断当前用户是否已经点赞</span><br><span class="line">    String key = RedisConstants.BLOG_LIKED_KEY + id;</span><br><span class="line"><span class="deletion">-   Boolean isMember = stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span></span><br><span class="line"><span class="addition">+   Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString());</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-   if (Boolean.FALSE.equals(isMember))&#123;</span></span><br><span class="line"><span class="addition">+   if (score == null)&#123;</span></span><br><span class="line">       //如果未点赞，则数据库对应点赞数+1</span><br><span class="line">       boolean isSuccess = update().setSql(&quot;liked = liked + 1&quot;).eq(&quot;id&quot;, id).update();</span><br><span class="line">       //保存用户id到redis</span><br><span class="line">       if (isSuccess)&#123;</span><br><span class="line"><span class="deletion">-          stringRedisTemplate.opsForSet().add(key, userId.toString());</span></span><br><span class="line"><span class="addition">+          stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;else &#123;</span><br><span class="line">        //如果已点赞，取消点赞，并数据库点赞数-1</span><br><span class="line">        boolean isSuccess = update().setSql(&quot;liked = liked - 1&quot;).eq(&quot;id&quot;, id).update();</span><br><span class="line">        //并从redis中移除用户id</span><br><span class="line">        if (isSuccess)&#123;</span><br><span class="line"><span class="deletion">-            stringRedisTemplate.opsForSet().remove(key, userId.toString());</span></span><br><span class="line"><span class="addition">+            stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>isBlogLiked</code></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void isBlogLiked(Blog blog) &#123;</span><br><span class="line">    //获取登录用户</span><br><span class="line">    Long userId = UserHolder.getUser().getId();</span><br><span class="line">    //判断当前用户是否已经点赞</span><br><span class="line">    String key = RedisConstants.BLOG_LIKED_KEY + blog.getId();</span><br><span class="line"><span class="deletion">-   Boolean isMember = stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span></span><br><span class="line"><span class="deletion">-   blog.setIsLike(BooleanUtil.isTrue(isMember));</span></span><br><span class="line"><span class="addition">+   Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString());</span></span><br><span class="line"><span class="addition">+   blog.setIsLike(score != null);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>点赞排行实现：</strong></p>
<p>目前点击笔记详情，会有一个请求报错，内容如下：</p>
<blockquote>
<p>Request URL: <a target="_blank" rel="noopener" href="http://localhost:8080/api/blog/likes/23">http://localhost:8080/api/blog/likes/23</a></p>
<p>Request Method: GET</p>
</blockquote>
<ol>
<li><p>在controller中实现对应方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogLikes(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在serviceImpl中实现具体逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取top点赞用户  zrange key 0 4</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.BLOG_LIKED_KEY + id;</span><br><span class="line">    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (top5 == <span class="literal">null</span> || top5.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析其中的用户</span></span><br><span class="line">    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 根据id查询用户</span></span><br><span class="line">    List&lt;UserDTO&gt; userDTOS = userService.listByIds(ids)</span><br><span class="line">        .stream()</span><br><span class="line">        .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>又是stream流，后需要好好学java8新特性！</p>
<p>这里使用userDTO还是防止用户敏感信息泄露，只返回用户name、头像和id</p>
</blockquote>
</li>
</ol>
<p>此时点赞后，可以在详情页面看到点赞用户的头像</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723170421142.png" alt="image-20230723170421142"></p>
<h3 id="解决BUG"><a href="#解决BUG" class="headerlink" title="解决BUG"></a>解决BUG</h3><h4 id="不登陆访问首页"><a href="#不登陆访问首页" class="headerlink" title="不登陆访问首页"></a>不登陆访问首页</h4><p>此时，若没有进行登录，直接访问首页，就会发生空指针异常，并且获取不到笔记详情。但是首页的信息并不需要登录，所以就无法获取到用户id，因此在后续根据id查询笔记和分页查询笔记中，根据用户id查询是否点赞就会报出异常。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723170730611.png" alt="image-20230723170730611"></p>
<p>所以这里需要对<code>isBlogLiked</code>方法进行修改，如果获取用户为空，直接返回即可，不在进行后续是否点赞的判断。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void isBlogLiked(Blog blog) &#123;</span><br><span class="line">    //获取登录用户</span><br><span class="line"><span class="deletion">-   Long userId = UserHolder.getUser().getId();</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+   UserDTO user = UserHolder.getUser();</span></span><br><span class="line"><span class="addition">+   if (user == null)&#123;</span></span><br><span class="line"><span class="addition">+       //用户未登录，无需判断是否点赞</span></span><br><span class="line"><span class="addition">+       return;</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line"><span class="addition">+   Long userId = user.getId();</span></span><br><span class="line">    //判断当前用户是否已经点赞</span><br><span class="line">    String key = RedisConstants.BLOG_LIKED_KEY + blog.getId();</span><br><span class="line">    Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">    blog.setIsLike(score != null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时不登陆也能正常访问首页。</p>
<h4 id="点赞顺序问题"><a href="#点赞顺序问题" class="headerlink" title="点赞顺序问题"></a>点赞顺序问题</h4><p>此时，我们更换一个新的账号，对笔记进行点赞，会发现我们是后点赞的，但是却排到了第一个，这是有问题的</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723171747808.png" alt="image-20230723171747808"></p>
<p>并且，此时sql语句查询的顺序和redis中存储的用户顺序也都是正确的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,phone,password,nick_name,icon,create_time,update_time <span class="keyword">FROM</span> tb_user <span class="keyword">WHERE</span> id <span class="keyword">IN</span> ( ? , ? )</span><br><span class="line"><span class="number">1014</span>(Long), <span class="number">1</span>(Long)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723172042938.png" alt="image-20230723172042938"></p>
<p>那是因为什么呢？这是因为sql语句查询使用的<code>IN</code>关键字，我们来演示一下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,phone,password,nick_name,icon,create_time,update_time </span><br><span class="line"><span class="keyword">FROM</span> tb_user </span><br><span class="line"><span class="keyword">WHERE</span> id </span><br><span class="line"><span class="keyword">IN</span> ( <span class="number">1014</span> , <span class="number">1</span> )</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723172424673.png" alt="image-20230723172424673"></p>
<blockquote>
<p>可以看出，我们在in中首先是1014，然后才是1，但查到的数据却是反的。</p>
</blockquote>
<p>那如何解决呢？这里可以通过添加<code>ORDER BY FIELD(id, 1, 1014)</code>人为指定顺序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,phone,password,nick_name,icon,create_time,update_time </span><br><span class="line"><span class="keyword">FROM</span> tb_user </span><br><span class="line"><span class="keyword">WHERE</span> id </span><br><span class="line"><span class="keyword">IN</span> ( <span class="number">1014</span> , <span class="number">1</span> ) </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> FIELD(id,<span class="number">1014</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723172734257.png" alt="image-20230723172734257"></p>
<p><strong>对应代码修改：</strong></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Result queryBlogLikes(Long id) &#123;</span><br><span class="line">    // 获取top点赞用户  zrange key 0 4</span><br><span class="line">    String key = RedisConstants.BLOG_LIKED_KEY + id;</span><br><span class="line">    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, 0, 4);</span><br><span class="line">    if (top5 == null || top5.isEmpty())&#123;</span><br><span class="line">        return Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    // 解析其中的用户</span><br><span class="line">    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line"><span class="addition">+   String idStr = StrUtil.join(&quot;,&quot;, ids); //new</span></span><br><span class="line">    // 根据id查询用户 WHERE id  IN ( 1014 , 1 )  ORDER BY FIELD(id,1014,1)</span><br><span class="line">    List&lt;UserDTO&gt; userDTOS = userService</span><br><span class="line"><span class="deletion">-       .listByIds(ids)</span></span><br><span class="line"><span class="addition">+       .query().in(&quot;id&quot;, ids).last(&quot;ORDER BY FIELD(id,&quot;+idStr+&quot;)&quot;).list()</span></span><br><span class="line">        .stream()</span><br><span class="line">        .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    return Result.ok(userDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里不再使用<code>listByIds</code>根据ids直接返回userDTO的list了，而是使用自定义的sql语句：</p>
<ul>
<li>使用<code>in()</code>指定查询范围</li>
<li>使用<code>last()</code>即最后拼接指定的sql语句（因为默认没有order by field），然后通过动态拼接的方法传入点赞用户的ids，从而实现按照指定顺序输出。</li>
</ul>
<p>此时效果如下：可以看出点赞排行已经按照先后顺序显示了</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723173717907.png" alt="image-20230723173717907"></p>
<hr>
<h1 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h1><h2 id="关注和取关"><a href="#关注和取关" class="headerlink" title="关注和取关"></a>关注和取关</h2><p>进入到笔记详情页面时，会发送一个请求，判断当前登录用户是否关注了笔记博主</p>
<blockquote>
<p>Request URL: <a target="_blank" rel="noopener" href="http://localhost:8080/api/follow/or/not/2">http://localhost:8080/api/follow/or/not/2</a><br>Request Method: GET</p>
</blockquote>
<p>点击关注按钮时，会发送一个请求，实现关注&#x2F;取关</p>
<blockquote>
<p>Request URL: <a target="_blank" rel="noopener" href="http://localhost:8080/api/follow/2/true">http://localhost:8080/api/follow/2/true</a><br>Request Method: PUT</p>
</blockquote>
<p>关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来表示：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723222504675.png" alt="image-20230723222504675"></p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><ol>
<li><p>controller中实现以上两个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/follow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FollowController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IFollowService followService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(<span class="meta">@PathVariable</span> Long id, <span class="meta">@PathVariable</span> Boolean isFollow)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> followService.follow(id, isFollow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">checkFollw</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> followService.checkFollow(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>serviceImpl中实现对应逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FollowServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;FollowMapper, Follow&gt; <span class="keyword">implements</span> <span class="title class_">IFollowService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关注取关功能</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isFollow</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long id, Boolean isFollow)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//判断关注还是取关</span></span><br><span class="line">        <span class="keyword">if</span> (isFollow)&#123;</span><br><span class="line">            <span class="comment">//新增数据</span></span><br><span class="line">            <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">            follow.setUserId(userId);</span><br><span class="line">            follow.setFollowUserId(id);</span><br><span class="line">            save(follow);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//删除数据 delete from tb_follow where userId = ? and followUserId = ?</span></span><br><span class="line">            remove(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">                    .eq(Follow::getUserId, userId)</span><br><span class="line">                    .eq(Follow::getFollowUserId, id));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进入笔记详情页后判断是否关注</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">checkFollow</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> getOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">                .eq(Follow::getUserId, userId)</span><br><span class="line">                .eq(Follow::getFollowUserId, id));</span><br><span class="line">        <span class="keyword">return</span> Result.ok(follow!=<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h2><p>在本项目中，点击用户头像，进入到用户详情页，可以查看用户发布的笔记，和共同关注列表。但是目前项目还没有实现这些功能，此时点击进去都是空的。</p>
<h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>查询用户信息</p>
<blockquote>
<p>请求网址: <a target="_blank" rel="noopener" href="http://localhost:8080/api/user/2">http://localhost:8080/api/user/2</a><br>请求方法: GET</p>
</blockquote>
<p>此时controller中没有这个方法，所以进行实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(id);</span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时就能看到用户头像和用户name</p>
<h3 id="用户笔记"><a href="#用户笔记" class="headerlink" title="用户笔记"></a>用户笔记</h3><p>在上面的基础上，访问用户主页后还会触发一下请求获取笔记内容</p>
<blockquote>
<p>请求网址: <a target="_blank" rel="noopener" href="http://localhost:8080/api/blog/of/user?&id=2&current=1">http://localhost:8080/api/blog/of/user?&amp;id=2&amp;current=1</a><br>请求方法: GET</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryUserBlog</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Long id, </span></span><br><span class="line"><span class="params">                            <span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span>Integer current)</span>&#123;</span><br><span class="line">    Page&lt;Blog&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    LambdaQueryWrapper&lt;Blog&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    lqw.eq(Blog::getUserId, id);</span><br><span class="line"></span><br><span class="line">    blogService.page(pageInfo, lqw);</span><br><span class="line">    List&lt;Blog&gt; records = pageInfo.getRecords();</span><br><span class="line">    <span class="keyword">return</span> Result.ok(records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时页面显示效果</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723230219249.png" alt="image-20230723230219249"></p>
<h3 id="共同关注-1"><a href="#共同关注-1" class="headerlink" title="共同关注"></a>共同关注</h3><p>此时点击共同关注，发送如下请求：</p>
<blockquote>
<p>请求网址: <a target="_blank" rel="noopener" href="http://localhost:8080/api/follow/common/2">http://localhost:8080/api/follow/common/2</a><br>请求方法: GET</p>
</blockquote>
<p>需求：利用Redis中恰当的数据结构，实现共同关注功能，在博主个人页面展示出当前用户与博主的共同关注</p>
<p>思路：在set集合中，有交集并集补集的api，可以把二者关注的人放入到set集合中，然后通过<code>SINTER</code>命令查询两个set集合的交集</p>
<h4 id="修改关注逻辑"><a href="#修改关注逻辑" class="headerlink" title="修改关注逻辑"></a>修改关注逻辑</h4><p>修改之前的<strong>关注逻辑</strong>，在关注博主的同时，需要<strong>将数据放到set集合中</strong>，方便后期实现共同关注，当取消关注时，也需要将数据从set集合中删除</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Result follow(Long id, Boolean isFollow) &#123;</span><br><span class="line">    Long userId = UserHolder.getUser().getId();</span><br><span class="line"><span class="addition">+   String key = RedisConstants.FOLLOW_KEY + userId;</span></span><br><span class="line">    //判断关注还是取关</span><br><span class="line">    if (isFollow)&#123;</span><br><span class="line">        //新增数据</span><br><span class="line">        Follow follow = new Follow();</span><br><span class="line">        follow.setUserId(userId);</span><br><span class="line">        follow.setFollowUserId(id);</span><br><span class="line">        boolean isSuccess = save(follow);</span><br><span class="line"><span class="addition">+       if (isSuccess)&#123;</span></span><br><span class="line"><span class="addition">+           //把关注用户的id放入redis的set集合 sadd userId followUserId</span></span><br><span class="line"><span class="addition">+           stringRedisTemplate.opsForSet().add(key, id.toString());</span></span><br><span class="line"><span class="addition">+       &#125;</span></span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        //删除数据 delete from tb_follow where userId = ? and followUserId = ?</span><br><span class="line">        boolean isSuccess = remove(new LambdaQueryWrapper&lt;Follow&gt;()</span><br><span class="line">                                   .eq(Follow::getUserId, userId)</span><br><span class="line">                                   .eq(Follow::getFollowUserId, id));</span><br><span class="line"><span class="addition">+       if (isSuccess)&#123;</span></span><br><span class="line"><span class="addition">+           //移除关注的用户id</span></span><br><span class="line"><span class="addition">+           stringRedisTemplate.opsForSet().remove(key, id.toString());</span></span><br><span class="line"><span class="addition">+       &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时关注两个用户，可以看到redis中缓存了数据</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723231911746.png" alt="image-20230723231911746"></p>
<h4 id="功能实现-1"><a href="#功能实现-1" class="headerlink" title="功能实现"></a>功能实现</h4><ol>
<li><p>controller请求方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/common/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> followService.followCommons(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>serviceImpl功能实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key_prefix</span> <span class="operator">=</span> RedisConstants.FOLLOW_KEY;</span><br><span class="line">    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key_prefix + userId, key_prefix + id);</span><br><span class="line">    <span class="keyword">if</span> (intersect == <span class="literal">null</span> | intersect.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析出用户id</span></span><br><span class="line">    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//查询用户(转换为UserDTO隐藏隐私信息)</span></span><br><span class="line">    List&lt;UserDTO&gt; userDTOS = userService.listByIds(ids)</span><br><span class="line">        .stream()</span><br><span class="line">        .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>此时查看一个和我有共同关注的用户，可以看到：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723233430217.png" alt="image-20230723233430217"></p>
<h2 id="关注推送"><a href="#关注推送" class="headerlink" title="关注推送"></a>关注推送</h2><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>关注推送也叫作Feed流，直译为<strong>投喂</strong>，为用户提供沉浸式体验，通过无限下拉刷新获取新的信息。</p>
<p>传统模式内容检索：用户需要主动通过搜索引擎或者是其他方式去查找想看的内容<br>新型Feed流：系统分析用户到底想看什么，然后直接把内容推送给用户，从而使用户能更加节约时间，不用去主动搜素</p>
<p><strong>Feed流实现的两种模式</strong></p>
<ul>
<li><p><strong>Timeline</strong>：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注(朋友圈等)</p>
<ul>
<li><p>优点：信息全面，不会有缺失，并且实现也相对简单</p>
</li>
<li><p>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</p>
</li>
</ul>
</li>
<li><p><strong>智能排序</strong>：利用智能算法屏蔽掉违规的、用户不感兴趣的内容，推送用户感兴趣的信息来吸引用户</p>
<ul>
<li><p>优点：投喂用户感兴趣的信息，用户粘度很高，容易沉迷</p>
</li>
<li><p>缺点：如果算法不精准，可能会起到反作用</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>本项目针对好友的操作，采用的是<strong>Timeline</strong>方式，只需要拿到关注用户的信息，然后按照时间排序即可</p>
</blockquote>
<p>采用Timeline模式，有三种具体的实现方案</p>
<ol>
<li><p><strong>拉模式</strong>（也叫读扩散）</p>
<ul>
<li><p>含义：当张三和李四、王五发了消息之后，都会保存到自己的发件箱中，如果赵六要读取消息，那么他会读取他自己的收件箱，此时系统会从他关注的人群中，将他关注人的信息全都进行拉取，然后进行排序</p>
</li>
<li><p>优点：比较节约空间，因为赵六在读取信息时，并没有重复读取，并且读取完之后，可以将他的收件箱清除</p>
</li>
<li><p>缺点：有延迟，当用户读取数据时，才会去关注的人的时发件箱中拉取信息，假设该用户关注了海量用户，那么此时就会拉取很多信息，对服务器压力巨大</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723234514180.png" alt="image-20230723234514180"></p>
</li>
</ul>
</li>
<li><p><strong>推模式</strong>（也叫写扩散）</p>
<ul>
<li><p>含义：推模式是没有发件箱的，当用户写了一个内容，会主动把用户写的内容发送到它粉丝的收件箱中，假设此时粉丝再来读取，就不用再去临时拉取了</p>
</li>
<li><p>优点：时效快，不用临时拉取</p>
</li>
<li><p>缺点：内存压力大，假设一个大V发了一个动态，很多人关注他，那么就会写很多份数据到粉丝那边去</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723234800350.png" alt="image-20230723234800350"></p>
</li>
</ul>
</li>
<li><p><strong>推拉结合</strong>（也叫读写混合，兼具推和拉的优点，是一个折中的方案）</p>
<ul>
<li><p>站在发件人这边来看：</p>
<ul>
<li>如果是普通人，那么采用推模式，直接把数据写入到他的粉丝收件箱中，因为普通人的粉丝数量较少，所以这样不会产生太大压力。</li>
<li>但如果是大V，那么他是直接将数据写入一份到发件箱中去（拉模式），再直接写一份到活跃粉丝的收件箱中（推模式）</li>
</ul>
</li>
<li><p>站在收件人这边来看：</p>
<ul>
<li>如果是活跃粉丝，那么大V和普通人发的都会写到自己的收件箱里</li>
<li>如果是普通粉丝，由于上线不是很频繁，所以等他们上线的时候，再从发件箱中去拉取信息。</li>
</ul>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723235218907.png" alt="image-20230723235218907"></p>
</li>
</ul>
</li>
</ol>
<h3 id="推送功能"><a href="#推送功能" class="headerlink" title="推送功能"></a>推送功能</h3><blockquote>
<p>鉴于点评软件几乎没有大V，所以直接使用<strong>推模式</strong>实现推送功能</p>
</blockquote>
<h4 id="Feed流的分页问题"><a href="#Feed流的分页问题" class="headerlink" title="Feed流的分页问题"></a>Feed流的分页问题</h4><p>Feed流中的数据会不断更新，所以数据的角标也会不断变化，所以我们不能使用传统的分页模式</p>
<p><strong>传统分页</strong></p>
<p>假设在t1时刻，取读取第一页，此时page &#x3D; 1，size &#x3D; 5，那么拿到的就是<code>10~6</code>这几条记录，假设t2时刻有发布了一条新数据，那么在t3时刻来读取第二页，此时page &#x3D; 2，size &#x3D; 5，那么此时读取的数据是从6开始的，读到的是<code>6~2</code>，那么就读到了重复的数据，所以要使用Feed流的分页，不能使用传统的分页</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230723235959528.png" alt="image-20230723235959528"></p>
<p><strong>Feed流的滚动分页</strong></p>
<p>记录<strong>每次操作的最后一条</strong>，然后从这个位置去开始读数据</p>
<p>从t1时刻开始，拿到第一页数据，拿到了<code>10~6</code>，然后记录下当前最后一次读取的记录，就是6，t2时刻发布了新数据，此时这个11在最上面，但不会影响之前拿到的6，此时t3时刻来读取第二页，第二页读数据的时候，从<code>6-1=5</code>开始读，这样就拿到了<code>5~1</code>的记录。在这个地方可以<strong>使用SortedSet来做</strong>，使用时间戳来充当表中的<code>1~10</code></p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230724000259280.png" alt="image-20230724000259280"></p>
<h4 id="推送到收件箱"><a href="#推送到收件箱" class="headerlink" title="推送到收件箱"></a>推送到收件箱</h4><p>需求：</p>
<ol>
<li><strong>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</strong></li>
<li><strong>收件箱满足可以根据时间戳排序，必须使用Redis的数据结构实现</strong></li>
<li>查询收件箱数据时，可以实现分页查询</li>
</ol>
<p>实现：</p>
<p><code>BlogServiceImpl.saveBlog</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    <span class="comment">// 保存探店博文</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSave</span> <span class="operator">=</span> save(blog);</span><br><span class="line">    <span class="keyword">if</span> (!isSave)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;保存笔记失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询笔记作者的所有粉丝</span></span><br><span class="line">    List&lt;Follow&gt; follows = followService.query()</span><br><span class="line">        .eq(<span class="string">&quot;follow_user_id&quot;</span>, user.getId())</span><br><span class="line">        .list();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推送笔记id给所有粉丝</span></span><br><span class="line">    <span class="keyword">for</span> (Follow follow : follows) &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.FEED_KEY + userId;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：用户发一篇笔记后，其粉丝的收件箱（redis数据）中记录了其笔记的id和发送的时间戳</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230724142431224.png" alt="image-20230724142431224"></p>
<h4 id="滚动分页查询仿真"><a href="#滚动分页查询仿真" class="headerlink" title="滚动分页查询仿真"></a>滚动分页查询仿真</h4><p><strong>Redis中实现：</strong></p>
<ul>
<li>命令：<code>ZREVRANGEBYSCORE key max min WITHSCORE LIMITE offset count</code><ul>
<li><code>ZREVRANGEBYSCORE </code>指的是按照score降序排列</li>
<li><code>max</code>、<code>min</code>指的是查询的score范围，这里是时间戳</li>
<li><code>WITHSCORE </code>指的是结果带上socre</li>
<li><code>LIMITE offset count</code>有点类似分页查询，但是这里的offset指的是max值的偏移量。<ul>
<li>若第一次查询，max默认当前时间戳，则offset为0即可，再一次查询时，max是上一次查询的最后一条数据的score，所以此时需要offset向后偏移一位，也就是从比最后一条数据score小的数据开始查询（这时正常情况下，下面介绍了特殊情况）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>具体步骤：</strong></p>
<ul>
<li>每次查询之后，需要获取上次查询出的最小时间戳，这个值作为下一次的查询条件</li>
<li>需要找到<strong>与上一次查询最小score相同的查询个数</strong>，并作为<strong>偏移量</strong>，下次查询的时候，才能跳过这些查询过的数据，拿到需要的数据<ul>
<li>例如时间戳为8 6 6 5 4 3，每次查询3个，第一次是8 6 6，此时最小时间戳是6，如果不设置偏移量，会从第一个6之后开始查询，那么查询到的就是6 5 5，而不是5 4 3，所以需要设置offset为2，则从第一个6向后偏移两个。</li>
</ul>
</li>
</ul>
<p><strong>滚动分页查询参数：</strong></p>
<ul>
<li><strong>max</strong>：当前时间戳（第一次） <strong>|</strong> 上一次查询的最小时间戳（后续）</li>
<li><strong>min</strong>：0</li>
<li><strong>offset</strong>：0 （第一次）**|** 在上一次的结果中，与最小值一样的元素的个数（后续）</li>
<li><strong>count</strong>：每页笔记条数（固定的）</li>
</ul>
<h4 id="分页查询收件箱"><a href="#分页查询收件箱" class="headerlink" title="分页查询收件箱"></a>分页查询收件箱</h4><p><strong>需求：</strong></p>
<ol>
<li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li>
<li>收件箱满足可以根据时间戳排序，必须使用Redis的数据结构实现</li>
<li><strong>查询收件箱数据时，可以实现分页查询</strong></li>
</ol>
<p><strong>分析：</strong></p>
<p>到自己主页下，点击关注，这里会发送如下请求：</p>
<blockquote>
<p>请求网址: <a target="_blank" rel="noopener" href="http://localhost:8080/api/blog/of/follow?&lastId=1690179906849">http://localhost:8080/api/blog/of/follow?&amp;lastId=1690179906849</a><br>请求方法: GET</p>
</blockquote>
<p>并且可以发现这个ladtId就是当前的时间戳，是第一次查询的max值；这里缺少参数offset，这是因为是第一次查询，默认为0</p>
<p>方法的返回值需要包括分页查询数据、上一次查询中的最小时间戳、offset偏移量</p>
<p><strong>实现：</strong></p>
<ol>
<li><p>编写一个通用的实体类，用泛型做一个通用的分页查询，list是封装返回的结果，minTime是记录的最小时间戳，offset是记录偏移量</p>
<p><code>dto.ScrollResult</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScrollResult</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;?&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Long minTime;</span><br><span class="line">    <span class="keyword">private</span> Integer offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>controller方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/follow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(<span class="meta">@RequestParam(&quot;lastId&quot;)</span> Long max,<span class="meta">@RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;)</span>Integer offset)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogOfFollow(max, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>serviceImpl实现具体逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//2. 查询该用户收件箱（之前存的key固定前缀 + 粉丝id），所以根据当前用户id就可以查询是否有关注的人发了笔记</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.FEED_KEY + userId;</span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">        .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (typedTuples == <span class="literal">null</span> || typedTuples.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.解析数据：blogId、minTime（时间戳）、offset、</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">off</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123;</span><br><span class="line">        <span class="comment">//3.1 获取id</span></span><br><span class="line">        ids.add(Long.valueOf(tuple.getValue()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.2 获取score（时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> tuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span> (time == minTime) &#123;</span><br><span class="line">            off++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            off = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.根据id查询blog (SQL的in不能排序问题，手动指定排序为传入的ids)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idsStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>,ids);</span><br><span class="line">    List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, idsStr).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idsStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">        <span class="comment">//4.1 查询发布该blog的用户信息</span></span><br><span class="line">        queryBlogUser(blog);</span><br><span class="line">        <span class="comment">//4.2 查询当前用户是否给该blog点过赞</span></span><br><span class="line">        isBlogLiked(blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.封装返回</span></span><br><span class="line">    <span class="type">ScrollResult</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">    r.setList(blogs);</span><br><span class="line">    r.setOffset(off);</span><br><span class="line">    r.setMinTime(minTime);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>显示效果：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230724152624535.png" alt="image-20230724152624535"></p>
<hr>
<h1 id="附近商铺"><a href="#附近商铺" class="headerlink" title="附近商铺"></a>附近商铺</h1><h2 id="GEO数据结构"><a href="#GEO数据结构" class="headerlink" title="GEO数据结构"></a>GEO数据结构</h2><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据，常见的命令有：</p>
<p><strong>GEOADD</strong>：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）<br><strong>GEODIST</strong>：计算指定的两个点之间的距离并返回<br><strong>GEOHASH</strong>：将指定member的坐标转化为hash字符串形式并返回<br><strong>GEOPOS</strong>：返回指定member的坐标<br><strong>GEOGADIUS</strong>：指定圆心、半径，找到该园内包含的所有member，并按照与圆心之间的距离排序后返回。6.2以后已经弃用<br><strong>GEOSEARCH</strong>：在指定范围内搜索member，并按照与制定点之间的距离排序后返回，范围可以使圆形或矩形。6.2新功能<br><strong>GEOSEARCHSTORE</strong>：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。6.2新功能</p>
<h3 id="GEOADD"><a href="#GEOADD" class="headerlink" title="GEOADD"></a>GEOADD</h3><p>添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</p>
<ul>
<li><p>命令格式：<code>GEOADD key longitude latitude member [longitude latitude member …]</code></p>
</li>
<li><p>举例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOADD china 13.361389 38.115556 <span class="string">&quot;shanghai&quot;</span> 15.087269 37.502669 <span class="string">&quot;beijing&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="GEODIST"><a href="#GEODIST" class="headerlink" title="GEODIST"></a>GEODIST</h3><p>计算指定的两个点之间的距离并返回</p>
<ul>
<li>命令格式：<code>GEODIST key member1 member2 [m|km|ft|mi]</code></li>
<li>如果两个位置之间的其中⼀个不存在， 那么命令返回空值。</li>
<li>指定单位的参数 unit 必须是以下单位的其中⼀个：（ 默认使用米作为单位）<ul>
<li>m 表示单位为米。</li>
<li>km 表示单位为千米。</li>
<li>mi 表示单位为英⾥。</li>
<li>ft 表示单位为英尺。</li>
</ul>
</li>
</ul>
<h3 id="GEODIST-1"><a href="#GEODIST-1" class="headerlink" title="GEODIST"></a>GEODIST</h3><p>命令在计算距离时会假设地球为完美的球形， 在极限情况下， 这⼀假设最⼤会造成 0.5% 的误差</p>
<ul>
<li><p>举例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEODIST china beijing shanghai km</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="GEOHASH"><a href="#GEOHASH" class="headerlink" title="GEOHASH"></a>GEOHASH</h3><p>将指定member的坐标转化为hash字符串形式并返回</p>
<ul>
<li><p>命令格式：<code>GEOHASH key member [member …]</code></p>
</li>
<li><p>举例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;GEOHASH china beijing shanghai</span><br><span class="line">1) <span class="string">&quot;sqdtr74hyu0&quot;</span></span><br><span class="line">2) <span class="string">&quot;sqc8b49rny0&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="GEOPOS"><a href="#GEOPOS" class="headerlink" title="GEOPOS"></a>GEOPOS</h3><p>返回指定member的坐标</p>
<ul>
<li><p>格式：<code>GEOPOS key member [member …]</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;geopos china beijing shanghai</span><br><span class="line">1)  1) <span class="string">&quot;15.08726745843887329&quot;</span></span><br><span class="line">    2) <span class="string">&quot;37.50266842333162032&quot;</span></span><br><span class="line"></span><br><span class="line">2)  1) <span class="string">&quot;13.36138933897018433&quot;</span></span><br><span class="line">    2) <span class="string">&quot;38.11555639549629859&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="GEOGADIUS"><a href="#GEOGADIUS" class="headerlink" title="GEOGADIUS"></a>GEOGADIUS</h3><p>指定圆心、半径，找到该园内包含的所有member，并按照与圆心之间的距离排序后返回，<code>6.2之后已废弃</code></p>
<ul>
<li><p>命令格式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] </span><br><span class="line">[COUNT count [ANY]] [ASC|DESC] [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></figure>
</li>
<li><p>范围可以使用以下其中一个单位：</p>
<ul>
<li>m 表示单位为米。</li>
<li>km 表示单位为千米。</li>
<li>mi 表示单位为英里。</li>
<li>ft 表示单位为英尺。</li>
</ul>
</li>
<li><p>在给定以下可选项时， 命令会返回额外的信息：</p>
<ul>
<li>WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</li>
<li>WITHCOORD: 将位置元素的经度和维度也一并返回。</li>
<li>WITHHASH: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</li>
</ul>
</li>
<li><p>命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式：</p>
<ul>
<li>ASC: 根据中心的位置， 按照从近到远的方式返回位置元素。</li>
<li>DESC: 根据中心的位置， 按照从远到近的方式返回位置元素。</li>
</ul>
</li>
<li><p>举例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;GEORADIUS china 15 37 200 km WITHDIST WITHCOORD</span><br><span class="line">1)  1) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">    2) <span class="string">&quot;190.4424&quot;</span></span><br><span class="line">    3)  1) <span class="string">&quot;13.36138933897018433&quot;</span></span><br><span class="line">        2) <span class="string">&quot;38.11555639549629859&quot;</span></span><br><span class="line"></span><br><span class="line">2)  1) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">    2) <span class="string">&quot;56.4413&quot;</span></span><br><span class="line">    3)  1) <span class="string">&quot;15.08726745843887329&quot;</span></span><br><span class="line">        2) <span class="string">&quot;37.50266842333162032&quot;</span></span><br><span class="line">&gt;GEORADIUS china 15 37 200 km WITHDIST</span><br><span class="line">1)  1) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">    2) <span class="string">&quot;190.4424&quot;</span></span><br><span class="line"></span><br><span class="line">2)  1) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">    2) <span class="string">&quot;56.4413&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="GEOSEARCH"><a href="#GEOSEARCH" class="headerlink" title="GEOSEARCH"></a>GEOSEARCH</h3><p>在指定范围内搜索member，并按照与制定点之间的距离排序后返回，范围可以使圆形或矩形，6.2的新功能</p>
<ul>
<li><p>命令格式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GEOSEARCH key [FROMMEMBER member] [FROMLONLAT longitude latitude] [BYRADIUS radius m|km|ft|mi] </span><br><span class="line">[BYBOX width height m|km|ft|mi] [ASC|DESC] [COUNT count [ANY]] [WITHCOORD] [WITHDIST] [WITHHASH]</span><br></pre></td></tr></table></figure>
</li>
<li><p>举例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;geosearch china FROMLONLAT 15 37 BYRADIUS 200 km ASC WITHCOORD WITHDIST</span><br><span class="line">1)  1) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">    2) <span class="string">&quot;56.4413&quot;</span></span><br><span class="line">    3)  1) <span class="string">&quot;15.08726745843887329&quot;</span></span><br><span class="line">        2) <span class="string">&quot;37.50266842333162032&quot;</span></span><br><span class="line"></span><br><span class="line">2)  1) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">    2) <span class="string">&quot;190.4424&quot;</span></span><br><span class="line">    3)  1) <span class="string">&quot;13.36138933897018433&quot;</span></span><br><span class="line">        2) <span class="string">&quot;38.11555639549629859&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;geosearch china FROMLONLAT 15 37 BYBOX 400 400 km DESC WITHCOORD WITHDIST</span><br><span class="line">1)  1) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">    2) <span class="string">&quot;190.4424&quot;</span></span><br><span class="line">    3)  1) <span class="string">&quot;13.36138933897018433&quot;</span></span><br><span class="line">        2) <span class="string">&quot;38.11555639549629859&quot;</span></span><br><span class="line"></span><br><span class="line">2)  1) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">    2) <span class="string">&quot;56.4413&quot;</span></span><br><span class="line">    3)  S1) <span class="string">&quot;15.08726745843887329&quot;</span></span><br><span class="line">        2) <span class="string">&quot;37.50266842333162032&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="GEOSEARCHSTORE"><a href="#GEOSEARCHSTORE" class="headerlink" title="GEOSEARCHSTORE"></a>GEOSEARCHSTORE</h3><p>与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key，也是6.2的新功能</p>
<ul>
<li><p>命令格式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GEOSEARCHSTORE destination <span class="built_in">source</span> [FROMMEMBER member] [FROMLONLAT longitude latitude] </span><br><span class="line">[BYRADIUS radius m|km|ft|mi] [BYBOX width height m|km|ft|mi] </span><br><span class="line">[ASC|DESC] [COUNT count [ANY]] [STOREDIST]</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个命令和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 GEORADIUSBYMEMBER 的中心点是由给定的位置元素决定的， 而不是像 GEORADIUS 那样， 使用输入的经度和纬度来决定中心点指定成员的位置被用作查询的中心。</p>
</li>
<li><p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;GEORADIUSBYMEMBER china beijing 200 km</span><br><span class="line">1) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">2) <span class="string">&quot;beijing&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="附近商户搜索"><a href="#附近商户搜索" class="headerlink" title="附近商户搜索"></a>附近商户搜索</h2><h3 id="导入店铺数据到GEO"><a href="#导入店铺数据到GEO" class="headerlink" title="导入店铺数据到GEO"></a>导入店铺数据到GEO</h3><p><strong>思路：</strong></p>
<ul>
<li>将数据库中的数据导入到Redis中去，GEO在Redis中就是一个member和一个经纬度，经纬度对应的就是tb_shop中的x和y，而<strong>member用shop_id来存</strong>，因为Redis只是一个内存级数据库，如果存海量的数据占用资源过多，所以只存一个id，用的时候再拿id去SQL数据库中查询shop信息</li>
<li>此时还有一个问题，在<strong>redis中没有存储shop_type</strong>，无法根据店铺类型来对数据进行筛选，解决办法就是<strong>将type_id作为key，存入同一个GEO集合</strong>即可</li>
</ul>
<p><strong>示例：</strong></p>
<table>
<thead>
<tr>
<th align="left">Key</th>
<th>Value</th>
<th>Score</th>
</tr>
</thead>
<tbody><tr>
<td align="left">shop:geo:美食</td>
<td>海底捞</td>
<td>40691512240174598</td>
</tr>
<tr>
<td align="left"></td>
<td>吉野家</td>
<td>40691519846517915</td>
</tr>
<tr>
<td align="left">shop:geo:KTV</td>
<td>KTV 01</td>
<td>40691165486458787</td>
</tr>
<tr>
<td align="left"></td>
<td>KTV 02</td>
<td>40691514154651657</td>
</tr>
</tbody></table>
<p>数据库中的对应数据如下：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230724162937675.png" alt="image-20230724162937675"></p>
<p><strong>实现上述功能：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 查询所有店铺信息</span></span><br><span class="line">    List&lt;Shop&gt; shopList = shopService.list();</span><br><span class="line">    <span class="comment">//2. 将店铺进行分组,按照typeId</span></span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = shopList.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    <span class="comment">//3. 分批写入Redis</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 获取类型id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="comment">// 获取同类型店铺的集合</span></span><br><span class="line">        List&lt;Shop&gt; shops = entry.getValue();</span><br><span class="line">        <span class="comment">// 写入redis GEO数据  GEOADD key 经度 纬度 member</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">            <span class="comment">//3.3 写入redis GEOADD key 经度 纬度 member</span></span><br><span class="line">            stringRedisTemplate.opsForGeo().add(key,<span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(),shop.getY()),shop.getId().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码是是一条一条写入redis的，效率较低。这里进行改进，根据key一次写入对应的数据</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void loadShopData() &#123;</span><br><span class="line">    //1. 查询所有店铺信息</span><br><span class="line">    List&lt;Shop&gt; shopList = shopService.list();</span><br><span class="line">    //2. 将店铺进行分组,按照typeId</span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = shopList.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    //3. 分批写入Redis</span><br><span class="line">    for (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        // 获取类型id</span><br><span class="line">        Long typeId = entry.getKey();</span><br><span class="line">        // 获取同类型店铺的集合</span><br><span class="line">        List&lt;Shop&gt; shops = entry.getValue();</span><br><span class="line">        // 写入redis GEO数据  GEOADD key 经度 纬度 member</span><br><span class="line">        String key = SHOP_GEO_KEY + typeId;</span><br><span class="line"><span class="addition">+       List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = new ArrayList&lt;&gt;(shops.size());</span></span><br><span class="line">        for (Shop shop : shops) &#123;</span><br><span class="line"><span class="deletion">-       	stringRedisTemplate.opsForGeo().add(key,new Point(shop.getX(),shop.getY()),shop.getId().toString());          </span></span><br><span class="line"><span class="addition">+           locations.add(new RedisGeoCommands.GeoLocation&lt;&gt;(shop.getId().toString(), new Point(shop.getX(), shop.getY())));//将当前type的商铺都添加到locations集合中</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="addition">+       //批量写入</span></span><br><span class="line"><span class="addition">+       stringRedisTemplate.opsForGeo().add(key, locations);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入redis中查看，可以看出保存成功</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230724164953957.png" alt="image-20230724164953957"></p>
<h3 id="功能实现-2"><a href="#功能实现-2" class="headerlink" title="功能实现"></a>功能实现</h3><p>进入到频道页后会发送如下请求：</p>
<blockquote>
<p>请求网址: <a target="_blank" rel="noopener" href="http://localhost:8080/api/shop/of/type?&typeId=1&current=1&x=120.149993&y=30.334229">http://localhost:8080/api/shop/of/type?&amp;typeId=1&amp;current=1&amp;x=120.149993&amp;y=30.334229</a><br>请求方法: GET</p>
</blockquote>
<p>其中typeId就是频道类型；current是当前页码；xy就是经纬度</p>
<p><strong>代码实现：</strong></p>
<ol>
<li><p>SpringDataRedis的2.3.9版本并不支持Redis 6.2提供的<code>GEOSEARCH</code>命令，因此我们需要提示其版本，修改自己的pom.xml文件</p>
<blockquote>
<p>这里主要是将spring-data-redis和lettuce-core从spring-boot-starter-data-redis中排除，然后导入新版本的依赖</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改ShopController中的方法，传入参数除了typeId，分页码，还需要其坐标</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> shopService.queryShopByType(typeId,current,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对应的逻辑实现</p>
<blockquote>
<p>这里传入的经纬度是前端写死的，实际业务是获取定位处的经纬度</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">    <span class="comment">//1.判断是否需要根据坐标查询</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//不需要坐标查询，直接数据库查询</span></span><br><span class="line">        Page&lt;Shop&gt; page = query().eq(<span class="string">&quot;type_id&quot;</span>, typeId)</span><br><span class="line">            .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">        <span class="keyword">return</span> Result.ok(page.getRecords());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.计算分页参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.MAX_PAGE_SIZE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.MAX_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.查询redis、按照距离排序、分页:shopId、distance</span></span><br><span class="line">    <span class="comment">//GEOSEARCH key FROMLONLAT x y BYRADIUS 5000 m WITHDIST</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.SHOP_GEO_KEY + typeId;</span><br><span class="line">    GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo().search(</span><br><span class="line">        key,</span><br><span class="line">        GeoReference.fromCoordinate(x, y), <span class="comment">//搜索的圆心</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>), <span class="comment">//搜索半径</span></span><br><span class="line">        RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end));</span><br><span class="line">    <span class="comment">//4.解析出id</span></span><br><span class="line">    <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">    <span class="comment">// 判断集合的长度是否小于等于下一页的from，如果符合则说明没有下一页的数据了</span></span><br><span class="line">    <span class="keyword">if</span> (list.size() &lt;= from) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.1 截取从from到end的内容</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());<span class="comment">//保存查询到的店铺id，后续根据id查询shop</span></span><br><span class="line">    Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());<span class="comment">//保存id和距离对</span></span><br><span class="line">    list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">        <span class="comment">//4.2 获取店铺id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">        ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">        <span class="comment">//4.3 获取距离</span></span><br><span class="line">        <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">        distanceMap.put(shopIdStr, distance);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//5.根据id查询shop</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idsStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD( id,&quot;</span> + idsStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">    <span class="comment">//遍历shop，将距离set到shop中</span></span><br><span class="line">    <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">        shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里用到了stream流的<code>skip()</code>，可以截取<strong>指定位置后</strong>的所有数据</p>
</blockquote>
</li>
</ol>
<p>这里我直接运行会报错，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error in execution; nested exception is io.lettuce.core.RedisCommandExecutionException: ERR unknown command &#x27;GEOSEARCH&#x27;</span><br></pre></td></tr></table></figure>

<p>经过查阅，出现问题的原因是<strong>服务端的redis版本过低</strong>。这里我的版本确实低，只有4.0（x_x），需要6.2以上版本，因为<code>GEOSEARCH</code>是6.2的新功能。所以这里从官网下载了6.2.5版本，参考以前的笔记Redis入门中进行相关设置。</p>
<p>此时查看商户列表，可以看到包含了距离，并且按照距离排序：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230725004545567.png" alt="image-20230725004545567"></p>
<blockquote>
<p>我在上面逻辑实现的L21中，开始将<code>includeDistance()</code>写成了<code>includeCoordination()</code>，导致得到的距离都是0，这里bug找了好久。</p>
<ul>
<li><code>includeDistance()</code>相当于GEOSEARCH中的[WITHCOORD]，返回的是经纬度坐标</li>
<li>而<code>includeCoordination()</code>则相当于 [WITHDIST]，返回的是距离信息</li>
</ul>
</blockquote>
<hr>
<h1 id="用户签到"><a href="#用户签到" class="headerlink" title="用户签到"></a>用户签到</h1><h2 id="BitMap用法"><a href="#BitMap用法" class="headerlink" title="BitMap用法"></a>BitMap用法</h2><p>假如我们使用一张表来存储用户签到的信息，其结构如下：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230725110408727.png" alt="image-20230725110408727"></p>
<p>假如有1000W用户，平均没人每年签到10次，那这张表一年的数据量就有1亿条。这样即消耗内存又影响效率。</p>
<p>有什么更好地方法？类似签到表，这里可以使用二进制位来记录每个月的签到情况，签到记录为1，未签到记录为0。把每一个bit位对应当月的每一天，形成映射关系，用0和1标识业务状态，这种思路就成为<strong>位图（BitMap）</strong>。这样我们就能用极小的空间，来实现大量数据的表示。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230725110742678.png" alt="image-20230725110742678"></p>
<p>Redis中是<strong>利用String类型数据结构实现BitMap</strong>，因此最大上限是512M，转换为bit则是2^32个bit位</p>
<p><strong>BitMap的操作命令</strong>：</p>
<ul>
<li><strong>SETBIT</strong>：向指定位置（offset）存入一个0或1</li>
<li><strong>GETBIT</strong>：获取指定位置（offset）的bit值</li>
<li><strong>BITCOUNT</strong>：统计BitMap中值为1的bit位的数量</li>
<li><strong>BITFIELD</strong>：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li>
<li><strong>BITFIELD_RO</strong>：获取BitMap中bit数组，并以十进制形式返回</li>
<li><strong>BITOP</strong>：将多个BitMap的结果做位运算（与、或、异或）</li>
<li><strong>BITPOS</strong>：查找bit数组中指定范围内第一个0或1出现的位置</li>
</ul>
<h2 id="签到功能"><a href="#签到功能" class="headerlink" title="签到功能"></a>签到功能</h2><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230725111330227.png" alt="image-20230725111330227"></p>
<p><strong>代码实现：</strong></p>
<p>把用户id、年和月作为BitMap的key，然后保存到一个BitMap中，每次签到获取今天是当前月的第几天，就把对应位上的0变成1，只要是1就说明这一天已经签到了，反之则没有签到</p>
<ol>
<li><p>控制器方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.sign();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>serviceImlp逻辑实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + date;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取今天是这个月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入redis setbit key offset 0|1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key,dayOfMonth-<span class="number">1</span>,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：getDayOfMonth()返回的是1-31，但是位图从0开始，所以需要dayOfMonth-1</p>
</blockquote>
</li>
</ol>
<p>因为这里前端没有实现功能额，所以使用PostMan发送请求测试，注意请求头中需携带登录用户的token</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230725112610287.png" alt="image-20230725112610287"></p>
<p>然后在Redis中可以看到对应生成的BitMap（今天是25号，所以第25位为1）</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230725112653055.png" alt="image-20230725112653055"></p>
<h2 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h2><p>Q1：什么叫连续签到天数？<strong>从最后一天签到到开始向前统计</strong>，直到遇到第一次未签到为止，统计总的签到次数，就是连续签到天数。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230725113053523.png" alt="image-20230725113053523"></p>
<p>Q2：如何获取本月到今天为止的所有签到数据？<code>BITFIELD key GET u[dayOfMonth] 0</code></p>
<p>Q3：如何从后往前遍历每个bit位，获取连续签到天数？与1做与运算，就能得到最后一个bit位；随后右移一位，下一个bit位就成最后一个bit位</p>
<p><strong>需求：</strong>实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p>
<p><img src="/image-20230725124843897.png" alt="image-20230725124843897"></p>
<p>代码实现：</p>
<ol>
<li><p>控制器方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sign/count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.signCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + date;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取今天是这个月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取本月截至今天为止所有的签到记录，返回的是一个十进制数字 BITFIELD key GET dayOfMonth 0</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">        key,</span><br><span class="line">        BitFieldSubCommands.create()</span><br><span class="line">        .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> | result.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span> || num == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环遍历，</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充：按位移位运算符：<code>&gt;&gt;</code>表示算术右移，<code>&gt;&gt;&gt;</code>表示逻辑右移。参考:<a target="_blank" rel="noopener" href="https://xulong.blog.csdn.net/article/details/111812309?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-111812309-blog-3936489.235%5Ev38%5Epc_relevant_anti_vip_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-111812309-blog-3936489.235%5Ev38%5Epc_relevant_anti_vip_base&utm_relevant_index=5">Java中＞＞和＞＞＞的区别</a></p>
<ul>
<li><code>&gt;&gt;</code> ，它在右移n位（扩展符号）后保留符号（正数或负数）。</li>
<li><code>&gt;&gt;&gt;</code> ，它会在右移n位（零扩展）后忽略符号，都在高位插入0。</li>
</ul>
</blockquote>
</li>
</ol>
<hr>
<h1 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h1><h2 id="HyperLogLog用法"><a href="#HyperLogLog用法" class="headerlink" title="HyperLogLog用法"></a>HyperLogLog用法</h2><p>首先搞懂两个概念：</p>
<ul>
<li><strong>UV</strong>：全称Unique Visitor，也叫<strong>独立访客量</strong>，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li>
<li><strong>PV</strong>：全称Page View，也叫<strong>页面访问量或点击量</strong>，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li>
</ul>
<p>UV统计在服务端做会很麻烦，因为要判断该用户是否已经统计过了，需要将统计过的信息保存，但是如果每个访问的用户都保存到Redis中，那么数据库会非常恐怖，那么该如何处理呢？</p>
<p>**HyperLogLog(HLL)**是从Loglog算法派生的概率算法，用户确定非常大的集合基数，而不需要存储其所有值，算法相关原理可以参考下面这篇文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a></p>
<p>Redis中的HLL是<strong>基于string结构实现</strong>的，单个HLL的<strong>内存永远小于16kb</strong>，内存占用低的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p>
<p><strong>常用方法</strong>：（就这三个）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PFADD key element [element...]</span><br><span class="line">summary: Adds the specified elements to the specified HyperLogLog</span><br><span class="line"></span><br><span class="line">PFCOUNT key [key ...]</span><br><span class="line">Return the approximated cardinality of the <span class="built_in">set</span>(s) observed by the HyperLogLog at key(s).</span><br><span class="line"></span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br><span class="line">lnternal commands <span class="keyword">for</span> debugging HyperLogLog values</span><br></pre></td></tr></table></figure>

<h2 id="实现UV统计"><a href="#实现UV统计" class="headerlink" title="实现UV统计"></a>实现UV统计</h2><p>使用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHyperLogLog</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//准备数组，</span></span><br><span class="line">    String[] users = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        j = i % <span class="number">1000</span>;</span><br><span class="line">        users[j] = <span class="string">&quot;user_&quot;</span> + i;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">999</span>) &#123;</span><br><span class="line">            stringRedisTemplate.opsForHyperLogLog().add(<span class="string">&quot;HLL&quot;</span>, users);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计数量</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForHyperLogLog().size(<span class="string">&quot;HLL&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的count为997593，误差率为0.002407%。在Redis中使用<code>info memory</code>命令查看占用情况为：12.3K字节（插入前和插入后相减）</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">wzy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/13/Redis%E5%AE%9E%E6%88%98/">http://example.com/2023/07/13/Redis%E5%AE%9E%E6%88%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Wzy's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="/img/cheems.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/25/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" title="Java8新特性"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java8新特性</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/11/Redis%E5%9F%BA%E7%A1%80/" title="Redis基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/04/Redis%E5%85%A5%E9%97%A8/" title="Redis入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-04</div><div class="title">Redis入门</div></div></a></div><div><a href="/2023/07/11/Redis%E5%9F%BA%E7%A1%80/" title="Redis基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-11</div><div class="title">Redis基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cheems.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wzy</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">内容概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%AD%E4%BF%A1%E7%99%BB%E9%99%86"><span class="toc-number">2.</span> <span class="toc-text">短信登陆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5"><span class="toc-number">2.1.</span> <span class="toc-text">项目导入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ESession%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95"><span class="toc-number">2.2.</span> <span class="toc-text">基于Session实现登录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">登录流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E9%AA%8C%E8%AF%81%E7%A0%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">发送验证码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95"><span class="toc-number">2.2.3.</span> <span class="toc-text">登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81"><span class="toc-number">2.2.4.</span> <span class="toc-text">校验登录状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%95%AA%E5%A4%96%EF%BC%9AThreadLocal"><span class="toc-number">2.2.5.</span> <span class="toc-text">番外：ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%95%AA%E5%A4%96%EF%BC%9A%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">2.2.6.</span> <span class="toc-text">番外：拦截器和过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8Filter"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">过滤器Filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">拦截器Interceptor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.6.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E7%94%A8%E6%88%B7%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF"><span class="toc-number">2.2.7.</span> <span class="toc-text">隐藏用户敏感信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%ABSession%E7%99%BB%E5%BD%95"><span class="toc-number">2.3.</span> <span class="toc-text">基于Redis实现共享Session登录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%9A%84Session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.1.</span> <span class="toc-text">集群的Session共享问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.3.2.</span> <span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95"><span class="toc-number">2.3.3.</span> <span class="toc-text">基于Redis实现验证码登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%8A%B6%E6%80%81%E7%99%BB%E5%BD%95%E5%88%B7%E6%96%B0%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.4.</span> <span class="toc-text">解决状态登录刷新问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E7%89%88%E6%9C%AC"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">初步版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%89%88%E6%9C%AC"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">优化版本</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%95%86%E6%88%B7%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">3.</span> <span class="toc-text">商户查询缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98"><span class="toc-number">3.1.</span> <span class="toc-text">什么是缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%95%86%E6%88%B7%E7%BC%93%E5%AD%98"><span class="toc-number">3.2.</span> <span class="toc-text">添加商户缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E6%9C%AC%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.1.</span> <span class="toc-text">原本查询方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">添加缓存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%95%86%E6%88%B7%E7%B1%BB%E5%9E%8B%E7%BC%93%E5%AD%98"><span class="toc-number">3.3.</span> <span class="toc-text">添加商户类型缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%95%AA%E5%A4%96%EF%BC%9AJSONUtil%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">3.3.2.</span> <span class="toc-text">番外：JSONUtil工具类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">3.4.</span> <span class="toc-text">缓存更新策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">3.4.1.</span> <span class="toc-text">常见更新策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">3.4.2.</span> <span class="toc-text">主动更新策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%95%86%E9%93%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4"><span class="toc-number">3.4.3.</span> <span class="toc-text">实现商铺缓存与数据库双写一致</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">3.5.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.5.1.</span> <span class="toc-text">问题描述和解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%95%86%E9%93%BA%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">3.5.2.</span> <span class="toc-text">解决商铺查询缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E5%8F%96%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.3.</span> <span class="toc-text">抽取为一个方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.5.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">3.6.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">3.7.</span> <span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.7.1.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.7.2.</span> <span class="toc-text">互斥锁使用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JMeter%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">JMeter并发测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.7.3.</span> <span class="toc-text">逻辑过期使用示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85"><span class="toc-number">3.8.</span> <span class="toc-text">缓存工具封装</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80"><span class="toc-number">4.</span> <span class="toc-text">优惠券秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID"><span class="toc-number">4.1.</span> <span class="toc-text">全局唯一ID</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E8%87%AA%E5%A2%9E"><span class="toc-number">4.1.1.</span> <span class="toc-text">Redis自增</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95"><span class="toc-number">4.2.</span> <span class="toc-text">实现优惠券秒杀下单</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%BC%98%E6%83%A0%E5%88%B8"><span class="toc-number">4.2.1.</span> <span class="toc-text">添加优惠券</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.2.</span> <span class="toc-text">秒杀实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.</span> <span class="toc-text">超卖问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E6%A8%A1%E6%8B%9F"><span class="toc-number">4.3.1.</span> <span class="toc-text">场景模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-%E6%82%B2%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">4.3.2.</span> <span class="toc-text">问题分析|悲、乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">4.3.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95"><span class="toc-number">4.4.</span> <span class="toc-text">一人一单</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.4.1.</span> <span class="toc-text">初步实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96-%E5%8A%A0%E9%94%81"><span class="toc-number">4.4.2.</span> <span class="toc-text">进一步优化(加锁)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E7%89%88%E6%9C%AC-%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.4.3.</span> <span class="toc-text">最终版本(事务)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.4.</span> <span class="toc-text">并发安全问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%8E%B7%E5%8F%96%E5%92%8C%E9%87%8A%E6%94%BE"><span class="toc-number">5.1.</span> <span class="toc-text">分布式锁获取和释放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">5.2.</span> <span class="toc-text">初步实现分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E8%B6%85%E6%97%B6%E9%87%8A%E6%94%BE%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.</span> <span class="toc-text">锁的超时释放问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">5.3.1.</span> <span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">5.3.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">5.4.</span> <span class="toc-text">分布式锁的原子性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E8%84%9A%E6%9C%AC%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">5.4.1.</span> <span class="toc-text">Lua脚本解决原子性问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%B0%83%E7%94%A8Lua%E8%84%9A%E6%9C%AC%E6%94%B9%E9%80%A0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">5.4.2.</span> <span class="toc-text">Java调用Lua脚本改造分布式锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redisson"><span class="toc-number">5.5.</span> <span class="toc-text">Redisson</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson%E5%85%A5%E9%97%A8"><span class="toc-number">5.5.1.</span> <span class="toc-text">Redisson入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson%E9%94%81%E9%87%8D%E5%85%A5"><span class="toc-number">5.5.2.</span> <span class="toc-text">Redisson锁重入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Lua%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.5.2.1.</span> <span class="toc-text">Lua脚本实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson%E9%94%81%E9%87%8D%E8%AF%95%E5%92%8CWatchDog%E6%9C%BA%E5%88%B6"><span class="toc-number">5.5.3.</span> <span class="toc-text">Redisson锁重试和WatchDog机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson%E9%94%81%E7%9A%84MutiLock%E5%8E%9F%E7%90%86"><span class="toc-number">5.5.4.</span> <span class="toc-text">Redisson锁的MutiLock原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95"><span class="toc-number">5.5.4.1.</span> <span class="toc-text">代码测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%80%BB%E7%BB%93"><span class="toc-number">5.5.5.</span> <span class="toc-text">Redisson分布式锁总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">秒杀优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80"><span class="toc-number">6.1.</span> <span class="toc-text">异步秒杀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E8%B5%84%E6%A0%BC%E5%88%A4%E6%96%AD"><span class="toc-number">6.2.</span> <span class="toc-text">秒杀资格判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.3.</span> <span class="toc-text">阻塞队列实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">6.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">7.1.</span> <span class="toc-text">什么是消息队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EList%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">7.2.</span> <span class="toc-text">基于List实现消息队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EPubSub%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">7.3.</span> <span class="toc-text">基于PubSub的消息队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">7.4.</span> <span class="toc-text">基于Stream的消息队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E2%80%94%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="toc-number">7.5.</span> <span class="toc-text">基于Stream的消息队列—消费者组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97"><span class="toc-number">8.</span> <span class="toc-text">达人探店</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E6%8E%A2%E5%BA%97%E7%AC%94%E8%AE%B0"><span class="toc-number">8.1.</span> <span class="toc-text">发布探店笔记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%8E%A2%E5%BA%97%E7%AC%94%E8%AE%B0"><span class="toc-number">8.2.</span> <span class="toc-text">查看探店笔记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E8%B5%9E%E5%8A%9F%E8%83%BD"><span class="toc-number">8.3.</span> <span class="toc-text">点赞功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%96%84"><span class="toc-number">8.3.1.</span> <span class="toc-text">功能完善</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E8%B5%9E%E6%8E%92%E8%A1%8C%E6%A6%9C"><span class="toc-number">8.4.</span> <span class="toc-text">点赞排行榜</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.4.1.</span> <span class="toc-text">功能实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3BUG"><span class="toc-number">8.4.2.</span> <span class="toc-text">解决BUG</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E7%99%BB%E9%99%86%E8%AE%BF%E9%97%AE%E9%A6%96%E9%A1%B5"><span class="toc-number">8.4.2.1.</span> <span class="toc-text">不登陆访问首页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E8%B5%9E%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="toc-number">8.4.2.2.</span> <span class="toc-text">点赞顺序问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8"><span class="toc-number">9.</span> <span class="toc-text">好友关注</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E6%B3%A8%E5%92%8C%E5%8F%96%E5%85%B3"><span class="toc-number">9.1.</span> <span class="toc-text">关注和取关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">9.1.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E5%85%B3%E6%B3%A8"><span class="toc-number">9.2.</span> <span class="toc-text">共同关注</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-number">9.2.1.</span> <span class="toc-text">用户信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AC%94%E8%AE%B0"><span class="toc-number">9.2.2.</span> <span class="toc-text">用户笔记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E5%85%B3%E6%B3%A8-1"><span class="toc-number">9.2.3.</span> <span class="toc-text">共同关注</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%85%B3%E6%B3%A8%E9%80%BB%E8%BE%91"><span class="toc-number">9.2.3.1.</span> <span class="toc-text">修改关注逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">9.2.3.2.</span> <span class="toc-text">功能实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E6%B3%A8%E6%8E%A8%E9%80%81"><span class="toc-number">9.3.</span> <span class="toc-text">关注推送</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.3.1.</span> <span class="toc-text">概念介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD"><span class="toc-number">9.3.2.</span> <span class="toc-text">推送功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Feed%E6%B5%81%E7%9A%84%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98"><span class="toc-number">9.3.2.1.</span> <span class="toc-text">Feed流的分页问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E9%80%81%E5%88%B0%E6%94%B6%E4%BB%B6%E7%AE%B1"><span class="toc-number">9.3.2.2.</span> <span class="toc-text">推送到收件箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E4%BB%BF%E7%9C%9F"><span class="toc-number">9.3.2.3.</span> <span class="toc-text">滚动分页查询仿真</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E6%94%B6%E4%BB%B6%E7%AE%B1"><span class="toc-number">9.3.2.4.</span> <span class="toc-text">分页查询收件箱</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E8%BF%91%E5%95%86%E9%93%BA"><span class="toc-number">10.</span> <span class="toc-text">附近商铺</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">10.1.</span> <span class="toc-text">GEO数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GEOADD"><span class="toc-number">10.1.1.</span> <span class="toc-text">GEOADD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GEODIST"><span class="toc-number">10.1.2.</span> <span class="toc-text">GEODIST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GEODIST-1"><span class="toc-number">10.1.3.</span> <span class="toc-text">GEODIST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GEOHASH"><span class="toc-number">10.1.4.</span> <span class="toc-text">GEOHASH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GEOPOS"><span class="toc-number">10.1.5.</span> <span class="toc-text">GEOPOS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GEOGADIUS"><span class="toc-number">10.1.6.</span> <span class="toc-text">GEOGADIUS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GEOSEARCH"><span class="toc-number">10.1.7.</span> <span class="toc-text">GEOSEARCH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GEOSEARCHSTORE"><span class="toc-number">10.1.8.</span> <span class="toc-text">GEOSEARCHSTORE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E8%BF%91%E5%95%86%E6%88%B7%E6%90%9C%E7%B4%A2"><span class="toc-number">10.2.</span> <span class="toc-text">附近商户搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%BA%97%E9%93%BA%E6%95%B0%E6%8D%AE%E5%88%B0GEO"><span class="toc-number">10.2.1.</span> <span class="toc-text">导入店铺数据到GEO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">10.2.2.</span> <span class="toc-text">功能实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AD%BE%E5%88%B0"><span class="toc-number">11.</span> <span class="toc-text">用户签到</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BitMap%E7%94%A8%E6%B3%95"><span class="toc-number">11.1.</span> <span class="toc-text">BitMap用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%BE%E5%88%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">11.2.</span> <span class="toc-text">签到功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%BE%E5%88%B0%E7%BB%9F%E8%AE%A1"><span class="toc-number">11.3.</span> <span class="toc-text">签到统计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UV%E7%BB%9F%E8%AE%A1"><span class="toc-number">12.</span> <span class="toc-text">UV统计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HyperLogLog%E7%94%A8%E6%B3%95"><span class="toc-number">12.1.</span> <span class="toc-text">HyperLogLog用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0UV%E7%BB%9F%E8%AE%A1"><span class="toc-number">12.2.</span> <span class="toc-text">实现UV统计</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/02/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98Caffeine/" title="本地缓存Caffeine">本地缓存Caffeine</a><time datetime="2024-04-02T14:49:20.000Z" title="发表于 2024-04-02 22:49:20">2024-04-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/18/XuechengOnline/" title="XuechengOnline">XuechengOnline</a><time datetime="2023-09-18T11:56:19.000Z" title="发表于 2023-09-18 19:56:19">2023-09-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/09/ElasticSearch/" title="ElasticSearch">ElasticSearch</a><time datetime="2023-08-09T09:20:46.000Z" title="发表于 2023-08-09 17:20:46">2023-08-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/06/MeassageQueue/" title="MeassageQueue">MeassageQueue</a><time datetime="2023-08-06T07:41:56.000Z" title="发表于 2023-08-06 15:41:56">2023-08-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/04/Docker/" title="Docker">Docker</a><time datetime="2023-08-04T06:11:43.000Z" title="发表于 2023-08-04 14:11:43">2023-08-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By wzy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>