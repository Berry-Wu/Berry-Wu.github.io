<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis实战 | Wzy's Blog</title><meta name="author" content="wzy"><meta name="copyright" content="wzy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis的实战部分">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis实战">
<meta property="og:url" content="http://example.com/2023/07/13/Redis%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="Wzy&#39;s Blog">
<meta property="og:description" content="Redis的实战部分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cheems.jpg">
<meta property="article:published_time" content="2023-07-13T02:47:40.000Z">
<meta property="article:modified_time" content="2023-07-17T15:04:41.135Z">
<meta property="article:author" content="wzy">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cheems.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/07/13/Redis%E5%AE%9E%E6%88%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis实战',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-17 23:04:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cheems.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/bk2.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Wzy's Blog"><span class="site-name">Wzy's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-13T02:47:40.000Z" title="发表于 2023-07-13 10:47:40">2023-07-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-17T15:04:41.135Z" title="更新于 2023-07-17 23:04:41">2023-07-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis%E5%AD%A6%E4%B9%A0/">Redis学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>视频学习：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cr4y1671t/">黑马Redis入门到实战</a></p>
<p>课程资料：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1189u6u4icQYHg_9_7ovWmA?pwd=eh11">链接</a>   提取码：eh11</p>
<p>学习路线及部分内容参考：<a target="_blank" rel="noopener" href="https://cyborg2077.github.io/">Kyle’s Blog</a></p>
</blockquote>
<h1 id="内容概述"><a href="#内容概述" class="headerlink" title="内容概述"></a>内容概述</h1><p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713111559810.png" alt="image-20230713111559810"></p>
<hr>
<h1 id="短信登陆"><a href="#短信登陆" class="headerlink" title="短信登陆"></a>短信登陆</h1><h2 id="项目导入"><a href="#项目导入" class="headerlink" title="项目导入"></a>项目导入</h2><ul>
<li>资料中导入<strong>SQL</strong>文件，所提供表的内容如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">表</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">tb_user</td>
<td>用户表</td>
</tr>
<tr>
<td align="left">tb_user_info</td>
<td>用户详情表</td>
</tr>
<tr>
<td align="left">tb_shop</td>
<td>商户信息表</td>
</tr>
<tr>
<td align="left">tb_shop_type</td>
<td>商户类型表</td>
</tr>
<tr>
<td align="left">tb_blog</td>
<td>用户日记表（达人探店日记)</td>
</tr>
<tr>
<td align="left">tb_follow</td>
<td>用户关注表</td>
</tr>
<tr>
<td align="left">tb_voucher</td>
<td>优惠券表</td>
</tr>
<tr>
<td align="left">tb_voucher_order</td>
<td>优惠券的订单表</td>
</tr>
</tbody></table>
<ul>
<li><p>导入<strong>后端</strong>项目：同样已经放在资源中了，修改Mysql和Redis的相关配置。启动项目后访问<a target="_blank" rel="noopener" href="http://localhost:8081/shop-type/list">http://localhost:8081/shop-type/list</a> ，如果可以看到JSON数据，则说明导入成功</p>
<ul>
<li><p>这里我修改了数据库连接驱动为8以后版本，所以对应修改了maven依赖和驱动名称</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>页面显示：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713114244441.png" alt="image-20230713114244441"></p>
</li>
</ul>
</li>
<li><p>导入<strong>前端</strong>项目：这里也是直接拿资源中的nginx项目解压即可，其中已经包含了hmdp的前端资源，位于html文件夹下。</p>
<ul>
<li><p>nginx文件结构：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713114522356.png" alt="image-20230713114522356"></p>
</li>
<li><p>在<code>nginx所在目录</code>打开一个cmd窗口，输入命令：<code>start nginx.exe</code>，即可启动项目</p>
</li>
<li><p>访问<a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a> ，打开开发者模式，就可以看到页面</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713114914727.png" alt="image-20230713114914727"></p>
</li>
</ul>
</li>
</ul>
<h2 id="基于Session实现登录"><a href="#基于Session实现登录" class="headerlink" title="基于Session实现登录"></a>基于Session实现登录</h2><h3 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h3><ol>
<li>发送验证码<br>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号<br>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</li>
<li>短信验证码登录、注册<br>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</li>
<li>校验登录状态<br>用户在请求的时候，会从cookie中携带JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并放行</li>
</ol>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713155947666.png" alt="image-20230713155947666"></p>
<h3 id="发送验证码"><a href="#发送验证码" class="headerlink" title="发送验证码"></a>发送验证码</h3><p>首先进入<code>我的</code>页面，第一次进入会显示手机验证码登录，这里点击发送验证码按钮，发送如下请求：</p>
<blockquote>
<p>Request URL: <a target="_blank" rel="noopener" href="http://localhost:8080/api/user/code?phone=13264429299">http://localhost:8080/api/user/code?phone=13264429299</a></p>
<p>Request Method: POST</p>
</blockquote>
<p>可以看出，操作的内容是UserController，且方法拦截方法为<code>code</code>，携带参数<code>phone</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;code&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 发送短信验证码并保存验证码</span></span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;功能未完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改以上方法，这里我们通过调用service中的实现进行，不要把业务实现放在controller中，不便于重用和阅读。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;code&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 发送短信验证码并保存验证码</span></span><br><span class="line">    <span class="keyword">return</span> userService.sendCode(phone, session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再对应的serviceImpl中实现该方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="comment">//2.如果不符合返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.符合，生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">//4.保存验证码到session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line">    <span class="comment">//5.发送验证码</span></span><br><span class="line">    log.info(<span class="string">&quot;生成的验证码为：&#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：这里没有去真的发送验证码，想要改成邮箱验证参考瑞吉外卖部分</p>
</blockquote>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>上一步填上验证码后，点击登录发送请求和携带参数如下：</p>
<blockquote>
<p>Request URL:<a target="_blank" rel="noopener" href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p>
<p>Request Method:POST</p>
<p>{phone: “13264429299”, code: “404849”}</p>
</blockquote>
<p>可以看出是UserController中的login方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> LoginFormDTO loginForm, HttpSession session)</span>&#123;</span><br><span class="line">    <span class="comment">// TODO 实现登录功能</span></span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;功能未完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且使用的Dto来封装手机号和验证码。然后根据上述逻辑进行代码实现。依旧是写在serviceImpl中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="comment">//如果不符合返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.验证码不一致则报错</span></span><br><span class="line">    <span class="keyword">if</span> (code==<span class="literal">null</span> || !cacheCode.toString().equals(code))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;输入的验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.一致则先根据手机号查询用户</span></span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    lqw.eq(User::getPhone, phone);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getOne(lqw);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.用户不存在则创建,存在则继续执行程序</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//创建逻辑封装成了一个方法</span></span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;user信息：&#123;&#125;&quot;</span>, user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.保存用户信息到session中</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> User <span class="title function_">createUserWithPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">    <span class="comment">//1.创建用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setPhone(phone);</span><br><span class="line">    user.setNickName(<span class="string">&quot;游客&quot;</span>+phone);</span><br><span class="line">    <span class="comment">//2.保存用户信息</span></span><br><span class="line">    save(user);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>登录完后，数据库中就新增了用户数据：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713172326865.png" alt="image-20230713172326865"></p>
<blockquote>
<p>在上述功能完成期间，直接用课程资料中给的maven依赖会报错，我这里经过查阅，将<strong>mybatis-plus版本</strong>从3.4.3降到3.4.2后就正常运行</p>
</blockquote>
<h3 id="校验登录状态"><a href="#校验登录状态" class="headerlink" title="校验登录状态"></a>校验登录状态</h3><p>目前登录功能还有问题，当我们登录成功后，再点击我的，会发现还是让我们验证登录。这是因为我们还没完成登录校验功能，所以直接跳转到登录页面。</p>
<p>并且，不仅仅这个登录页面需要进行校验，很多controller都需要这个功能，所以这里可以通过设置一个<strong>拦截器</strong>，再所有的controller执行之前进行相应地操作。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713191707291.png" alt="image-20230713191707291"></p>
<p>这里创建一个<code>LoginInterceptor</code>类，实现<code>HandlerInterceptor</code>接口，重写其中的两个方法（快捷键<code>shift+alt+p</code>），前置拦截器和完成处理方法，<strong>前置拦截器</strong>主要用于登陆之前的权限校验，<strong>完成处理方法</strong>是用于处理登录后的信息，避免内存泄露</p>
<p><code>LoginInterceptor</code>：登录拦截器方法，将session中的信息保存在ThreadLocal中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//获取session中的用户信息</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (user==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//不存在，返回401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存在则保存用户信息到ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser((User) user);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserHolder</code>：使用ThreadLocal保存用户信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MvcConfig</code>：添加配置类，配置拦截器，并指定放行的请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                    <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/voucher/**&quot;</span></span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>/user/me</code>请求：这里返回登录用户信息，从而完成登录校验（登录校验的逻辑应该在前端实现的，对<code>/me</code>的ajax请求的返回进行判断，如果没有登录则跳转到指定页面）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/me&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">me</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TODO 获取当前登录的用户并返回</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    <span class="keyword">return</span> Result.ok(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时登录后就能正常显示<code>我的</code>页面：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713195147184.png" alt="image-20230713195147184"></p>
<h3 id="番外：ThreadLocal"><a href="#番外：ThreadLocal" class="headerlink" title="番外：ThreadLocal"></a>番外：ThreadLocal</h3><p>ThreadLocal可以解释成<strong>线程的局部变量</strong>，也就是说一个ThreadLocal的变量<strong>只有当前自身线程可以访问</strong>，别的线程都访问不了，那么自然就避免了线程竞争。</p>
<h3 id="番外：拦截器和过滤器"><a href="#番外：拦截器和过滤器" class="headerlink" title="番外：拦截器和过滤器"></a>番外：拦截器和过滤器</h3><blockquote>
<p>在上面我们用到了拦截器实现登录校验。但是一直不太清楚拦截器和过滤器具体使用场景和区别。所以这里进行了对比和总结。</p>
<p>这里参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xinzhifu1/article/details/106356958%E3%80%81https://zhuanlan.zhihu.com/p/408809649">https://blog.csdn.net/xinzhifu1/article/details/106356958、https://zhuanlan.zhihu.com/p/408809649</a></p>
</blockquote>
<h4 id="过滤器Filter"><a href="#过滤器Filter" class="headerlink" title="过滤器Filter"></a>过滤器Filter</h4><p>过滤器的配置比较简单，直接<strong>实现Filter 接口</strong>即可，也可以通过@WebFilter注解实现对特定URL拦截，看到Filter 接口中定义了三个方法。</p>
<ul>
<li><p><code>init()</code> ：该方法在容器启动初始化过滤器时被调用，它在 Filter 的整个生命周期只会被调用一次。注意：这个方法必须执行成功，否则过滤器会不起作用。</p>
</li>
<li><p><code>doFilter() </code>：容器中的每一次请求都会调用该方法， FilterChain 用来调用下一个过滤器 Filter。</p>
</li>
<li><p><code>destroy()</code>： 当容器销毁 过滤器实例时调用该方法，一般在方法中销毁或关闭资源，在过滤器 Filter 的整个生命周期也只会被调用一次</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Filter 前置&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Filter 处理中&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter 后置&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拦截器Interceptor"><a href="#拦截器Interceptor" class="headerlink" title="拦截器Interceptor"></a>拦截器Interceptor</h4><p>拦截器它是<strong>链式调用</strong>，一个应用中可以同时存在多个拦截器<code>Interceptor</code>， 一个请求也可以触发多个拦截器 ，而每个拦截器的调用会依据它的声明顺序依次执行。需要<strong>实现HandlerInterceptor接口</strong>。接口中也定义了三个方法：</p>
<ul>
<li><p><code>preHandle()</code> ：这个方法将在请求处理之前进行调用。注意：如果该方法的返回值为false ，将视为当前请求结束，不仅自身的拦截器会失效，还会导致其他的拦截器也不再执行。</p>
</li>
<li><p><code>postHandle()</code>：只有在 <code>preHandle() </code>方法返回值为true 时才会执行。会在Controller 中的方法调用之后，DispatcherServlet 返回渲染视图之前被调用。 </p>
<blockquote>
<p><code>postHandle()</code>方法被调用的顺序跟<code>preHandle() </code>是相反的，先声明的拦截器 <code>preHandle()</code> 方法先执行，而<code>postHandle()</code>方法反而会后执行。</p>
</blockquote>
</li>
<li><p><code>afterCompletion()</code>：只有在 <code>preHandle()</code>方法返回值为true 时才会执行。在整个请求结束之后， DispatcherServlet 渲染了对应的视图之后执行。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Interceptor 前置&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Interceptor 处理中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Interceptor 后置&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后可以创建一个config类实现<code>WebMvcConfigurer</code>接口，重写<code>addInterceptors</code>方法，在其中通过<code>addPathPatterns</code>、<code>excludePathPatterns</code>等属性设置需要拦截或需要排除的 <code>URL</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">            		<span class="string">&quot;/xxx/yy&quot;</span>,</span><br><span class="line">            		<span class="string">&quot;/xxx/zz&quot;</span>,</span><br><span class="line">            		<span class="string">&quot;/ddd/ff&quot;</span></span><br><span class="line">            	); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li><p>过滤器是基于<strong>函数回调</strong>，拦截器是基于java的<strong>反射机制</strong></p>
</li>
<li><p>过滤器属于<strong>Servlet级别</strong>，拦截器属于Spring级别 ****</p>
<ul>
<li>Filter是在javax.servlet包中定义的，要依赖于网络容器，因此只能在web项目中使用。</li>
<li>Interceptor是SpringMVC中实现的，拦截器是一个Spring组件，由Spring容器进行管理。</li>
</ul>
</li>
<li><p>执行顺序不同：</p>
<ul>
<li>当一个请求进入Servlet之前，过滤器的<code>doFilter</code>方法进行过滤，进入Servlet容器之后，执行Controller方法之前，拦截器的<code>preHandle</code>方法进行拦截，执行Controller方法之后，视图渲染之前，拦截器的<code>postHandle</code>方法进行拦截，请求结束之后，执行拦截器的<code>postHandle</code>方法。</li>
<li><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230714113359939.png" alt="image-20230714113359939"></li>
</ul>
</li>
<li><p>二者实际开发中的应用场景：</p>
<ul>
<li><strong>拦截器</strong>：权限控制（登录校验），日志打印，参数校验</li>
<li><strong>过滤器</strong>：跨域问题解决，编码转换</li>
</ul>
</li>
</ul>
<h3 id="隐藏用户敏感信息"><a href="#隐藏用户敏感信息" class="headerlink" title="隐藏用户敏感信息"></a>隐藏用户敏感信息</h3><p>在上面的内容中，我们可以在<code>/user/me</code>的请求返回值中看到如下用户的全部信息，这样会泄露用户的信息。所以这里在返回用户信息前，将其敏感信息进行隐藏。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1013</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span><span class="string">&quot;13264429111&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;nickName&quot;</span><span class="punctuation">:</span><span class="string">&quot;游客13264429111&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;createTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2023-07-13T19:12:59&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;updateTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2023-07-13T19:12:59&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>核心思想就是实现一个<code>UserDto</code>类，其中只包含用户名，头像和id即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> String icon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改UserHolder，将其User类型都换为UserDto</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且对应修改<code>/login</code>方法，在将用户信息存入session中时只存UserDto类型</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    @Override</span><br><span class="line">    public Result login(LoginFormDTO loginForm, HttpSession session) &#123;</span><br><span class="line">        String phone = loginForm.getPhone();</span><br><span class="line">        String code = loginForm.getCode();</span><br><span class="line">        Object cacheCode = session.getAttribute(&quot;code&quot;);</span><br><span class="line"></span><br><span class="line">        //1.校验手机号</span><br><span class="line">        if(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">            //如果不符合返回错误信息</span><br><span class="line">            return Result.fail(&quot;手机号格式错误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //2.验证码不一致则报错</span><br><span class="line">        if (code==null || !cacheCode.toString().equals(code))&#123;</span><br><span class="line">            return Result.fail(&quot;输入的验证码错误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.一致则先根据手机号查询用户</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        lqw.eq(User::getPhone, phone);</span><br><span class="line">        User user = getOne(lqw);</span><br><span class="line"></span><br><span class="line">        //4.用户不存在则创建,存在则继续执行程序</span><br><span class="line">        if (user == null) &#123;</span><br><span class="line">            //创建逻辑封装成了一个方法</span><br><span class="line">            user = createUserWithPhone(phone);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(&quot;user信息：&#123;&#125;&quot;, user);</span><br><span class="line"></span><br><span class="line">        //5.保存用户信息到session中</span><br><span class="line"><span class="deletion">-       session.setAttribute(&quot;user&quot;, user);</span></span><br><span class="line"><span class="addition">+       UserDTO userDTO = new UserDTO();</span></span><br><span class="line"><span class="addition">+       BeanUtils.copyProperties(user, userDTO);</span></span><br><span class="line"><span class="addition">+       session.setAttribute(&quot;user&quot;, userDTO);</span></span><br><span class="line">        return Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>同时也要修改拦截器中的方法</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        //获取session</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        //获取session中的用户信息</span><br><span class="line">        Object user = session.getAttribute(&quot;user&quot;);</span><br><span class="line">        //判断用户是否存在</span><br><span class="line">        if (user==null)&#123;</span><br><span class="line">            //不存在，返回401状态码</span><br><span class="line">            response.setStatus(401);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //存在则保存用户信息到ThreadLocal</span><br><span class="line"><span class="deletion">-       UserHolder.saveUser((User) user);</span></span><br><span class="line"><span class="addition">+       UserHolder.saveUser((UserDTO) user);</span></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此时再查看返回的内容，可见不包含敏感信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1013</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;nickName&quot;</span><span class="punctuation">:</span><span class="string">&quot;游客13264429111&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="基于Redis实现共享Session登录"><a href="#基于Redis实现共享Session登录" class="headerlink" title="基于Redis实现共享Session登录"></a>基于Redis实现共享Session登录</h2><h3 id="集群的Session共享问题"><a href="#集群的Session共享问题" class="headerlink" title="集群的Session共享问题"></a>集群的Session共享问题</h3><p><strong>session共享问题：</strong>多台Tomcat并不共享session的存储空间，当请求切换到不同tomcat服务器上时导致数据丢失的问题</p>
<p>早期的方案是<strong>session拷贝</strong>，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了。但是这种方法存在很大的缺点：每台服务器中都有完整的一份session数据，服务器压力过大；session拷贝数据时，可能会出现延迟。</p>
<p>session的替代方案应该满足：数据共享、内存存储和key-value结构。这自然想到<strong>Redis</strong></p>
<h3 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h3><ul>
<li>保存登录的用户信息，可以使用String结构，以JSON字符串来保存，比较直观</li>
</ul>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713212409863.png" alt="image-20230713212409863"></p>
<ul>
<li>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD，并且内存占用更少。（本项目以Hash存储）</li>
</ul>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713212420023.png" alt="image-20230713212420023"></p>
<p>对于保存用户手机号和验证码，采用String结构，以手机号为key，以验证码为value。</p>
<p>对于保存用户登录状态，采用Hash结构，以<strong>随机token</strong>为key存储用户数据，而不是将手机号作为key，因为这会造成用户信息的泄露。</p>
<h3 id="基于Redis实现验证码登录"><a href="#基于Redis实现验证码登录" class="headerlink" title="基于Redis实现验证码登录"></a>基于Redis实现验证码登录</h3><p>注入<code>StringRedisTemplate</code></p>
<ul>
<li><p>修改<code>sendCode</code></p>
<blockquote>
<p>key以手机号存储，同时加上业务逻辑便于查看。并且可以定义一个常量类来替换<code>login:code:</code>和<code>2</code>。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="comment">//2.如果不符合返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.符合，生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">//4.保存验证码到session</span></span><br><span class="line">    <span class="comment">//session.setAttribute(&quot;code&quot;, code);</span></span><br><span class="line">    <span class="comment">//4.保存验证码到redis</span></span><br><span class="line">    <span class="comment">//stringRedisTemplate.opsForValue().set(&quot;login:code:&quot;+phone, code,2, TimeUnit.MINUTES);</span></span><br><span class="line">	stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY+phone, code,LOGIN_CODE_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">//5.发送验证码(这里没有去真的发送验证码，想要改成邮箱验证参考瑞吉外卖部分)</span></span><br><span class="line">    log.info(<span class="string">&quot;生成的验证码为：&#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>常量类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConstants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOGIN_CODE_KEY</span> <span class="operator">=</span> <span class="string">&quot;login:code:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">LOGIN_CODE_TTL</span> <span class="operator">=</span> <span class="number">2L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOGIN_USER_KEY</span> <span class="operator">=</span> <span class="string">&quot;login:token:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">LOGIN_USER_TTL</span> <span class="operator">=</span> <span class="number">36000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">CACHE_NULL_TTL</span> <span class="operator">=</span> <span class="number">2L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">CACHE_SHOP_TTL</span> <span class="operator">=</span> <span class="number">30L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CACHE_SHOP_KEY</span> <span class="operator">=</span> <span class="string">&quot;cache:shop:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_SHOP_KEY</span> <span class="operator">=</span> <span class="string">&quot;lock:shop:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">LOCK_SHOP_TTL</span> <span class="operator">=</span> <span class="number">10L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SECKILL_STOCK_KEY</span> <span class="operator">=</span> <span class="string">&quot;seckill:stock:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BLOG_LIKED_KEY</span> <span class="operator">=</span> <span class="string">&quot;blog:liked:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FEED_KEY</span> <span class="operator">=</span> <span class="string">&quot;feed:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SHOP_GEO_KEY</span> <span class="operator">=</span> <span class="string">&quot;shop:geo:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER_SIGN_KEY</span> <span class="operator">=</span> <span class="string">&quot;sign:&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改<code>login</code></li>
</ul>
<blockquote>
<p>注意：直接按照老师代码会报错，这里将userMap中的value全转化为String类型才行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="comment">//通过session获取验证码</span></span><br><span class="line">    <span class="comment">//Object cacheCode = session.getAttribute(&quot;code&quot;);</span></span><br><span class="line">    <span class="comment">//通过redis获取验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY+phone);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="comment">//如果不符合返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.验证码不一致则报错</span></span><br><span class="line">    <span class="keyword">if</span> (code==<span class="literal">null</span> || !cacheCode.equals(code))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;输入的验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.一致则先根据手机号查询用户</span></span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    lqw.eq(User::getPhone, phone);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getOne(lqw);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.用户不存在则创建,存在则继续执行程序</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//创建逻辑封装成了一个方法</span></span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;user信息：&#123;&#125;&quot;</span>, user);</span><br><span class="line"></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDTO</span>();</span><br><span class="line">    BeanUtils.copyProperties(user, userDTO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.保存用户信息到session中</span></span><br><span class="line">    <span class="comment">//session.setAttribute(&quot;user&quot;, userDTO);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.保存用户信息到redis</span></span><br><span class="line">    <span class="comment">//5.1 随机生成token，作为登录令牌</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//5.2 将UserDto对象转为hash存储</span></span><br><span class="line">    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO);</span><br><span class="line">    <span class="comment">//这里将value全转换为String类型，因为userDto中的id是Long型，直接存入hash结构会报错</span></span><br><span class="line">    userMap.forEach((key, value) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != value) userMap.put(key, String.valueOf(value));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//5.3 存储</span></span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY+token, userMap);</span><br><span class="line">    <span class="comment">//设定token的有效期</span></span><br><span class="line">    stringRedisTemplate.expire(LOGIN_USER_KEY+token, LOGIN_USER_TTL,TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>经过这样的修改后，就可以在redis中看到缓存的数据。但是此时就会校验登录失败，因为之前实现是使用session，这里修改成redis，需要对应的修改。</p>
<p>此外，注意<strong>返回时要带上token</strong>，因为前端进行了数据判断，如果不携带token就会重新验证码登录</p>
</blockquote>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713222244886.png" alt="image-20230713222244886"></p>
<h3 id="解决状态登录刷新问题"><a href="#解决状态登录刷新问题" class="headerlink" title="解决状态登录刷新问题"></a>解决状态登录刷新问题</h3><p>之前设置了用户信息在redis中存活30分钟，但是此时无论用户是否有操作，30分钟一到都会被删除，这是不合理的。这里可以<strong>通过拦截器拦截到的请求</strong>，来证明用户是否在操作，如果用户没有任何操作30分钟，则token会消失，用户需要重新登录</p>
<h4 id="初步版本"><a href="#初步版本" class="headerlink" title="初步版本"></a>初步版本</h4><ul>
<li><p>首先通过查看前端请求，发现<strong>存的token在请求头里</strong>（这部分前端实现）</p>
<p><code>authorization: 6867061d-a8d0-4e60-b92f-97f7d698a1ca</code></p>
</li>
<li><p>修改<code>LoginInterceptor</code>类</p>
<blockquote>
<p>注意：这里不能直接注入StringRedisTemplate，因为这个类并没有给String容器管理，所以使用以下方法进行赋值实现。</p>
<p>而在<code>MvcConfig</code>中调用时进行依赖的注入，因为这个类标注了<code>@Configuration</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token))&#123;</span><br><span class="line">            <span class="comment">//不存在，返回401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.基于token获取redis中的用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//不存在，返回401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.将查询到的Hash数据转为UserDto对象</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.将userDto保存在TheadLocal中</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.刷新token的有效期</span></span><br><span class="line">        stringRedisTemplate.expire(key, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上述操作6中，会设置token数据的有效期，而每一次操作页面就会触发拦截器，所以只要用户在活跃状态，这个用户信息就不会过期。</p>
</blockquote>
</li>
<li><p><code>MvcConfig</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>(stringRedisTemplate))</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                    <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/voucher/**&quot;</span></span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>此时再运行，可以看到redis数据库中的数据和前端请求头中的<code>authorization</code>一致。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713225510663.png" alt="image-20230713225510663"></p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713225540560.png" alt="image-20230713225540560"></p>
<p>目前这个拦截器只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713225826186.png" alt="image-20230713225826186"></p>
<h4 id="优化版本"><a href="#优化版本" class="headerlink" title="优化版本"></a>优化版本</h4><p>可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230713230004843.png" alt="image-20230713230004843"></p>
<ol>
<li><p>首先新建一个拦截器<code>RefreshTokenInterceptor</code>，将之前的拦截器主要逻辑粘在这里，但是并<strong>不做拦截操作，而是全部放行</strong>，主要功能是获取token将用户信息保存在Threadloacl并且刷新token的有效期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.基于token获取redis中的用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.将查询到的Hash数据转为UserDto对象</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.将userDto保存在TheadLocal中</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.刷新token的有效期</span></span><br><span class="line">        stringRedisTemplate.expire(key, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改原来的拦截器，只需要对ThreadLocal中的数据判断是否为空即可，为空则拦截。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//判断是否需要拦截(ThreadLocal中是否有用户)</span></span><br><span class="line">        <span class="keyword">if</span> (UserHolder.getUser()==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//没有则需要拦截，设置状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="comment">//拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有用户则放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时修改对应的配置类<code>MvcConfig</code>，此时<code>LoginInterceptor</code>不需要传入stringRedisTemplate了，并且设置<code>ReefreshTokenInterceptor</code>的注册，设置拦截所有路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                    <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/voucher/**&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate))</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：这里可以使用<code>order</code>函数设置拦截器的执行顺序，我们把<code>RefreshTokenInterceptor</code>的优先级设为最高。</p>
</blockquote>
</li>
</ol>
<p>此时，通过Redis图行界面查看数据的TTL，每次更换访问页面，token的TTL就会刷新。</p>
<hr>
<h1 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h1><h2 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h2><p>缓存就是数据交换的缓存区，是存储数据的临时地方，一般读写性能较高。</p>
<p>缓存的作用：</p>
<ul>
<li>降低后端负载</li>
<li>提高读写效率，降低响应时间</li>
</ul>
<p>缓存的成本：</p>
<ul>
<li>数据一致性成本</li>
<li>代码维护成本</li>
<li>运维成本</li>
</ul>
<h2 id="添加商户缓存"><a href="#添加商户缓存" class="headerlink" title="添加商户缓存"></a>添加商户缓存</h2><h3 id="原本查询方法"><a href="#原本查询方法" class="headerlink" title="原本查询方法"></a>原本查询方法</h3><p>启动前端和后端的项目，登陆之后访问一个商户，查看浏览器发送的请求</p>
<blockquote>
<p>Request URL: <a target="_blank" rel="noopener" href="http://localhost:8080/api/shop/1">http://localhost:8080/api/shop/1</a></p>
<p>Request Method: GET</p>
</blockquote>
<p>可以看出在<code>ShopController</code>中的实现，原本的代码直接从数据库进行查询，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shopService.getById(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加缓存模型"><a href="#添加缓存模型" class="headerlink" title="添加缓存模型"></a>添加缓存模型</h3><p>可以在客户端与数据库之间加上一个Redis缓存，先从Redis中查询，如果没有查到，再去MySQL中查询，同时查询完毕之后，将查询到的数据也存入Redis，这样当下一个用户来进行查询的时候，就可以直接从Redis中获取到数据</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230714150534787.png" alt="image-20230714150534787"></p>
<p>对应的代码逻辑如下所示：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230714150543594.png" alt="image-20230714150543594"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>在Service中实现业务逻辑。</p>
<p><code>ShopController</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> shopService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IShopService</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IShopService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Shop&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Result <span class="title function_">queryById</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小技巧：快捷键<code>ctrl+alt+B</code>：直接跳转对应的实现类</p>
</blockquote>
<p><code>ShopServiceImpl</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ShopMapper, Shop&gt; <span class="keyword">implements</span> <span class="title class_">IShopService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">            <span class="comment">//3.存在，直接返回</span></span><br><span class="line">            <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.存在，写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<p>此时商铺信息就会存储在Redis数据库中：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230714152421152.png" alt="image-20230714152421152"></p>
<h2 id="添加商户类型缓存"><a href="#添加商户类型缓存" class="headerlink" title="添加商户类型缓存"></a>添加商户类型缓存</h2><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>商户类型指的是首页上方的几种类型：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230714152543289.png" alt="image-20230714152543289"></p>
<p>此时点击任意一种类型，会发送如下请求</p>
<blockquote>
<p>Request URL: <a target="_blank" rel="noopener" href="http://localhost:8080/api/shop-type/list">http://localhost:8080/api/shop-type/list</a></p>
<p>Request Method: GET</p>
</blockquote>
<p>可以看出是属于<code>ShopTypeController</code>中的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryTypeList</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;ShopType&gt; typeList = typeService</span><br><span class="line">        .query().orderByAsc(<span class="string">&quot;sort&quot;</span>).list();</span><br><span class="line">    <span class="keyword">return</span> Result.ok(typeList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要需要缓存的就是查询出的商户列表。像之前一样，还是将业务逻辑写在Service中。</p>
<p><code>ShopTypeController</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryTypeList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> typeService.queryList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ShopTypeServiceImpl</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopTypeServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ShopTypeMapper, ShopType&gt; <span class="keyword">implements</span> <span class="title class_">IShopTypeService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//首先根据key从redis中查询缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_TYPE_KEY;</span><br><span class="line">        <span class="type">String</span> <span class="variable">shopTypes</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//如果缓存不为空，则将返回的json字符串转换为类型列表，并且返回查询结果</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopTypes))&#123;</span><br><span class="line">            List&lt;ShopType&gt; typeList = JSONUtil.toList(shopTypes, ShopType.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(typeList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果为空，则进行sql查询，获取类型列表</span></span><br><span class="line">        List&lt;ShopType&gt; typeList = query().orderByAsc(<span class="string">&quot;sort&quot;</span>).list();</span><br><span class="line">        <span class="keyword">if</span> (typeList.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;分类信息为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果sql查询不为空，则将查询的列表转化为json字符串，将其存入redis中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(typeList);</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, jsonStr);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(typeList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时可以看到redis数据库中缓存到了商户类型</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230714163302426.png" alt="image-20230714163302426"></p>
<h3 id="番外：JSONUtil工具类"><a href="#番外：JSONUtil工具类" class="headerlink" title="番外：JSONUtil工具类"></a>番外：JSONUtil工具类</h3><p>这里对<code>JSONUtil</code>的几个常用方法进行记录：</p>
<ul>
<li><p><code>toBean(JSON json, Type beanType)</code>：将json转化为指定的实体类</p>
</li>
<li><p><code>toList(String jsonArray, Class&lt;T&gt; elementType )</code>：将<strong>JSONArray字符串</strong>转换为Bean的List</p>
</li>
<li><p><code>toJsonStr(JSON json)</code>：将<strong>实体类或实体类列表</strong>转为JSON字符串</p>
</li>
</ul>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJOSNUtil</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;wzy&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;yzw&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    List&lt;Stu&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(stu1);</span><br><span class="line">    list.add(stu2);</span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(list);</span><br><span class="line">    System.out.println(jsonStr);</span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr1</span> <span class="operator">=</span> JSONUtil.toJsonStr(stu1);</span><br><span class="line">    System.out.println(jsonStr1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Stu stu : JSONUtil.toList(jsonStr, Stu.class)) &#123;</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(JSONUtil.toBean(jsonStr1, Stu.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&quot;name&quot;:&quot;wzy&quot;,&quot;age&quot;:12&#125;,&#123;&quot;name&quot;:&quot;yzw&quot;,&quot;age&quot;:23&#125;]</span><br><span class="line">&#123;&quot;name&quot;:&quot;wzy&quot;,&quot;age&quot;:12&#125;</span><br><span class="line"></span><br><span class="line">Stu(name=wzy, age=12)</span><br><span class="line">Stu(name=yzw, age=23)</span><br><span class="line"></span><br><span class="line">Stu(name=wzy, age=12)</span><br></pre></td></tr></table></figure>

<h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><h3 id="常见更新策略"><a href="#常见更新策略" class="headerlink" title="常见更新策略"></a>常见更新策略</h3><p>因为Redis数据在内存中存储，插入太多数据，会导致缓存中数据过多，所以需要对缓存进行更新。常见的更新策略如下：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">内存淘汰</th>
<th align="center">超时剔除</th>
<th align="center">主动更新</th>
</tr>
</thead>
<tbody><tr>
<td align="center">说明</td>
<td align="center">不用自己维护， 利用Redis的内存淘汰机制， 当内存不足自动淘汰部分数据。 下次查询时更新缓存。</td>
<td align="center">给缓存数据添加TTL时间， 到期后自动删除缓存。 下次查询时更新缓存。</td>
<td align="center">编写业务逻辑， 在修改数据库的同时， 更新缓存。</td>
</tr>
<tr>
<td align="center">一致性</td>
<td align="center">差</td>
<td align="center">一般</td>
<td align="center">好</td>
</tr>
<tr>
<td align="center">维护成本</td>
<td align="center">无</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
</tbody></table>
<p>业务场景</p>
<ul>
<li>低一致性需求：使用内存淘汰机制，例如店铺类型的查询缓存）</li>
<li>高一致性需求：主动更新，并以超时剔除作为兜底方案，例如店铺详情查询的缓存、优惠券缓存</li>
</ul>
<h3 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h3><p>缓存数据源来自数据库，如果当数据库中数据发生变化，而缓存却没有同步，此时就导致一致性问题。有以下三种方案：</p>
<ol>
<li><code>Cache Aside Pattern</code> 人工编码方式：缓存调用者在更新完数据库之后再去更新缓存，也称之为双写方案</li>
<li><code>Read/Write Through Pattern</code>：缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。但是维护这样一个服务很复杂，市面上也不容易找到这样的一个现成的服务，开发成本高</li>
<li><code>Write Behind Caching Pattern</code>：调用者只操作缓存，其他线程去异步处理数据库，最终实现一致性。但是维护这样的一个异步的任务很复杂，需要实时监控缓存中的数据更新，其他线程去异步更新数据库也可能不太及时，而且缓存服务器如果宕机，那么缓存的数据也就丢失了</li>
</ol>
<p>在以上三种方法中，更多采用<strong>方案一</strong>。</p>
<p>操作缓存和数据库时有三个问题需要考虑：</p>
<ol>
<li><p>删除缓存还是更新缓存？</p>
<ul>
<li>更新缓存：每次更新数据库都更新缓存，无效写操作较多。❎</li>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存。✅</li>
</ul>
</li>
<li><p>如何保证缓存与数据库的操作的同步成功或失败？</p>
<ul>
<li>单体系统，将缓存与数据库放在一个事务</li>
<li>分布式系统，使用TTC等分布式事务</li>
</ul>
</li>
<li><p>先操作缓存还是先操作数据库？</p>
<ul>
<li><p>先删除缓存：</p>
<p>删除缓存的操作很快，更新数据库的操作相对较慢。在线程1进行修改时，如果此时有一个线程2进来查询缓存，由于刚刚删除缓存，所以线程2需要查询数据库，并写入缓存，但是更新数据库的操作还未完成，所以线程2此时缓存的数据和数据库中的数据不一致，出现线程安全问题。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230714171323199.png" alt="image-20230714171323199"></p>
</li>
<li><p>先删除数据库</p>
<p>线程1在查询缓存的时候，缓存TTL刚好失效，需要查询数据库并写入缓存，这个操作耗时相对较短，但是就在这么短的时间内，线程2进来了，更新数据库，删除缓存，但是线程1虽然查询完了数据（更新前的旧数据），但是还没来得及写入缓存，所以线程2的更新数据库与删除缓存，并没有影响到线程1的查询旧数据，写入缓存，造成线程安全问题</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230714172852683.png" alt="image-20230714172852683"></p>
</li>
<li><p>二者相比，后者出现线程安全问题的概率相对较低，所以通常采用<strong>先操作数据库，再删除缓存</strong>的方案</p>
</li>
</ul>
</li>
</ol>
<h3 id="实现商铺缓存与数据库双写一致"><a href="#实现商铺缓存与数据库双写一致" class="headerlink" title="实现商铺缓存与数据库双写一致"></a>实现商铺缓存与数据库双写一致</h3><p>修改ShopController中的业务逻辑，满足以下要求</p>
<ol>
<li>根据id查询店铺时，如果缓存未命中，则查询数据库，并将数据库结果写入缓存，并设置超时时间</li>
<li>根据id修改店铺时，先修改数据库，再删除缓存</li>
</ol>
<p>修改：</p>
<ol>
<li><p>修改ShopService的queryById方法，写入缓存时设置一下超时时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, Time)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改Controller中的<code>updateShop</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">updateShop</span><span class="params">(<span class="meta">@RequestBody</span> Shop shop)</span> &#123;</span><br><span class="line">    <span class="comment">// 写入数据库</span></span><br><span class="line">    <span class="keyword">return</span> shopService.update(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>serviceImpl实现对应的update方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">    <span class="keyword">if</span> (id==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺id不能为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.更新数据库</span></span><br><span class="line">    updateById(shop);</span><br><span class="line">    <span class="comment">//2.删除缓存</span></span><br><span class="line">    stringRedisTemplate.delete(RedisConstants.CACHE_SHOP_KEY+id);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：该方法需要声明为事务，因为涉及sql数据库操作和redis数据库操作，一旦其中有一个错误就回滚。</p>
</blockquote>
</li>
<li><p>然后启动项目，点击餐厅，将其数据缓存到Redis中。但是由于目前没有后端提供修改功能，所以这里使用POSTMAN发送PUT请求，请求路径<a target="_blank" rel="noopener" href="http://localhost:8081/shop%EF%BC%8C%E6%90%BA%E5%B8%A6JSON%E6%95%B0%E6%8D%AE%E5%A6%82%E4%B8%8B">http://localhost:8081/shop，携带JSON数据如下</a></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;area&quot;</span><span class="punctuation">:</span> <span class="string">&quot;大关&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;openHours&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10:00-22:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sold&quot;</span><span class="punctuation">:</span> <span class="number">4215</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;金华路锦昌文华苑29号&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="number">3035</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;avgPrice&quot;</span><span class="punctuation">:</span> <span class="number">80</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span> <span class="number">37</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;369茶餐厅&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typeId&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>此时数据库更新成功，同时redis中相关的缓存也被清理了，并且再次点击详情，对应数据的缓存就被保存在redis中。并且</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230714202109756.png" alt="image-20230714202109756"></p>
</li>
</ol>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="问题描述和解决方案"><a href="#问题描述和解决方案" class="headerlink" title="问题描述和解决方案"></a>问题描述和解决方案</h3><p><strong>缓存穿透：</strong>缓存穿透是指客户端<strong>请求的数据在缓存中和数据库中都不存在</strong>，这样缓存永远都不会生效（只有数据库查到了，才会让redis缓存，但现在的问题是查不到），会频繁的去访问数据库。</p>
<p>常见的解决方案有两种</p>
<ol>
<li><p><strong>缓存空对象（可添加TTL）</strong></p>
<ul>
<li><p>优点：实现简单，维护方便</p>
</li>
<li><p>缺点：额外的内存消耗；可能造成短期的不一致</p>
</li>
<li><p>实现思路：当客户端访问不存在的数据时，会先请求redis，但是此时redis中也没有数据，就会直接访问数据库，但是数据库里也没有数据，那么这个数据就穿透了缓存，直击数据库。但是数据库能承载的并发不如redis这么高，所以如果大量的请求同时都来访问这个不存在的数据，那么这些请求就会访问到数据库，简单的解决方案就是哪怕这个数据在数据库里不存在，我们也把这个这个数据存在redis中去，存为空对象，这样下次用户过来访问这个不存在的数据时，redis缓存中也能找到这个数据，不用去查数据库，但这样就造成了<strong>额外的内存消耗</strong>。<strong>短期不一致</strong>是指在空对象的存活期间，如果更新了数据库，但由于空对象的TTL还没过，所以当用户来查询的时候，查询到的还是空对象，等TTL过了之后，才能访问到正确的数据。</p>
</li>
<li><p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715103123126.png" alt="image-20230715103123126"></p>
</li>
</ul>
</li>
<li><p><strong>布隆过滤</strong></p>
<ul>
<li>优点：内存占用较少，没有多余的key</li>
<li>缺点：实现复杂；可能存在误判</li>
<li>实现思路：布隆过滤器采用的是<strong>哈希思想</strong>，并不是将数据库中的内容都保存到这里，而是通过一个<strong>二进制数组</strong>，根据哈希思想去判断当前这个要查询的数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，从数据库中查询到数据之后，再将其放到redis中。如果布隆过滤器判断这个数据不存在，则直接返回。优点在于节约内存空间，但<strong>存在误判</strong>，误判的原因在于：布隆过滤器基于哈希思想，只要是哈希思想，都可能存在<strong>哈希冲突</strong></li>
<li><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715103149780.png" alt="image-20230715103149780"></li>
</ul>
</li>
</ol>
<h3 id="解决商铺查询缓存穿透"><a href="#解决商铺查询缓存穿透" class="headerlink" title="解决商铺查询缓存穿透"></a>解决商铺查询缓存穿透</h3><p>商铺查询缓存穿透流程图：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715104124554.png" alt="image-20230715104124554"></p>
<p>思路：如果这个数据不存在，将这个数据写入到Redis中，将value设置为空字符串，然后设置一个较短的TTL，返回错误信息。当再次发起查询时，先去Redis中判断value是否为空字符串，如果是空字符串，则说明是不存在的数据，直接返回错误信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson))&#123; <span class="comment">//isNotBlank中如果是null、&quot;&quot;都会返回false</span></span><br><span class="line">        <span class="comment">//3.存在，直接返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[缓存穿透]判断命中的是否为空值。</span></span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;查询的商户不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//[缓存穿透]将空值写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.存在，写入Redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽取为一个方法"><a href="#抽取为一个方法" class="headerlink" title="抽取为一个方法"></a>抽取为一个方法</h3><p>这里先把之前写的缓存穿透代码修改一下，提取成一个独立的方法<code>queryWithPassThrough</code>，以免全写在queryById中，不便于阅读。同时方便后续功能的增加，更有区分性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithPassThrough</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson))&#123; <span class="comment">//isNotBlank中如果是null、&quot;&quot;都会返回false</span></span><br><span class="line">        <span class="comment">//3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[缓存穿透]判断命中的是否为空值。</span></span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//[缓存穿透]将空值写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.存在，写入Redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">//7.返回</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后的的<code>queryById</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> queryWithPassThrough(id);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>缓存穿透产生的原因是什么？</p>
<ul>
<li>用户请求的数据在缓存中和在数据库中都不存在，不断发起这样的请求，会给数据库带来巨大压力</li>
</ul>
<p>缓存穿透的解决方案有哪些？</p>
<ul>
<li>缓存null值</li>
<li>布隆过滤</li>
<li>增强id复杂度，避免被猜测id规律（可以采用<strong>雪花算法</strong>）</li>
<li>做好数据的基础格式校验</li>
<li>加强用户权限校验</li>
<li>做好热点参数的限流</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>缓存雪崩</strong>是指在同一时间段，<strong>大量缓存的key同时失效，或者Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>给不同的Key的TTL添加随机值。<ul>
<li>让其在不同时间段分批失效</li>
</ul>
</li>
<li>利用Redis集群提高服务的可用性。<ul>
<li>使用一个或者多个哨兵实例组成的系统，对redis节点进行监控，在主节点出现故障的情况下，能将从节点中的一个升级为主节点，进行故障转义，保证系统的可用性。</li>
</ul>
</li>
<li>给缓存业务添加降级限流策略。</li>
<li>给业务添加多级缓存。<ul>
<li>浏览器访问静态资源时，优先读取浏览器本地缓存；访问非静态资源（ajax查询数据）时，访问服务端；请求到达Nginx后，优先读取Nginx本地缓存；如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）；如果Redis查询未命中，则查询Tomcat；请求进入Tomcat后，优先查询JVM进程缓存；如果JVM进程缓存未命中，则查询数据库。</li>
</ul>
</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿也叫<strong>热点Key问题</strong>，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，那么无数请求访问就会在瞬间给数据库带来巨大的冲击</p>
<p>例如：秒杀商品的key突然失效了，大家都在疯狂抢购，那么这个瞬间就会有无数的请求访问去直接抵达数据库，从而造成缓存击穿</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715135246603.png" alt="image-20230715135246603"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>常见的解决方案：</p>
<ul>
<li><p><strong>互斥锁</strong></p>
<ul>
<li><p>流程：</p>
<p>在第一个线程缓存未命中时，首先会获取到一个互斥锁，然后继续后续的数据库查询重建任务，在此期间，如果有其他线程进来，在缓存查询未命中时，首先会尝试获取互斥锁，此时因为线程1还没释放锁，所以线程2获取失败，然后休眠一段时间后循环上述操作，直到线程1释放了锁，此时线程2就能获取到缓存，从而解决了上述问题</p>
</li>
<li><p>原理示意：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715135550365.png" alt="image-20230715135550365"></p>
</li>
</ul>
</li>
<li><p><strong>逻辑过期</strong></p>
<ul>
<li><p>流程：</p>
<p>之所以会出现缓存击穿问题，主要原因是对key设置了TTL，如果不设置TTL，就不会出现缓存击穿，但是就会占用过多内存，所以采用逻辑过期方案。也就是实际上没有设置TTL，但是在缓存的字段中新加了<code>expire</code>并指定了时间。在查询时，会判断逻辑时间是否过期，如果过期就会重新查询数据库进行重建。在重建完成前，其他线程都直接<strong>获取旧的缓存</strong>，直到锁的释放</p>
</li>
<li><p>原理示意：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715140132200.png" alt="image-20230715140132200"></p>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">解决方案</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">互斥锁</td>
<td align="center">没有额外的内存消耗; 保证一致性; 实现简单</td>
<td align="center">线程需要等待，性能受影响; 可能有死锁风险</td>
</tr>
<tr>
<td align="center">逻辑过期</td>
<td align="center">线程无需等待，性能较好</td>
<td align="center">不保证一致性; 有额外内存消耗; 实现复杂</td>
</tr>
</tbody></table>
<h3 id="互斥锁使用示例"><a href="#互斥锁使用示例" class="headerlink" title="互斥锁使用示例"></a>互斥锁使用示例</h3><p>修改根据id查询商铺信息的业务，基于互斥锁方式来解决缓存击穿的问题。流程如下：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715140840403.png" alt="image-20230715140840403"></p>
<p>这里锁的获取和释放采用的是Redis中的<code>setnx</code>命令实现：</p>
<ul>
<li>获取锁：<code>setnx lock [value] [TTL]</code><ul>
<li>当一个线程使用该命令进行指定key（lock）缓存的写入时，其他线程就无法操作这个lock</li>
<li>这里设置TTL是防止忘记释放锁而导致无法后续操作</li>
</ul>
</li>
<li>释放锁：<code>del lock</code><ul>
<li>当前线程执行完后，需要释放锁，可以直接将该缓存数据删除即可。</li>
</ul>
</li>
</ul>
<p>这里我们在<code>ShopServiceImpl</code>中新建两个方法，实现获取锁和释放锁的方法:</p>
<blockquote>
<p>这里的<code>setIfAbsent</code>就对应Redis命令<code>setnx</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存击穿：获取锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//避免返回值为null，这里使用了BooleanUtil工具类</span></span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存击穿：释放锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似之前的缓存穿透，我们这里也把互斥锁解决缓存击穿抽离为一个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson))&#123; <span class="comment">//isNotBlank中如果是null、&quot;&quot;都会返回false</span></span><br><span class="line">        <span class="comment">//3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[缓存穿透]判断命中的是否为空值。</span></span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[缓存击穿]获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">//[缓存击穿]判断是否获取成功</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock)&#123;</span><br><span class="line">            <span class="comment">//[缓存击穿]失败，则休眠重试</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="comment">//重试就是重新查询缓存，所以这里直接使用递归</span></span><br><span class="line">            <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.成功，根据id查询数据库</span></span><br><span class="line">        shop = getById(id);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模拟重建的延时</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//[缓存穿透]将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.存在，写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//[缓存击穿]释放互斥锁</span></span><br><span class="line">        unlock(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.返回</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里用到了try-catch去捕获线程sleep的异常。可以在选择需要包括的code后使用快捷键<code>ctrl+alt+T</code>快速实现功能。</p>
</blockquote>
<p>此时<code>queryById</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//缓存穿透</span></span><br><span class="line">    <span class="comment">//Shop shop = queryWithPassThrough(id);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存击穿:互斥锁</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> queryWithMutex(id);</span><br><span class="line">    <span class="comment">//这里统一对返回为null的情况进行报错</span></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JMeter并发测试"><a href="#JMeter并发测试" class="headerlink" title="JMeter并发测试"></a>JMeter并发测试</h4><p>使用教程参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/64847409">https://zhuanlan.zhihu.com/p/64847409</a></p>
<p>官网：<a target="_blank" rel="noopener" href="https://jmeter.apache.org/download_jmeter.cgi">https://jmeter.apache.org/download_jmeter.cgi</a></p>
<p>操作如下：</p>
<ol>
<li>首先将Redis中的热点商品数据删除，模拟TTL到期，然后用Jmeter进行压力测试，开1000个线程来访问这个没有缓存的热点数据</li>
<li>创建线程组，设置线程数和间隔时间。</li>
</ol>
<blockquote>
<p>右键点击“Test Plan测试计划”-“Add添加”-“Threads(Users)线程(用户)”-“Thread Group线程组”</p>
</blockquote>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715164507853.png" alt="image-20230715164507853"></p>
<ol start="3">
<li>然后设置HTTP请求，设定服务器协议，请求ip及端口号，设置请求方式和请求路径，修改编码为UTF-8</li>
</ol>
<blockquote>
<p>右键点击“Thread Group线程组” - “Add添加”-“Sampler” - “HTTP Request”</p>
</blockquote>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715164458590.png" alt="image-20230715164458590"></p>
<ol start="4">
<li>然后添加添加<strong>结果树视图&#x2F;聚合视图</strong></li>
</ol>
<blockquote>
<p>右键点击“Thread线程组”-“Add添加”-“Listener监听器”-“View Results Tree结果树视图”及“Summary Report聚合视图”</p>
</blockquote>
<ol start="5">
<li><p>然后点击上方小三角即可进行并发测试。此时查看结果树视图、聚合视图结果如下：</p>
<ul>
<li><p>结果树视图：</p>
<p>可以看出，请求都顺利执行</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715164519972.png" alt="image-20230715164519972"></p>
</li>
<li><p>聚合视图：</p>
<p>可以看到请求的各项参数</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715164531483.png" alt="image-20230715164531483"></p>
</li>
</ul>
</li>
<li><p>此时查看控制台输出，可以看出，执行1000个线程查询请求，后台只输出了一次sql数据库查询。这说明互斥锁有效，降低了数据库的查询量。</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT id,name,type_id,images,area,address,x,y,avg_price,sold,comments,score,open_hours, create_time,update_time FROM tb_shop WHERE id=?</span><br><span class="line">==&gt; Parameters: 1(Long)</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="逻辑过期使用示例"><a href="#逻辑过期使用示例" class="headerlink" title="逻辑过期使用示例"></a>逻辑过期使用示例</h3><p>需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿的问题。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715201049866.png" alt="image-20230715201049866"></p>
<p>过程：从Redis中查询缓存判断是否命中。如果没有命中则直接返回空数据，不查询数据库；如果命中，则将缓存中数据的value取出，判断value中的过期时间是否满足。如果没有过期，则直接返回Redis中的数据；如果过期，该线程直接返回之前的数据并获取互斥锁，然后新创建一个线程独去查询数据库以重构缓存数据，重构完成后再释放互斥锁。</p>
<p>流程：</p>
<ol>
<li><p>因为原本的Shop实体类并没有这个过期时间属性，为了不对原本的代码进行入侵（直接在Shop中添加字段），所以这里<strong>新建一个实体类</strong><code>RedisData</code>，包含原有数据和过期时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后再ShopServiceImlp中实现将shop数据和<strong>过期时间封装</strong>到redisData中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShop2Redis</span><span class="params">(Long id, Long expireSeconds)</span>&#123;</span><br><span class="line">    <span class="comment">//1.查询店铺数据</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">//2.封装逻辑过期时间</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">    redisData.setData(shop);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));</span><br><span class="line">    <span class="comment">//3.写入Redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这里进行测试，看看是否能成功写入redis，这里在测试类中进行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ShopServiceImpl shopService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveShop</span><span class="params">()</span>&#123;</span><br><span class="line">    shopService.saveShop2Redis(<span class="number">1L</span>, <span class="number">100L</span>); <span class="comment">//id=1，过期时间=当前时间+100s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis数据库中的缓存</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;area&quot;</span><span class="punctuation">:</span> <span class="string">&quot;大关&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;openHours&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10:00-22:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sold&quot;</span><span class="punctuation">:</span> <span class="number">4215</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;images&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://qcloud.dpfile.com/pc/jiclIsCKmOI2arxKN1Uf0Hx3PucIJH8q0QSz-Z8llzcN56-_QiKuOvyio1OOxsRtFoXqu0G3iT2T27qat3WhLVEuLYk00OmSS1IdNpm8K8sG4JN9RIm2mTKcbLtc2o2vfCF2ubeXzk49OsGrXt_KYDCngOyCwZK-s3fqawWswzk.jpg,https://qcloud.dpfile.com/pc/IOf6VX3qaBgFXFVgp75w-KKJmWZjFc8GXDU8g9bQC6YGCpAmG00QbfT4vCCBj7njuzFvxlbkWx5uwqY2qcjixFEuLYk00OmSS1IdNpm8K8sG4JN9RIm2mTKcbLtc2o2vmIU_8ZGOT1OjpJmLxG6urQ.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;金华路锦昌文华苑29号&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="number">3035</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;avgPrice&quot;</span><span class="punctuation">:</span> <span class="number">80</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;updateTime&quot;</span><span class="punctuation">:</span> <span class="number">1689337040000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span> <span class="number">37</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;createTime&quot;</span><span class="punctuation">:</span> <span class="number">1640167839000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;369茶餐厅&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;x&quot;</span><span class="punctuation">:</span> <span class="number">120.149192</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;y&quot;</span><span class="punctuation">:</span> <span class="number">30.316078</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typeId&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;expireTime&quot;</span><span class="punctuation">:</span> <span class="number">1689424146614</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看出，保存的缓存中多了过期时间字段</p>
</blockquote>
</li>
<li><p>然后就是类似上面互斥锁，也新建一个方法单独实现逻辑过期功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里需要声明一个线程池，因为下面需要新建一个现成来完成重构缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * queryById：解决缓存击穿：使用逻辑过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithExpire</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(shopJson))&#123;</span><br><span class="line">        <span class="comment">//不存在直接返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.命中，将json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="comment">//4.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (LocalDateTime.now().isBefore(redisData.getExpireTime()))&#123;</span><br><span class="line">        <span class="comment">//4.1如果未过期则直接返回数据</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 过期，则需要缓存重建</span></span><br><span class="line">    <span class="comment">//5.缓存重建</span></span><br><span class="line">    <span class="comment">//5.1 获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">//5.2 判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">        <span class="comment">//成功则开启独立线程，并返回旧的店铺信息</span></span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//重建缓存(这里过期时间设置得短，为了便于测试)</span></span><br><span class="line">                <span class="built_in">this</span>.saveShop2Redis(id, <span class="number">30L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//直接返回商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//未获取到锁，直接返回商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);</code>这里用到的是Java中的一个常用线程池类——newFixedThreadPool。创建的线程池是一个固定大小的线程池，线程池中的线程数量是固定的，由构造函数传入的参数指定，而任务队列的大小则由内部的阻塞队列来决定。</p>
</blockquote>
</li>
</ol>
<p>这里我们模拟场景，在此之前，我们已经将餐厅数据缓存到redis，但是缓存时间早已过期，这时，我们去数据库修改餐厅的数据，（这里是修改餐厅名称）。这样逻辑过期前和逻辑过期后的数据就不一致，当用户来访问数据的时候，需要花时间来进行重构缓存数据，但是在重构完成之前，都只能获得脏数据（也就是修改前的数据），只有当重构完毕之后，才能获得新数据（修改后的数据）。</p>
<p>然后此时在缓存重建部分内容人为添加上延时，便于观察重建期间其他线程访问到的数据内容</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void saveShop2Redis(Long id, Long expireSeconds) throws InterruptedException &#123;</span><br><span class="line">    //1.查询店铺数据</span><br><span class="line">    Shop shop = getById(id);</span><br><span class="line"><span class="addition">+   Thread.sleep(200);</span></span><br><span class="line">    //2.封装逻辑过期时间</span><br><span class="line">    RedisData redisData = new RedisData();</span><br><span class="line">    redisData.setData(shop);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));</span><br><span class="line">    //3.写入Redis</span><br><span class="line">    stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时使用JMeter进行100个线程访问测试：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715212020400.png" alt="image-20230715212020400"></p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230715211954105.png" alt="image-20230715211954105"></p>
<p>在前面部分线程访问到的都是旧数据，在线程25以后访问到的就是更新后的数据。并且通过IDEA的控制台输出可以看出只进行了一次SQL查询。</p>
<h2 id="缓存工具封装"><a href="#缓存工具封装" class="headerlink" title="缓存工具封装"></a>缓存工具封装</h2><blockquote>
<p>无论是解决缓存穿透还是缓存击穿，其逻辑都是复杂的，如果每次开发都重写这些逻辑，就会有些复杂，所以这里将其封装为工具类</p>
</blockquote>
<p>基于StringRedisTemplate封装一个<strong>缓存工具类</strong>，需满足下列要求</p>
<ul>
<li>方法1：将<strong>任意</strong>Java对象序列化为JSON，并存储到String类型的Key中，并可以设置TTL过期时间</li>
<li>方法2：将<strong>任意</strong>Java对象序列化为JSON，并存储在String类型的Key中，并可以设置逻辑过期时间，用于处理缓存击穿问题</li>
<li>方法3：根据指定的Key查询缓存，并反序列化为指定类型，利用<strong>缓存空值</strong>的方式解决<strong>缓存穿透</strong>问题</li>
<li>方法4：根据指定的Key查询缓存，并反序列化为指定类型，需要利用<strong>逻辑过期</strong>解决<strong>缓存击穿</strong>问题</li>
</ul>
<p><strong>流程：</strong></p>
<ol start="0">
<li><p>这里在util包中创建<code>CacheClinet</code></p>
<blockquote>
<p>让后将上述内容写在该类中即可</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1：将**任意**Java对象序列化为JSON，并存储到String类型的Key中，并可以设置TTL过期时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法2：将任意Java对象序列化为JSON，并存储在String类型的Key中，并可以设置逻辑过期时间，用于处理缓存击穿问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="comment">//设置逻辑过期</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">    redisData.setData(value);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">    <span class="comment">//写入redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法三</p>
<blockquote>
<p>该方法直接在之前<code>queryWithPassThrough</code>的基础上进行修改。</p>
<ul>
<li>因为需要改成通用方法，所以这里返回类型不能是Shop，而是需要返回一个泛型，所以方法上定义泛型和返回类型<code>&lt;R&gt; R</code>，并且通过参数<code>Class&lt;R&gt; type</code>传递需要处理的类型</li>
<li>传入id的类型也不一定是Long，所以也是用泛型，定义在前面。</li>
<li>然后此时缓存前缀也会随着任务的不同而不同，所以也需要调用者自己输入，所以这里也抽离称为一个参数<code>String keyPrefix</code></li>
<li>因为具体的数据库查询逻辑也不同，所以在参数列表中加入一个查询数据库逻辑的函数<code>Function&lt;ID, R&gt; dbFallback</code>，传递id和处理的类型。然后调用<code>apply</code>方法调用传递的函数，返回对应类型的数据r。</li>
<li>以及传入TTL的两个参数</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法3：根据指定的Key查询缓存，并反序列化为指定类型，利用**缓存空值**的方式解决**缓存穿透**问题</span></span><br><span class="line"><span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123; <span class="comment">//isNotBlank中如果是null、&quot;&quot;都会返回false</span></span><br><span class="line">        <span class="comment">//3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[new]判断命中的是否为空值。</span></span><br><span class="line">    <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">    <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//[new]将空值写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.存在，写入Redis</span></span><br><span class="line">    <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">    <span class="comment">//7.返回</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改<code>ShopServiceImpl</code>中的<code>queryById</code>方法，修改缓存击穿的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CacheClient cacheClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//调用封装工具解决缓存击穿</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient.queryWithPassThrough(RedisConstants.CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>方法四</p>
<blockquote>
<p>类似上面的逻辑，传递的参数都一致。只不过这里需要将线程获取、获取锁和释放锁的代码拿过来。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法4：根据指定的Key查询缓存，并反序列化为指定类型，需要利用**逻辑过期**解决**缓存击穿**问题</span></span><br><span class="line"><span class="comment">//这里需要声明一个线程池，因为下面需要新建一个现成来完成重构缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//[缓存击穿-互斥锁]：获取锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//避免返回值为null，我们这里使用了BooleanUtil工具类</span></span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[缓存击穿-互斥锁]：释放锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">    <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(json))&#123;</span><br><span class="line">        <span class="comment">//不存在直接返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.命中，将json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">    <span class="comment">//4.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (LocalDateTime.now().isBefore(redisData.getExpireTime()))&#123;</span><br><span class="line">        <span class="comment">//4.1如果未过期则直接返回数据</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 过期，则需要缓存重建</span></span><br><span class="line">    <span class="comment">//5.缓存重建</span></span><br><span class="line">    <span class="comment">//5.1 获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">//5.2 判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">        <span class="comment">//成功则开启独立线程，并返回旧的店铺信息</span></span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//[]重建缓存:查询数据库</span></span><br><span class="line">                <span class="type">R</span> <span class="variable">r1</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                <span class="comment">//[]重建缓存:写入Redis</span></span><br><span class="line">                <span class="built_in">this</span>.setWithLogicalExpire(key, r1, time, unit);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//直接返回商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//未获取到锁，直接返回商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这部分内容不能直接执行，因为这个方法会判断过期时间字段，如果缓存没有这个字段就会查询失败。所以执行前先使用测试方法添加一个缓存信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CacheClient cacheClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLogicalExpire</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> shopService.getById(<span class="number">1L</span>);</span><br><span class="line">    cacheClient.setWithLogicalExpire(RedisConstants.CACHE_SHOP_KEY+<span class="number">1L</span>, shop, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
</blockquote>
</li>
</ol>
<p>至此，之前在<code>ShopServiceImpl</code>中实现的缓存击穿、缓存穿透的代码就不需要了，直接调用写好的<code>CacheClient</code>工具类即可，并且更加灵活，应对不同的输入类型和操作逻辑。</p>
<hr>
<h1 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h1><h2 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h2><p>背景：这里以购物app中的优惠券为例，当用户下单抢购优惠券后，对应的订单就会保存在 <code>user_voucher_order</code>，因为对应的订单号的id需要展示给用户，如果使用数据库自增id就会出现一些问题：</p>
<ol>
<li>id的规律性太明显<ul>
<li>如果id有明显的规律，会被用户或者竞争对手从中获取到敏感信息，比如商城一天之内的销售量</li>
</ul>
</li>
<li>受单表数据量的限制<ul>
<li>随着商城规模的扩大，mysql单表数据量不宜超过500W，这时过多的订单就要通过拆库拆表实现，从逻辑上讲，这些属于一张表，所以id不能重复，因此要保证id的唯一性</li>
</ul>
</li>
</ol>
<p>这就引入了<strong>全局ID生成器</strong>，这是一种在分布式系统下用来生成全局唯一ID的工具，一般需要满足下列特征：</p>
<ul>
<li>唯一性</li>
<li>高可用</li>
<li>高性能</li>
<li>递增性</li>
<li>安全性</li>
</ul>
<p><strong>全局唯一ID生成策略：</strong></p>
<ul>
<li>UUID</li>
<li>Redis自增</li>
<li>snowflake算法</li>
<li>数据库自增</li>
</ul>
<p><strong>ID组成部分</strong></p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716171045615.png" alt="image-20230716171045615"></p>
<ul>
<li>符号位：1bit，永远为0</li>
<li>时间戳：31bit，以秒为单位，可以使用69年（2^31秒约等于69年）</li>
<li>序列号：32bit，秒内的计数器，支持每秒传输2^32个不同ID</li>
</ul>
<h3 id="Redis自增"><a href="#Redis自增" class="headerlink" title="Redis自增"></a>Redis自增</h3><p>Redis自增策略：</p>
<ul>
<li>每天一个key，方便统计销售量；同时也避免超过存储数据上限（incr自增的值限制在64位）</li>
<li>ID构造是时间戳+计数器</li>
</ul>
<p><strong>代码实现：</strong></p>
<blockquote>
<p>这里首先在utils包下新建一个<code>RedisIdWorker</code>类</p>
</blockquote>
<p>这里使用Redis的<code>INCR</code>递增函数实现，该命令会将key中存储的数字值增加一。如果key不存在，那么key值就会先被初始化为0，再执行incr命令。本操作的值限制在 64 位(bit)有符号数字表示之内。对应的SpringRedisTemplate中对应的是<code>opsForString.increment()</code></p>
<ol start="0">
<li>首先获取起始时间的秒数</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//设置一下起始时间，时间戳就是起始时间与当前时间的秒数差</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">tmp</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2022</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    System.out.println(tmp.toEpochSecond(ZoneOffset.UTC));</span><br><span class="line">    <span class="comment">//结果为1640995200L</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>然后进行唯一id的获取，将上面得到的其实时间定义为一个常量。</p>
<blockquote>
<p>注意：在生成序列号的部分，之所以获取当天日期，是为了便于后续统计当天、当月或当年的销售量，便于区分</p>
</blockquote>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置起始时间:2022.01.01 00:00:00</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line">    <span class="comment">//序列号长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">COUNT_BIT</span> <span class="operator">=</span> <span class="number">32L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">//生成时间戳</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> LocalDateTime.now().toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeStamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成序列号</span></span><br><span class="line">        <span class="comment">// 先获取当天日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">// 自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拼接并返回</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> timeStamp &lt;&lt; COUNT_BIT | count; <span class="comment">// 将timeStamp左移32位，然后使用或运算拼接redis序列号</span></span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实现优惠券秒杀下单"><a href="#实现优惠券秒杀下单" class="headerlink" title="实现优惠券秒杀下单"></a>实现优惠券秒杀下单</h2><p>每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以随意购买，特价券需要秒杀抢购</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716174921932.png" alt="image-20230716174921932"></p>
<p>这两种代金券对应数据库中的两个表：</p>
<ul>
<li><p>平价券<code>tb_voucher</code></p>
<ul>
<li><p>表结构如下：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716180403204.png" alt="image-20230716180403204"></p>
</li>
</ul>
</li>
<li><p>特价券 <code>tb_seckill_voucher</code></p>
<ul>
<li><p>表结构如下：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716180445638.png" alt="image-20230716180445638"></p>
</li>
</ul>
</li>
</ul>
<p>对比：</p>
<ul>
<li>可以看出平价券并没有库存字段，而特价券除了具有优惠券的基本信息外（通过关联优惠券id），还有库存、生效时间、失效时间等字段</li>
<li>并且平价券的字段中包含了type，0代表普通券，1代表秒杀券</li>
</ul>
<h3 id="添加优惠券"><a href="#添加优惠券" class="headerlink" title="添加优惠券"></a>添加优惠券</h3><p>因为这时数据库中还没有秒杀券，这里进行添加逻辑分析和数据添加（这部分代码项目中已经实现好了）</p>
<p><code>VoucherController</code>中的优惠券添加方法。<strong>新增普通券</strong>，只是将普通券的信息保存到表中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 新增普通券</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> voucher 优惠券信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 优惠券id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.save(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增秒杀券位于<code>addSeckillVoucher</code>中的业务逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 新增秒杀券</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> voucher 优惠券信息，包含秒杀信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 优惠券id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;seckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.addSeckillVoucher(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对应的<code>addSeckillVoucher</code>方法如下：</p>
<blockquote>
<p>秒杀券可以看做是一种特殊的普通券，将普通券信息保存到普通券表中，同时将秒杀券的数据保存到秒杀券表中，<strong>通过券的ID进行关联</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为该项目没有实现后端管理界面，所以使用postman模拟发送请求来新增秒杀券，请求路径为<code>localhost:8081/voucher/seckill</code>， 请求方式POST，JSON数据如下。注意优惠券的截止日期设置，若优惠券过期，则不会在页面上显示。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;shopId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;100元代金券&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;subTitle&quot;</span><span class="punctuation">:</span><span class="string">&quot;周一至周五可用&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span><span class="string">&quot;全场通用\\n无需预约\\n可无限叠加&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;payValue&quot;</span><span class="punctuation">:</span><span class="number">8000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;actualValue&quot;</span><span class="punctuation">:</span><span class="number">10000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span><span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;beginTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2023-07-16T19:00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;endTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2023-07-16T23:59:59&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>页面显示如下：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716191825577.png" alt="image-20230716191825577"></p>
<h3 id="秒杀实现"><a href="#秒杀实现" class="headerlink" title="秒杀实现"></a>秒杀实现</h3><p>此时点击<code>限时抢购</code>，发送如下请求</p>
<blockquote>
<p>Request URL：<a target="_blank" rel="noopener" href="http://localhost:8080/api/voucher-order/seckill/10">http://localhost:8080/api/voucher-order/seckill/10</a></p>
<p>Request Method: POST</p>
</blockquote>
<p>可以看出是<code>VoucherOrderController</code>中的<code>seckill/&#123;id&#125;</code>请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/voucher-order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;seckill/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long voucherId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;功能未完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下单时需要判断两点：</p>
<ul>
<li>秒杀是否开始或者结束，如果尚未开始或已经结束则无法下单</li>
<li>库存是否充足，不足则无法下单</li>
</ul>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716204730696.png" alt="image-20230716204730696"></p>
<p><strong>代码实现：</strong></p>
<p>依旧是修改controller中的方法，调用service中的实现，然后在serviceImpl中实现对应功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//1.查询优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">//2.判断秒杀是否开始</span></span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.判断秒杀是否结束</span></span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>,voucherId)</span><br><span class="line">                .update();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!success)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//6.1订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">//6.2用户id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">//6.3代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        <span class="comment">//7.返回订单id</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：这里扣减库存逻辑采用<code>setSql</code>实现：在此之前，我们如果想要更新数据库中的某条数据的某个字段，需要前先查询出来再更新。但若直接使用<code>setSql</code>则相当于直接更新。以下述为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seckillVoucherService.update()</span><br><span class="line">    .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">    .eq(<span class="string">&quot;voucher_id&quot;</span>,voucherId)</span><br><span class="line">    .update();</span><br></pre></td></tr></table></figure>

<p>相当于sql语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="string">&#x27;voucher&#x27;</span> <span class="keyword">SET</span> <span class="string">&#x27;stock&#x27;</span> <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> <span class="string">&#x27;voucher_id&#x27;</span> <span class="operator">=</span> voucherId;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>结果：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716211205452.png" alt="image-20230716211205452"></p>
<p>可以看到抢购成功，并且刷新后库存减一</p>
<h2 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h2><h3 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h3><p>之前的代码其实是有问题的，当<strong>遇到高并发场景时，会出现超卖现象</strong>，可以用Jmeter开200个线程来模拟抢优惠券的场景（此时券只有100个），URL为 <code>localhost:8081/voucher-order/seckill/10</code>，请求方式为<code>POST</code></p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716212429435.png" alt="image-20230716212429435"></p>
<blockquote>
<p>但是这样直接去请求会出现问题，所有的http请求都失败了。这是因为没有携带登录的token ，可以从redis缓存或者浏览器中获取，添加到http请求中。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716212819878.png" alt="image-20230716212819878"></p>
</blockquote>
<p>执行完后，会发现出现了109个订单，并且秒杀券的数量变成了-9，说明超卖了9张。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716214748603.png" alt="image-20230716214748603"></p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716214803865.png" alt="image-20230716214803865"></p>
<h3 id="问题分析-悲、乐观锁"><a href="#问题分析-悲、乐观锁" class="headerlink" title="问题分析|悲、乐观锁"></a>问题分析|悲、乐观锁</h3><p>之所以出现超卖问题，是因为代码中首先会查询库存数量，然后进行库存判断和扣减，在这个过程中，可能涉及多个线程同时操作，造成了多线程并发问题。如下图所示：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716215255599.png" alt="image-20230716215255599"></p>
<p>针对这一问题的常见解决方案就是<strong>加锁</strong>：而对于加锁，我们通常有两种解决方案：</p>
<ul>
<li><strong>悲观锁</strong><ul>
<li>悲观锁认为线程安全问题<strong>一定会发生</strong>，因此在操作数据之前先获取锁，确保<strong>线程串行执行</strong></li>
<li>例如Synchronized、Lock等，都是悲观锁</li>
<li>优点：简单粗暴</li>
<li>缺点：性能一般</li>
</ul>
</li>
<li><strong>乐观锁</strong><ul>
<li>乐观锁认为线程安全问题<strong>不一定会发生</strong>，因此不加锁，只是在更新数据的时候再去判断有没有其他线程对数据进行了修改<ul>
<li>如果没有修改，则认为自己是安全的，自己才可以更新数据</li>
<li>如果已经被其他线程修改，则说明发生了安全问题，此时可以重试或者异常</li>
</ul>
</li>
<li>优点：性能好</li>
<li>缺点：存在成功率低的问题</li>
</ul>
</li>
</ul>
<blockquote>
<p>悲观锁比较常用，这里不做赘述，这里具体介绍乐观锁</p>
</blockquote>
<p>乐观锁的关键是判断之前查询得到的数据是否被修改过，常见有两种方式：</p>
<ul>
<li><p><strong>版本号法：</strong></p>
<ul>
<li><p>乐观锁会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会比较之前查询到的版本号和目前保存的版本号，如果一致，则进行操作成功，如果不一致，则数据被修改过。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716221304180.png" alt="image-20230716221304180"></p>
</li>
</ul>
</li>
<li><p><strong>CAS(Compare-And-Set)法：</strong></p>
<ul>
<li><p>类似上面的方法，只不过不需要版本号，而是判断查询到的库存是否和实际库存一致。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230716221731397.png" alt="image-20230716221731397"></p>
</li>
</ul>
</li>
</ul>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>初步实现：</strong></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    @Transactional</span><br><span class="line">    public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">        //1.查询优惠券</span><br><span class="line">        SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);</span><br><span class="line">        //2.判断秒杀是否开始</span><br><span class="line">        if (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            return Result.fail(&quot;秒杀尚未开始&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.判断秒杀是否结束</span><br><span class="line">        if (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            return Result.fail(&quot;秒杀已经结束&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //4.判断库存是否充足</span><br><span class="line">        if (seckillVoucher.getStock() &lt; 1) &#123;</span><br><span class="line">            return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //5.扣减库存</span><br><span class="line">        boolean success = seckillVoucherService.update()</span><br><span class="line">                .setSql(&quot;stock = stock - 1&quot;)</span><br><span class="line">                .eq(&quot;voucher_id&quot;,voucherId) // set stock = stock - 1</span><br><span class="line"><span class="addition">+               .eq(&quot;stock&quot;, seckillVoucher.getStock()) //where id = ? and stock = ? </span></span><br><span class="line">                .update();</span><br><span class="line">        if (!success)&#123;</span><br><span class="line">            return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //6.创建订单</span><br><span class="line">        VoucherOrder voucherOrder = new VoucherOrder();</span><br><span class="line">        //6.1订单id</span><br><span class="line">        long orderId = redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        //6.2用户id</span><br><span class="line">        Long userId = UserHolder.getUser().getId();</span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        //6.3代金券id</span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        //7.返回订单id</span><br><span class="line"></span><br><span class="line">        return Result.ok(orderId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述逻辑：扣减库存时的库存和之前查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多<strong>失败的情况</strong>，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败。但实际上有其他线程修改是没有问题的，只要stock的数目大于0就行。</p>
<p><strong>完善版本：</strong></p>
<p>实际上就是在前面判断了库存大于0的基础上，在后面准备修改数据时在判断库存是否大于0.</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    @Transactional</span><br><span class="line">    public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">        //1.查询优惠券</span><br><span class="line">        SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);</span><br><span class="line">        //2.判断秒杀是否开始</span><br><span class="line">        if (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            return Result.fail(&quot;秒杀尚未开始&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.判断秒杀是否结束</span><br><span class="line">        if (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            return Result.fail(&quot;秒杀已经结束&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //4.判断库存是否充足</span><br><span class="line">        if (seckillVoucher.getStock() &lt; 1) &#123;</span><br><span class="line">            return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //5.扣减库存</span><br><span class="line">        boolean success = seckillVoucherService.update()</span><br><span class="line">                .setSql(&quot;stock = stock - 1&quot;)</span><br><span class="line">                .eq(&quot;voucher_id&quot;,voucherId) // set stock = stock - 1</span><br><span class="line"><span class="deletion">-               .eq(&quot;stock&quot;, seckillVoucher.getStock()) //where id = ? and stock = ? </span></span><br><span class="line"><span class="addition">+               .gt(&quot;stock&quot;, 0) //where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        if (!success)&#123;</span><br><span class="line">            return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //6.创建订单</span><br><span class="line">        VoucherOrder voucherOrder = new VoucherOrder();</span><br><span class="line">        //6.1订单id</span><br><span class="line">        long orderId = redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        //6.2用户id</span><br><span class="line">        Long userId = UserHolder.getUser().getId();</span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        //6.3代金券id</span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        //7.返回订单id</span><br><span class="line"></span><br><span class="line">        return Result.ok(orderId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这时再测试，就会发现优惠券正好被抢光。</p>
<h2 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h2><p>所谓一人一单就是修改秒杀业务，要求同一个优惠券，<strong>一个用户只能抢一张</strong></p>
<p>实现逻辑也很简单，在判断库存是否充足之后，根据用户id和优惠券id查询订单，判断用户订单是否已存在。如果已存在，则不能下单，返回错误信息；如果不存在，则继续下单，获取优惠券。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230717195742940.png" alt="image-20230717195742940"></p>
<h3 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional</span><br><span class="line">public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">    //1.查询优惠券</span><br><span class="line">    SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);</span><br><span class="line">    //2.判断秒杀是否开始</span><br><span class="line">    if (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀尚未开始&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.判断秒杀是否结束</span><br><span class="line">    if (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀已经结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.判断库存是否充足</span><br><span class="line">    if (seckillVoucher.getStock() &lt; 1) &#123;</span><br><span class="line">        return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+   //[一人一单]</span></span><br><span class="line"><span class="addition">+   // 查询订单</span></span><br><span class="line"><span class="addition">+   Long userId = UserHolder.getUser().getId();</span></span><br><span class="line"><span class="addition">+   Integer count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();</span></span><br><span class="line"><span class="addition">+   // 判断订单是否存在</span></span><br><span class="line"><span class="addition">+   if (count &gt; 0)&#123;</span></span><br><span class="line"><span class="addition">+       return Result.fail(&quot;不能重复购买&quot;);</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line"></span><br><span class="line">    //5.扣减库存</span><br><span class="line">    boolean success = seckillVoucherService.update()</span><br><span class="line">        .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1</span><br><span class="line">        .eq(&quot;voucher_id&quot;,voucherId)</span><br><span class="line">        .gt(&quot;stock&quot;, 0) //where id = ? and stock &gt; 0</span><br><span class="line">        .update();</span><br><span class="line">    if (!success)&#123;</span><br><span class="line">        return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //6.创建订单</span><br><span class="line">    VoucherOrder voucherOrder = new VoucherOrder();</span><br><span class="line">    //6.1订单id</span><br><span class="line">    long orderId = redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    //6.2用户id</span><br><span class="line"></span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    //6.3代金券id</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line">    //7.返回订单id</span><br><span class="line"></span><br><span class="line">    return Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时使用JMeter进行多线程购买测试，但是因为http头携带的token是同一个用户的，所以按说执行200个线程只有一个订单。但实际运行后，发现还是会出现多个订单。其实发生的原因是一样的，还是因为在一人一单逻辑之前，如果进来了多个线程，还是可以抢多张优惠券的，这里使用悲观锁来解决这个问题。</p>
<h3 id="进一步优化-加锁"><a href="#进一步优化-加锁" class="headerlink" title="进一步优化(加锁)"></a>进一步优化(加锁)</h3><p>核心思想：把一人一单逻辑之后的代码都提取到一个<code>createVoucherOrder</code>方法中，然后给这个方法加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span>&#123;</span><br><span class="line">    <span class="comment">//[一人一单]</span></span><br><span class="line">    <span class="comment">// 查询订单</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 判断订单是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不能重复购买&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>,voucherId)</span><br><span class="line">            .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">//where id = ? and stock &gt; 0</span></span><br><span class="line">            .update();</span><br><span class="line">        <span class="keyword">if</span> (!success)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//6.1订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">//6.2用户id</span></span><br><span class="line"></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">//6.3代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li>这里获取<strong>锁并没有放在方法上，而是放在获取了用户id之后</strong><ul>
<li>这是因为如果放在方法上，所有的用户都要公用这一把锁，导致每个线程进来都会被锁住，串行执行，效率很低</li>
</ul>
</li>
<li>这里的锁采用用户的id实现，但是为什么要使用<code>userId.toString().intern()</code>？<ul>
<li>这是<strong>因为<code>toString</code>的源码是new String</strong>，所以如果只用<code>userId.toString()</code>会拿到不同的地址引用，所以需要使用<code>intern()</code>：如果字符串常量池中已经包含了一个等于这个string对象的字符串（由equals（object）方法确定），那么将返回池中的字符串。否则，将此String对象添加到池中，并返回对此String对象的引用。</li>
<li>具体解释：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44201525/article/details/120897052">https://blog.csdn.net/weixin_44201525/article/details/120897052</a></li>
</ul>
</li>
</ul>
</blockquote>
<p>原来的方法变为:</p>
<blockquote>
<p>此时这个方法就不需要事务注解了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">//2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.判断秒杀是否结束</span></span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最终版本-事务"><a href="#最终版本-事务" class="headerlink" title="最终版本(事务)"></a>最终版本(事务)</h3><p>但是以上代码还是存在问题，问题的原因在于当前方法被Spring事务控制，如果在内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放了，这样也会导致其他线程的进入，从而引发线程安全问题，所以需要<strong>使用锁将当前方法整体包裹起来</strong>，确保事务不会出现问题。</p>
<p>所以还是在函数外加锁，外部传递用户id给锁:</p>
<p><code>createVoucherOrder</code>函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//[一人一单]</span></span><br><span class="line">    <span class="comment">// 查询订单</span></span><br><span class="line">	<span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="comment">// 判断订单是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;不能重复购买&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">        .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">        .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">        .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">//where id = ? and stock &gt; 0</span></span><br><span class="line">        .update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">//6.1订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">//6.2用户id</span></span><br><span class="line"></span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">//6.3代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用函数处加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">//2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.判断秒杀是否结束</span></span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">        <span class="keyword">return</span> createVoucherOrder(voucherId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，只有在事务完成后才会释放锁，因此解决了线程安全问题。但是，此时<strong>还存在事务的问题</strong>。因为调用的函数声明了事务，但是上述方法不涉及事务。这是因为调用的<code>createVoucherOrder</code>方法，其实是this.的方式调用的，<strong>事务想要生效，需要利用代理来生效</strong>，所以这个地方，需要获得原始的事务对象， 来操作事务，这里可以使用<code>AopContext.currentProxy()</code>来<strong>获取当前对象的代理对象</strong>，然后再用代理对象调用方法，从而使这个方法被spring事务管理。</p>
<blockquote>
<p>注意：这里需要去<code>IVoucherOrderService</code>中创建<code>createVoucherOrder</code>方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">    <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法会对应依赖，需要导入。导入完成记得刷新！</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建代理事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时需要启动类上加上<code>@EnableAspectJAutoProxy(exposeProxy = true)</code>注解，来暴露这个代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.hmdp.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(exposeProxy = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HmDianPingApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(HmDianPingApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启服务器，再次使用JMeter测试，100个线程并发，但是只能抢到一张优惠券，实现一人一单.</p>
<h3 id="并发安全问题"><a href="#并发安全问题" class="headerlink" title="并发安全问题"></a>并发安全问题</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了</p>
<ol>
<li><p>我们将服务启动两份，端口分别为8081和8082：</p>
<ul>
<li>首先IEAD锤子图标右边选择<code>edit Configuration</code></li>
<li>然后点击本项目，然后点击复制上方图标</li>
<li>然后点击<code>Modify options</code>–&gt;<code>Add VM option</code>，填写指定端口即可<code>-Dserver.port=8081</code>和<code>-Dserver.port=8082</code></li>
<li><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230717222104666.png" alt="image-20230717222104666"></li>
</ul>
</li>
<li><p>然后修改nginx的config目录下的nginx.conf文件，配置反向代理和负载均衡（默认轮询就行）</p>
<blockquote>
<p>这部分内容在瑞吉外卖优化篇有介绍，参考以前博客</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">worker_processes</span>  <span class="string">1;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">events</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">worker_connections</span>  <span class="string">1024;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">http</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">include</span>       <span class="string">mime.types;</span></span><br><span class="line">    <span class="attr">default_type</span>  <span class="string">application/json;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">sendfile</span>        <span class="string">on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">keepalive_timeout</span>  <span class="string">65;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">listen</span>       <span class="string">8080;</span></span><br><span class="line">        <span class="attr">server_name</span>  <span class="string">localhost;</span></span><br><span class="line"><span class="comment">        # 指定前端项目所在的位置</span></span><br><span class="line">        <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">            <span class="attr">root</span>   <span class="string">html/hmdp;</span></span><br><span class="line">            <span class="attr">index</span>  <span class="string">index.html index.htm;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">error_page</span>   <span class="string">500 502 503 504  /50x.html;</span></span><br><span class="line">        <span class="attr">location</span> = <span class="string">/50x.html &#123;</span></span><br><span class="line">            <span class="attr">root</span>   <span class="string">html;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="attr">location</span> <span class="string">/api &#123;  </span></span><br><span class="line">            <span class="attr">default_type</span>  <span class="string">application/json;</span></span><br><span class="line"><span class="comment">            #internal;  </span></span><br><span class="line">            <span class="attr">keepalive_timeout</span>   <span class="string">30s;  </span></span><br><span class="line">            <span class="attr">keepalive_requests</span>  <span class="string">1000;  </span></span><br><span class="line"><span class="comment">            #支持keep-alive  </span></span><br><span class="line">            <span class="attr">proxy_http_version</span> <span class="string">1.1;  </span></span><br><span class="line">            <span class="attr">rewrite</span> <span class="string">/api(/.*) $1 break;  </span></span><br><span class="line">            <span class="attr">proxy_pass_request_headers</span> <span class="string">on;</span></span><br><span class="line"><span class="comment">            #more_clear_input_headers Accept-Encoding;  </span></span><br><span class="line">            <span class="attr">proxy_next_upstream</span> <span class="string">error timeout;  </span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            #proxy_pass http://127.0.0.1:8081; # modify-1</span></span><br><span class="line">            <span class="attr">proxy_pass</span> <span class="string">http://backend;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">upstream</span> <span class="string">backend &#123;</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">127.0.0.1:8081 max_fails=5 fail_timeout=10s weight=1;</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">127.0.0.1:8082 max_fails=5 fail_timeout=10s weight=1; # modify-2</span></span><br><span class="line">    <span class="attr">&#125;</span>  <span class="string"></span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>具体测试：</strong>使用<code>POSTMAN</code>发送两次请求，header携带同一用户的token，尝试用同一账号抢两张优惠券，结果出现了同一用户下了两次单。</p>
<p><strong>原因分析：</strong>部署了多个Tomcat时，每个Tomcat都有一个属于自己的<code>JVM</code>，假设在<code>JVM1</code>的内部，有两个线程：线程1和线程2，<strong>在<code>JVM</code>内部有一个锁监视器来管理锁的线程所有者</strong>，所以线程1和线程2可以实现互斥的。但是如果在<code>JVM2</code>，又有两个线程，但是他们的锁对象虽然写的和<code>JVM1</code>一样，但是<strong>锁对象却不是同一个</strong>，因为此时锁监视器变了，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2互斥。</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230717220856033.png" alt="image-20230717220856033"></p>
<p>这就是集群环境下，syn锁失效的原因，在这种情况下，需要使用<strong>分布式锁</strong>来解决这个问题，让锁不存在于每个jvm的内部，而是让所有jvm公用外部的一把锁（Redis）</p>
<hr>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>分布式锁：满足分布式系统或集群模式下<strong>多线程可见并且可以互斥的锁</strong>。此外，还需要具有高可用、高性能、安全性等特性。</p>
<p>分布式锁的核心思想就是让大家共用同一把锁，那么就能锁住线程，不让线程进行，让程序串行执行，以下是原理示意：</p>
<p><img src="/2023/07/13/Redis%E5%AE%9E%E6%88%98/image-20230717224352825.png" alt="image-20230717224352825"></p>
<p>常见的分布式锁有三种：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">MySQL</th>
<th align="center">Redis</th>
<th align="center">Zookeeper</th>
</tr>
</thead>
<tbody><tr>
<td align="center">互斥</td>
<td align="center">利用mysql本身的互斥锁机制</td>
<td align="center">利用setnx这样的互斥命令</td>
<td align="center">利用节点的唯一性和有序性实现互斥</td>
</tr>
<tr>
<td align="center">高可用</td>
<td align="center">好</td>
<td align="center">好</td>
<td align="center">好</td>
</tr>
<tr>
<td align="center">高性能</td>
<td align="center">一般</td>
<td align="center">好</td>
<td align="center">一般</td>
</tr>
<tr>
<td align="center">安全性</td>
<td align="center">断开连接，自动释放锁</td>
<td align="center">利用锁超时时间，到期释放</td>
<td align="center">临时节点，断开连接自动释放</td>
</tr>
</tbody></table>
<h2 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h2><p>实现分布式锁时需要实现两个基本方法：</p>
<ol>
<li><p>获取锁：</p>
<ul>
<li><p>互斥：确保只能有一个线程获取锁</p>
</li>
<li><p>非阻塞：尝试一次，成功返回true，失败返回false</p>
</li>
<li><p>实现：</p>
<ul>
<li><p><input disabled="" type="checkbox"> 
老方法，这种方法添加锁和设置过期时间是两步实现的，有可能在设置过期时间前就出现问题，还会造成死锁。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加锁</span></span><br><span class="line">SETNX lock thread01</span><br><span class="line"><span class="comment"># 添加锁过期时间，避免服务器宕机引起的死锁</span></span><br><span class="line">EXPIRE lock 10</span><br></pre></td></tr></table></figure>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
新方法，使用redis中的方法，同时添加锁和过期时间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加锁的同时设置过期时间 NX是互斥，EX是设置过期时间</span></span><br><span class="line">SET lock thread01 NX EX 10</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>释放锁：</p>
<ul>
<li><p>手动释放</p>
</li>
<li><p>超时释放：获取锁的时候添加一个超时时间</p>
</li>
<li><p>实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 释放锁，删除即可</span></span><br><span class="line">DEL lock</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h1 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">wzy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/13/Redis%E5%AE%9E%E6%88%98/">http://example.com/2023/07/13/Redis%E5%AE%9E%E6%88%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Wzy's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="/img/cheems.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/07/11/Redis%E5%9F%BA%E7%A1%80/" title="Redis基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/04/Redis%E5%85%A5%E9%97%A8/" title="Redis入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-04</div><div class="title">Redis入门</div></div></a></div><div><a href="/2023/07/11/Redis%E5%9F%BA%E7%A1%80/" title="Redis基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-11</div><div class="title">Redis基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cheems.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wzy</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">内容概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%AD%E4%BF%A1%E7%99%BB%E9%99%86"><span class="toc-number">2.</span> <span class="toc-text">短信登陆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5"><span class="toc-number">2.1.</span> <span class="toc-text">项目导入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ESession%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95"><span class="toc-number">2.2.</span> <span class="toc-text">基于Session实现登录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">登录流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E9%AA%8C%E8%AF%81%E7%A0%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">发送验证码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95"><span class="toc-number">2.2.3.</span> <span class="toc-text">登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81"><span class="toc-number">2.2.4.</span> <span class="toc-text">校验登录状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%95%AA%E5%A4%96%EF%BC%9AThreadLocal"><span class="toc-number">2.2.5.</span> <span class="toc-text">番外：ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%95%AA%E5%A4%96%EF%BC%9A%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">2.2.6.</span> <span class="toc-text">番外：拦截器和过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8Filter"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">过滤器Filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">拦截器Interceptor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.6.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E7%94%A8%E6%88%B7%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF"><span class="toc-number">2.2.7.</span> <span class="toc-text">隐藏用户敏感信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%ABSession%E7%99%BB%E5%BD%95"><span class="toc-number">2.3.</span> <span class="toc-text">基于Redis实现共享Session登录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%9A%84Session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.1.</span> <span class="toc-text">集群的Session共享问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.3.2.</span> <span class="toc-text">结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95"><span class="toc-number">2.3.3.</span> <span class="toc-text">基于Redis实现验证码登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%8A%B6%E6%80%81%E7%99%BB%E5%BD%95%E5%88%B7%E6%96%B0%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.4.</span> <span class="toc-text">解决状态登录刷新问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E7%89%88%E6%9C%AC"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">初步版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%89%88%E6%9C%AC"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">优化版本</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%95%86%E6%88%B7%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">3.</span> <span class="toc-text">商户查询缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98"><span class="toc-number">3.1.</span> <span class="toc-text">什么是缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%95%86%E6%88%B7%E7%BC%93%E5%AD%98"><span class="toc-number">3.2.</span> <span class="toc-text">添加商户缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E6%9C%AC%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.1.</span> <span class="toc-text">原本查询方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">添加缓存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%95%86%E6%88%B7%E7%B1%BB%E5%9E%8B%E7%BC%93%E5%AD%98"><span class="toc-number">3.3.</span> <span class="toc-text">添加商户类型缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%95%AA%E5%A4%96%EF%BC%9AJSONUtil%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">3.3.2.</span> <span class="toc-text">番外：JSONUtil工具类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">3.4.</span> <span class="toc-text">缓存更新策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">3.4.1.</span> <span class="toc-text">常见更新策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">3.4.2.</span> <span class="toc-text">主动更新策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%95%86%E9%93%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4"><span class="toc-number">3.4.3.</span> <span class="toc-text">实现商铺缓存与数据库双写一致</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">3.5.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.5.1.</span> <span class="toc-text">问题描述和解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%95%86%E9%93%BA%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">3.5.2.</span> <span class="toc-text">解决商铺查询缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E5%8F%96%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.3.</span> <span class="toc-text">抽取为一个方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.5.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">3.6.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">3.7.</span> <span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.7.1.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.7.2.</span> <span class="toc-text">互斥锁使用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JMeter%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">JMeter并发测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.7.3.</span> <span class="toc-text">逻辑过期使用示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85"><span class="toc-number">3.8.</span> <span class="toc-text">缓存工具封装</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80"><span class="toc-number">4.</span> <span class="toc-text">优惠券秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID"><span class="toc-number">4.1.</span> <span class="toc-text">全局唯一ID</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E8%87%AA%E5%A2%9E"><span class="toc-number">4.1.1.</span> <span class="toc-text">Redis自增</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95"><span class="toc-number">4.2.</span> <span class="toc-text">实现优惠券秒杀下单</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%BC%98%E6%83%A0%E5%88%B8"><span class="toc-number">4.2.1.</span> <span class="toc-text">添加优惠券</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.2.</span> <span class="toc-text">秒杀实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.</span> <span class="toc-text">超卖问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E6%A8%A1%E6%8B%9F"><span class="toc-number">4.3.1.</span> <span class="toc-text">场景模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-%E6%82%B2%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">4.3.2.</span> <span class="toc-text">问题分析|悲、乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">4.3.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95"><span class="toc-number">4.4.</span> <span class="toc-text">一人一单</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.4.1.</span> <span class="toc-text">初步实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96-%E5%8A%A0%E9%94%81"><span class="toc-number">4.4.2.</span> <span class="toc-text">进一步优化(加锁)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E7%89%88%E6%9C%AC-%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.4.3.</span> <span class="toc-text">最终版本(事务)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.4.</span> <span class="toc-text">并发安全问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">5.1.</span> <span class="toc-text">Redis分布式锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">秒杀优化</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/13/Redis%E5%AE%9E%E6%88%98/" title="Redis实战">Redis实战</a><time datetime="2023-07-13T02:47:40.000Z" title="发表于 2023-07-13 10:47:40">2023-07-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/11/Redis%E5%9F%BA%E7%A1%80/" title="Redis基础">Redis基础</a><time datetime="2023-07-11T06:09:14.000Z" title="发表于 2023-07-11 14:09:14">2023-07-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/04/Linux%E5%85%A5%E9%97%A8/" title="Linux入门">Linux入门</a><time datetime="2023-07-04T02:54:22.000Z" title="发表于 2023-07-04 10:54:22">2023-07-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/04/Redis%E5%85%A5%E9%97%A8/" title="Redis入门">Redis入门</a><time datetime="2023-07-04T02:24:15.000Z" title="发表于 2023-07-04 10:24:15">2023-07-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/02/Git%E5%AD%A6%E4%B9%A0/" title="Git版本控制工具">Git版本控制工具</a><time datetime="2023-07-02T15:49:02.000Z" title="发表于 2023-07-02 23:49:02">2023-07-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By wzy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>